#define EXTERN extern
#include "pdftexd.h"




boolean initterminal(void) {
    register boolean Result;
    initterminal_regmem topenin();
    if (last > first) {
        curinput.locfield = first;
        while ((curinput.locfield < last) && (buffer[curinput.locfield] == ' '))
            incr(curinput.locfield);
        if (curinput.locfield < last) {
            Result = true;
            return Result;
        }
    }
    while (true) {

        ;
        Fputs(stdout, "**");
        fflush(stdout);
        if (!inputln(stdin, true)) {
            putc('\n', stdout);
            fprintf(stdout, "%s\n", "! End of file on the terminal... why?");
            Result = false;
            return Result;
        }
        curinput.locfield = first;
        while ((curinput.locfield < last) &&
               (buffer[curinput.locfield] == /* str ' ' */ 32))
            incr(curinput.locfield);
        if (curinput.locfield < last) {
            Result = true;
            return Result;
        }
        fprintf(stdout, "%s\n", "Please type the name of your input file.");
    }
    return Result;
}
strnumber makestring(void) {
    register strnumber Result;
    makestring_regmem if (strptr == maxstrings)
        overflow(/* str 'number of strings' */ 260, maxstrings - initstrptr);
    incr(strptr);
    strstart[strptr] = poolptr;
    Result = strptr - 1;
    return Result;
}
boolean zstreqbuf(strnumber s, integer k) {
    register boolean Result;
    streqbuf_regmem poolpointer j;
    boolean result;
    j = strstart[s];
    while (j < strstart[s + 1]) {

        if (strpool[j] != buffer[k]) {
            result = false;
            goto labstreqbuf45not_found;
        }
        incr(j);
        incr(k);
    }
    result = true;
labstreqbuf45not_found:
    Result = result;
    return Result;
}
boolean zstreqstr(strnumber s, strnumber t) {
    register boolean Result;
    streqstr_regmem poolpointer j, k;
    boolean result;
    result = false;
    if ((strstart[s + 1] - strstart[s]) != (strstart[t + 1] - strstart[t]))
        goto labstreqstr45not_found;
    j = strstart[s];
    k = strstart[t];
    while (j < strstart[s + 1]) {

        if (strpool[j] != strpool[k])
            goto labstreqstr45not_found;
        incr(j);
        incr(k);
    }
    result = true;
labstreqstr45not_found:
    Result = result;
    return Result;
}
/* comment:Declare additional routines for string recycling */ 
strnumber zsearchstring(strnumber search) {
    register strnumber Result;
    searchstring_regmem strnumber result;
    strnumber s;
    integer len;
    result = 0;
    len = (strstart[search + 1] - strstart[search]);
    if (len == 0) {
        result = /* str '' */ 345;
        goto labsearchstring40found;
    } else {

        s = search - 1;
        while (s > 255) {

            if ((strstart[s + 1] - strstart[s]) == len) {

                if (streqstr(s, search)) {
                    result = s;
                    goto labsearchstring40found;
                }
            }
            decr(s);
        }
    }
labsearchstring40found:
    Result = result;
    return Result;
}
strnumber slowmakestring(void) {
    register strnumber Result;
    slowmakestring_regmem strnumber s;
    strnumber t;
    t = makestring();
    s = searchstring(t);
    if (s > 0) {
        {
            decr(strptr);
            poolptr = strstart[strptr];
        }
        Result = s;
        return Result;
    }
    Result = t;
    return Result;
}

void terminput(void) {
    terminput_regmem integer k;
    fflush(stdout);
    if (!inputln(stdin, true))
        fatalerror(/* str 'End of file on the terminal!' */ 263);
    termoffset = 0;
    decr(selector);
    k = first;
    while (k < last) {

        printbuffer(k);
    }
    println();
    incr(selector);
}
void zinterror(integer n) {
    interror_regmem print(/* str ' (' */ 286);
    printint(n);
    printchar(/* str ')' */ 41);
    error();
}
void normalizeselector(void) {
    normalizeselector_regmem if (logopened) selector = TERMANDLOG;
    else selector = TERMONLY;
    if (jobname == 0)
        openlogfile();
    if (interaction == BATCHMODE)
        decr(selector);
}
void pauseforinstructions(void) {
    pauseforinstructions_regmem if (OKtointerrupt) {
        interaction = ERRORSTOPMODE;
        if ((selector == LOGONLY) || (selector == NOPRINT))
            incr(selector);
        {
            if (interaction == ERRORSTOPMODE)
                ;
            if (filelineerrorstylep)
                printfileline();
            else
                printnl(/* str '! ' */ 264);
            print(/* str 'Interruption' */ 296);
        }
        {
            helpptr = 3;
            helpline[2] = /* str 'You rang?' */ 297;
            helpline[1] =
                /* str 'Try to insert some instructions for me (e.g.,`I\s' */
                298;
            helpline[0] =
                /* str 'unless you just want to quit by typing `X'.' */ 299;
        }
        deletionsallowed = false;
        error();
        deletionsallowed = true;
        interrupt = 0;
    }
}





void pushnest(void) {
    pushnest_regmem if (nestptr > maxneststack) {
        maxneststack = nestptr;
        if (nestptr == nestsize)
            overflow(/* str 'semantic nest size' */ 378, nestsize);
    }
    nest[nestptr] = curlist;
    incr(nestptr);
    curlist.headfield = getavail();
    curlist.tailfield = curlist.headfield;
    curlist.pgfield = 0;
    curlist.mlfield = line;
    curlist.eTeXauxfield = TEXNULL;
}
void popnest(void) {
    popnest_regmem {
        mem[curlist.headfield].hh.v.RH = avail;
        avail = curlist.headfield;
        mem[curlist.headfield].hh.me = 0;
        ;
#ifdef STAT
        decr(dynused);
#endif /* STAT */
    }
    decr(nestptr);
    curlist = nest[nestptr];
}

halfword zidlookup(integer j, integer l) {
    register halfword Result;
    idlookup_regmem integer h;
    integer d;
    halfword p;
    halfword k;
    /* comment:Compute the hash code |h| */ h = buffer[j];
    {
        register integer for_end;
        k = j + 1;
        for_end = j + l - 1;
        if (k <= for_end)
            do {
                h = h + h + buffer[k];
                while (h >= HASHPRIME)
                    h = h - HASHPRIME;
            } while (k++ < for_end);
    }
    p = h + HASHBASE;
    while (true) {

        if (hash[p].v.RH > 0) {

            if ((strstart[hash[p].v.RH + 1] - strstart[hash[p].v.RH]) == l) {

                if (streqbuf(hash[p].v.RH, j))
                    goto labidlookup40found;
            }
        }
        if (hash[p].v.LH == 0) {
            if (nonewcontrolsequence)
                p = UNDEFINEDCONTROLSEQUENCE;
            else /* comment:Insert a new control sequence after |p|, then make
                  */
            {

                if (hash[p].v.RH > 0) {
                    if (hashhigh < hashextra) {
                        incr(hashhigh);
                        hash[p].v.LH = hashhigh + EQTBSIZE;
                        p = hashhigh + EQTBSIZE;
                    } else {

                        do {
                            if ((hashused == HASHBASE))
                                overflow(/* str 'hash size' */ 578,
                                         HASHSIZE + hashextra);
                            decr(hashused);
                        } while (!(hash[hashused].v.RH == 0));
                        hash[p].v.LH = hashused;
                        p = hashused;
                    }
                }
                {
                    if (poolptr + l > poolsize)
                        overflow(/* str 'pool size' */ 259,
                                 poolsize - initpoolptr);
                }
                d = (poolptr - strstart[strptr]);
                while (poolptr > strstart[strptr]) {

                    decr(poolptr);
                    strpool[poolptr + l] = strpool[poolptr];
                }
                {
                    register integer for_end;
                    k = j;
                    for_end = j + l - 1;
                    if (k <= for_end)
                        do {
                            strpool[poolptr] = buffer[k];
                            incr(poolptr);
                        } while (k++ < for_end);
                }
                hash[p].v.RH = makestring();
                poolptr = poolptr + d;
                ;
#ifdef STAT
                incr(cscount);
#endif /* STAT */
            }
            goto labidlookup40found;
        }
        p = hash[p].v.LH;
    }
labidlookup40found:
    Result = p;
    return Result;
}
halfword zprimlookup(strnumber s) {
    register halfword Result;
    primlookup_regmem integer h;
    halfword p;
    halfword k;
    integer j, l;
    if (s <= BIGGESTCHAR) {
        if (s < 0) {
            p = UNDEFINEDPRIMITIVE;
            goto labprimlookup40found;
        } else
            p = (s % /* @d3623@ */ 1777) /* @d3624@ */ + 1;
    } else {

        j = strstart[s];
        if (s == strptr)
            l = (poolptr - strstart[strptr]);
        else
            l = (strstart[s + 1] - strstart[s]);
        /* comment:Compute the primitive code |h| */ h = strpool[j];
        {
            register integer for_end;
            k = j + 1;
            for_end = j + l - 1;
            if (k <= for_end)
                do {
                    h = h + h + strpool[k];
                    while (h >= PRIMPRIME)
                        h = h - PRIMPRIME;
                } while (k++ < for_end);
        }
        p = h + PRIMBASE;
    }
    while (true) {

        if (prim[p].v.RH > /* @d3629@ */ 256) {
            if ((strstart[prim[p].v.RH + 0] - strstart[prim[p].v.RH - 1]) ==
                l) {

                if (streqstr(prim[p].v.RH - 1, s))
                    goto labprimlookup40found;
            }
        } else if (prim[p].v.RH == 1 + s)
            goto labprimlookup40found;
        if (prim[p].v.LH == 0) {
            if (nonewcontrolsequence)
                p = UNDEFINEDPRIMITIVE;
            else /* comment:Insert a new primitive after |p|, then make |p| po
                  */
            {

                if (prim[p].v.RH > 0) {
                    do {
                        if ((primused == PRIMBASE))
                            overflow(/* str 'primitive size' */ 579, PRIMSIZE);
                        decr(primused);
                    } while (!(prim[primused].v.RH == 0));
                    prim[p].v.LH = primused;
                    p = primused;
                }
                prim[p].v.RH = s + 1;
            }
            goto labprimlookup40found;
        }
        p = prim[p].v.LH;
    }
labprimlookup40found:
    Result = p;
    return Result;
}
/* comment:Declare \eTeX\ procedures for tracing and input */
#ifdef STAT
void zrestoretrace(halfword p, strnumber s) {
    restoretrace_regmem begindiagnostic();
    printchar(/* str '{' */ 123);
    print(s);
    printchar(/* str ' ' */ 32);
    showeqtb(p);
    printchar(/* str '}' */ 125);
    enddiagnostic(false);
}
#endif /* STAT */
void zprintgroup(boolean e) {
    printgroup_regmem switch (curgroup) {
    case BOTTOMLEVEL: {
        print(/* str 'bottom level' */ 1981);
        return;
    } break;
    case SIMPLEGROUP:
    case SEMISIMPLEGROUP: {
        if (curgroup == SEMISIMPLEGROUP)
            print(/* str 'semi ' */ 1982);
        print(/* str 'simple' */ 1983);
    } break;
    case HBOXGROUP:
    case ADJUSTEDHBOXGROUP: {
        if (curgroup == ADJUSTEDHBOXGROUP)
            print(/* str 'adjusted ' */ 1984);
        print(/* str 'hbox' */ 1474);
    } break;
    case VBOXGROUP:
        print(/* str 'vbox' */ 1383);
        break;
    case VTOPGROUP:
        print(/* str 'vtop' */ 1473);
        break;
    case ALIGNGROUP:
    case NOALIGNGROUP: {
        if (curgroup == NOALIGNGROUP)
            print(/* str 'no ' */ 1985);
        print(/* str 'align' */ 1986);
    } break;
    case OUTPUTGROUP:
        print(/* str 'output' */ 414);
        break;
    case DISCGROUP:
        print(/* str 'disc' */ 1987);
        break;
    case INSERTGROUP:
        print(/* str 'insert' */ 337);
        break;
    case VCENTERGROUP:
        print(/* str 'vcenter' */ 619);
        break;
    case MATHGROUP:
    case MATHCHOICEGROUP:
    case MATHSHIFTGROUP:
    case MATHLEFTGROUP: {
        print(/* str 'math' */ 351);
        if (curgroup == MATHCHOICEGROUP)
            print(/* str ' choice' */ 1988);
        else if (curgroup == MATHSHIFTGROUP)
            print(/* str ' shift' */ 1989);
        else if (curgroup == MATHLEFTGROUP)
            print(/* str ' left' */ 1990);
    } break;
    }
    print(/* str ' group (level ' */ 1991);
    printint(curlevel);
    printchar(/* str ')' */ 41);
    if (savestack[saveptr - 1].cint != 0) {
        if (e)
            print(/* str ' entered at line ' */ 380);
        else
            print(/* str ' at line ' */ 1992);
        printint(savestack[saveptr - 1].cint);
    }
}
#ifdef STAT
void zgrouptrace(boolean e) {
    grouptrace_regmem begindiagnostic();
    printchar(/* str '{' */ 123);
    if (e)
        print(/* str 'leaving ' */ 1993);
    else
        print(/* str 'entering ' */ 1994);
    printgroup(e);
    printchar(/* str '}' */ 125);
    enddiagnostic(false);
}
#endif /* STAT */
boolean pseudoinput(void) {
    register boolean Result;
    pseudoinput_regmem halfword p;
    integer sz;
    fourquarters w;
    halfword r;
    last = first;
    p = mem[pseudofiles].hh.v.LH;
    if (p == TEXNULL)
        Result = false;
    else {

        mem[pseudofiles].hh.v.LH = mem[p].hh.v.RH;
        sz = mem[p].hh.v.LH;
        if (4 * sz - 3 >= bufsize - last) /* comment:Report overflow of the
                                             input buffer, and abort */
        {
            curinput.locfield = first;
            curinput.limitfield = last - 1;
            overflow(/* str 'buffer size' */ 258, bufsize);
        }
        last = first;
        {
            register integer for_end;
            r = p + 1;
            for_end = p + sz - 1;
            if (r <= for_end)
                do {
                    w = mem[r].qqqq;
                    buffer[last] = w.b0;
                    buffer[last + 1] = w.b1;
                    buffer[last + 2] = w.b2;
                    buffer[last + 3] = w.b3;
                    last = last + 4;
                } while (r++ < for_end);
        }
        if (last >= maxbufstack)
            maxbufstack = last + 1;
        while ((last > first) && (buffer[last - 1] == /* str ' ' */ 32))
            decr(last);
        freenode(p, sz);
        Result = true;
    }
    return Result;
}
void pseudoclose(void) {
    pseudoclose_regmem halfword p, q;
    p = mem[pseudofiles].hh.v.RH;
    q = mem[pseudofiles].hh.v.LH;
    {
        mem[pseudofiles].hh.v.RH = avail;
        avail = pseudofiles;
        mem[pseudofiles].hh.me = 0;
        ;
#ifdef STAT
        decr(dynused);
#endif /* STAT */
    }
    pseudofiles = p;
    while (q != TEXNULL) {

        p = q;
        q = mem[p].hh.v.RH;
        freenode(p, mem[p].hh.v.LH);
    }
}
void groupwarning(void) {
    groupwarning_regmem integer i;
    boolean w;
    baseptr = inputptr;
    inputstack[baseptr] = curinput;
    i = inopen;
    w = false;
    while ((grpstack[i] == curboundary) && (i > 0)) {

        /* comment:Set variable |w| to indicate if this case should b */
        if (eqtb[INTBASE + TRACINGNESTINGCODE].cint > 0) {
            while ((inputstack[baseptr].statefield == TOKENLIST) ||
                   (inputstack[baseptr].indexfield > i))
                decr(baseptr);
            if (inputstack[baseptr].namefield > 17)
                w = true;
        }
        grpstack[i] = savestack[saveptr].hh.v.RH;
        decr(i);
    }
    if (w) {
        printnl(/* str 'Warning' */ 2043);
        printgroup(true);
        print(/* str ' of a different file' */ 2044);
        println();
        if (eqtb[INTBASE + TRACINGNESTINGCODE].cint > 1)
            showcontext();
        if (history == SPOTLESS)
            history = WARNINGISSUED;
    }
}
void ifwarning(void) {
    ifwarning_regmem integer i;
    boolean w;
    baseptr = inputptr;
    inputstack[baseptr] = curinput;
    i = inopen;
    w = false;
    while (ifstack[i] == condptr) {

        /* comment:Set variable |w| to indicate if this case should b */
        if (eqtb[INTBASE + TRACINGNESTINGCODE].cint > 0) {
            while ((inputstack[baseptr].statefield == TOKENLIST) ||
                   (inputstack[baseptr].indexfield > i))
                decr(baseptr);
            if (inputstack[baseptr].namefield > 17)
                w = true;
        }
        ifstack[i] = mem[condptr].hh.v.RH;
        decr(i);
    }
    if (w) {
        printnl(/* str 'Warning' */ 2043);
        printcmdchr(IFTEST, curif);
        if (ifline != 0) {
            print(/* str ' entered on line ' */ 2013);
            printint(ifline);
        }
        print(/* str ' of a different file' */ 2044);
        println();
        if (eqtb[INTBASE + TRACINGNESTINGCODE].cint > 1)
            showcontext();
        if (history == SPOTLESS)
            history = WARNINGISSUED;
    }
}
void filewarning(void) {
    filewarning_regmem halfword p;
    quarterword l;
    quarterword c;
    integer i;
    p = saveptr;
    l = curlevel;
    c = curgroup;
    saveptr = curboundary;
    while (grpstack[inopen] != saveptr) {

        decr(curlevel);
        printnl(/* str 'Warning' */ 2045);
        printgroup(true);
        print(/* str ' is incomplete' */ 2046);
        curgroup = savestack[saveptr].hh.b1;
        saveptr = savestack[saveptr].hh.v.RH;
    }
    saveptr = p;
    curlevel = l;
    curgroup = c;
    p = condptr;
    l = iflimit;
    c = curif;
    i = ifline;
    while (ifstack[inopen] != condptr) {

        printnl(/* str 'Warning' */ 2045);
        printcmdchr(IFTEST, curif);
        if (iflimit == FICODE)
            printesc(/* str 'else' */ 931);
        if (ifline != 0) {
            print(/* str ' entered on line ' */ 2013);
            printint(ifline);
        }
        print(/* str ' is incomplete' */ 2046);
        ifline = mem[condptr + 1].cint;
        curif = mem[condptr].hh.b1;
        iflimit = mem[condptr].hh.b0;
        condptr = mem[condptr].hh.v.RH;
    }
    condptr = p;
    iflimit = l;
    curif = c;
    ifline = i;
    println();
    if (eqtb[INTBASE + TRACINGNESTINGCODE].cint > 1)
        showcontext();
    if (history == SPOTLESS)
        history = WARNINGISSUED;
}
void zdeletesaref(halfword q) {
    deletesaref_regmem halfword p;
    smallnumber i;
    smallnumber s;
    decr(mem[q + 1].hh.v.LH);
    if (mem[q + 1].hh.v.LH != TEXNULL)
        return;
    if (mem[q].hh.b0 < DIMENVALLIMIT) {

        if (mem[q + 2].cint == 0)
            s = WORDNODESIZE;
        else /* @d3742@ */
            return;
    } else {

        if (mem[q].hh.b0 < MUVALLIMIT) {

            if (mem[q + 1].hh.v.RH == membot)
                deleteglueref(membot);
            else /* @d3744@ */
                return;
        } else if (mem[q + 1].hh.v.RH != TEXNULL)
            return;
        s = POINTERNODESIZE;
    }
    do {
        i = mem[q].hh.b0 % 16;
        p = q;
        q = mem[p].hh.v.RH;
        freenode(p, s);
        if (q == TEXNULL) {
            saroot[i] = TEXNULL;
            return;
        }
        {
            if (odd(i))
                mem[q + (i / 2) + 1].hh.v.RH = TEXNULL;
            else
                mem[q + (i / 2) + 1].hh.v.LH = TEXNULL;
            decr(mem[q].hh.b1);
        }
        s = INDEXNODESIZE;
    } while (!(mem[q].hh.b1 > 0));
}
#ifdef STAT
void zshowsa(halfword p, strnumber s) {
    showsa_regmem smallnumber t;
    begindiagnostic();
    printchar(/* str '{' */ 123);
    print(s);
    printchar(/* str ' ' */ 32);
    if (p == TEXNULL)
        printchar(/* str '?' */ 63);
    else {

        t = (mem[p].hh.b0 / 16);
        if (t < 4)
            printcmdchr(REGISTER, p);
        else if (t == 4) {
            printesc(/* str 'box' */ 429);
            printsanum(p);
        } else if (t == TOKVAL)
            printcmdchr(TOKSREGISTER, p);
        else
            printchar(/* str '?' */ 63);
        printchar(/* str '=' */ 61);
        if (t == INTVAL)
            printint(mem[p + 2].cint);
        else if (t == DIMENVAL) {
            printscaled(mem[p + 2].cint);
            print(/* str 'pt' */ 312);
        } else {

            p = mem[p + 1].hh.v.RH;
            if (t == GLUEVAL)
                printspec(p, /* str 'pt' */ 312);
            else if (t == MUVAL)
                printspec(p, /* str 'mu' */ 344);
            else if (t == 4) {

                if (p == TEXNULL)
                    print(/* str 'void' */ 430);
                else {

                    depththreshold = 0;
                    breadthmax = 1;
                    shownodelist(p);
                }
            } else if (t == TOKVAL) {
                if (p != TEXNULL)
                    showtokenlist(mem[p].hh.v.RH, TEXNULL, 32);
            } else
                printchar(/* str '?' */ 63);
        }
    }
    printchar(/* str '}' */ 125);
    enddiagnostic(false);
}
#endif /* STAT */
void zsasave(halfword p) {
    sasave_regmem halfword q;
    quarterword i;
    if (curlevel != salevel) {
        if (saveptr > maxsavestack) {
            maxsavestack = saveptr;
            if (maxsavestack > savesize - 7)
                overflow(/* str 'save size' */ 621, savesize);
        }
        savestack[saveptr].hh.b0 = RESTORESA;
        savestack[saveptr].hh.b1 = salevel;
        savestack[saveptr].hh.v.RH = sachain;
        incr(saveptr);
        sachain = TEXNULL;
        salevel = curlevel;
    }
    i = mem[p].hh.b0;
    if (i < DIMENVALLIMIT) {
        if (mem[p + 2].cint == 0) {
            q = getnode(POINTERNODESIZE);
            i = TOKVALLIMIT;
        } else {

            q = getnode(WORDNODESIZE);
            mem[q + 2].cint = mem[p + 2].cint;
        }
        mem[q + 1].hh.v.RH = TEXNULL;
    } else {

        q = getnode(POINTERNODESIZE);
        mem[q + 1].hh.v.RH = mem[p + 1].hh.v.RH;
    }
    mem[q + 1].hh.v.LH = p;
    mem[q].hh.b0 = i;
    mem[q].hh.b1 = mem[p].hh.b1;
    mem[q].hh.v.RH = sachain;
    sachain = q;
    incr(mem[p + 1].hh.v.LH);
}
void zsadestroy(halfword p) {
    sadestroy_regmem if (mem[p].hh.b0 < MUVALLIMIT)
        deleteglueref(mem[p + 1].hh.v.RH);
    else if (mem[p + 1].hh.v.RH != TEXNULL) {

        if (mem[p].hh.b0 < BOXVALLIMIT)
            flushnodelist(mem[p + 1].hh.v.RH);
        else
            deletetokenref(mem[p + 1].hh.v.RH);
    }
}
void zsadef(halfword p, halfword e) {
    sadef_regmem incr(mem[p + 1].hh.v.LH);
    if (mem[p + 1].hh.v.RH == e) {
        ;
#ifdef STAT
        if (eqtb[INTBASE + TRACINGASSIGNSCODE].cint > 0)
            showsa(p, /* str 'reassigning' */ 623);
#endif /* STAT */
        sadestroy(p);
    } else {

        ;
#ifdef STAT
        if (eqtb[INTBASE + TRACINGASSIGNSCODE].cint > 0)
            showsa(p, /* str 'changing' */ 624);
#endif /* STAT */
        if (mem[p].hh.b1 == curlevel)
            sadestroy(p);
        else
            sasave(p);
        mem[p].hh.b1 = curlevel;
        mem[p + 1].hh.v.RH = e;
        ;
#ifdef STAT
        if (eqtb[INTBASE + TRACINGASSIGNSCODE].cint > 0)
            showsa(p, /* str 'into' */ 625);
#endif /* STAT */
    }
    deletesaref(p);
}
void zsawdef(halfword p, integer w) {
    sawdef_regmem incr(mem[p + 1].hh.v.LH);
    if (mem[p + 2].cint == w) {
        ;
#ifdef STAT
        if (eqtb[INTBASE + TRACINGASSIGNSCODE].cint > 0)
            showsa(p, /* str 'reassigning' */ 623);
#endif /* STAT */
    } else {

        ;
#ifdef STAT
        if (eqtb[INTBASE + TRACINGASSIGNSCODE].cint > 0)
            showsa(p, /* str 'changing' */ 624);
#endif /* STAT */
        if (mem[p].hh.b1 != curlevel)
            sasave(p);
        mem[p].hh.b1 = curlevel;
        mem[p + 2].cint = w;
        ;
#ifdef STAT
        if (eqtb[INTBASE + TRACINGASSIGNSCODE].cint > 0)
            showsa(p, /* str 'into' */ 625);
#endif /* STAT */
    }
    deletesaref(p);
}
void zgsadef(halfword p, halfword e) {
    gsadef_regmem incr(mem[p + 1].hh.v.LH);
    ;
#ifdef STAT
    if (eqtb[INTBASE + TRACINGASSIGNSCODE].cint > 0)
        showsa(p, /* str 'globally changing' */ 626);
#endif /* STAT */
    sadestroy(p);
    mem[p].hh.b1 = LEVELONE;
    mem[p + 1].hh.v.RH = e;
    ;
#ifdef STAT
    if (eqtb[INTBASE + TRACINGASSIGNSCODE].cint > 0)
        showsa(p, /* str 'into' */ 625);
#endif /* STAT */
    deletesaref(p);
}
void zgsawdef(halfword p, integer w) {
    gsawdef_regmem incr(mem[p + 1].hh.v.LH);
    ;
#ifdef STAT
    if (eqtb[INTBASE + TRACINGASSIGNSCODE].cint > 0)
        showsa(p, /* str 'globally changing' */ 626);
#endif /* STAT */
    mem[p].hh.b1 = LEVELONE;
    mem[p + 2].cint = w;
    ;
#ifdef STAT
    if (eqtb[INTBASE + TRACINGASSIGNSCODE].cint > 0)
        showsa(p, /* str 'into' */ 625);
#endif /* STAT */
    deletesaref(p);
}
void sarestore(void) {
    sarestore_regmem halfword p;
    do {
        p = mem[sachain + 1].hh.v.LH;
        if (mem[p].hh.b1 == LEVELONE) {
            if (mem[p].hh.b0 >= DIMENVALLIMIT)
                sadestroy(sachain);
            ;
#ifdef STAT
            if (eqtb[INTBASE + TRACINGRESTORESCODE].cint > 0)
                showsa(p, /* str 'retaining' */ 628);
#endif /* STAT */
        } else {

            if (mem[p].hh.b0 < DIMENVALLIMIT) {

                if (mem[sachain].hh.b0 < DIMENVALLIMIT)
                    mem[p + 2].cint = mem[sachain + 2].cint;
                else
                    mem[p + 2].cint = 0;
            } else {

                sadestroy(p);
                mem[p + 1].hh.v.RH = mem[sachain + 1].hh.v.RH;
            }
            mem[p].hh.b1 = mem[sachain].hh.b1;
            ;
#ifdef STAT
            if (eqtb[INTBASE + TRACINGRESTORESCODE].cint > 0)
                showsa(p, /* str 'restoring' */ 629);
#endif /* STAT */
        }
        deletesaref(p);
        p = sachain;
        sachain = mem[p].hh.v.RH;
        if (mem[p].hh.b0 < DIMENVALLIMIT)
            freenode(p, WORDNODESIZE);
        else
            freenode(p, POINTERNODESIZE);
    } while (!(sachain == TEXNULL));
}
void znewsavelevel(groupcode c) {
    newsavelevel_regmem if (saveptr > maxsavestack) {
        maxsavestack = saveptr;
        if (maxsavestack > savesize - 7)
            overflow(/* str 'save size' */ 621, savesize);
    }
    if ((eTeXmode == 1)) {
        savestack[saveptr + 0].cint = line;
        incr(saveptr);
    }
    savestack[saveptr].hh.b0 = LEVELBOUNDARY;
    savestack[saveptr].hh.b1 = curgroup;
    savestack[saveptr].hh.v.RH = curboundary;
    if (curlevel == MAXQUARTERWORD)
        overflow(/* str 'grouping levels' */ 622,
                 /* @d3828@ */ /* @d3829@ */ 255);
    curboundary = saveptr;
    curgroup = c;
    ;
#ifdef STAT
    if (eqtb[INTBASE + TRACINGGROUPSCODE].cint > 0)
        grouptrace(false);
#endif /* STAT */
    incr(curlevel);
    incr(saveptr);
}
void zeqdestroy(memoryword w) {
    eqdestroy_regmem halfword q;
    switch (w.hh.b0) {
    case CALL:
    case LONGCALL:
    case OUTERCALL:
    case LONGOUTERCALL:
        deletetokenref(w.hh.v.RH);
        break;
    case GLUEREF:
        deleteglueref(w.hh.v.RH);
        break;
    case SHAPEREF: {
        q = w.hh.v.RH;
        if (q != TEXNULL)
            freenode(q, mem[q].hh.v.LH + mem[q].hh.v.LH + 1);
    } break;
    case BOXREF:
        flushnodelist(w.hh.v.RH);
        break;
    /* comment:Cases for |eq_destroy| */ case TOKSREGISTER:
    case REGISTER:
        if ((w.hh.v.RH < membot) ||
            (w.hh.v.RH > /* @d3842@ */ /* @d3843@ */ /* @d3844@ */ /* @d3845@ */
                             /* @d3846@ */ membot + 19))
            deletesaref(w.hh.v.RH);
        break;
    default:;
        break;
    }
}
void zeqsave(halfword p, quarterword l) {
    eqsave_regmem if (saveptr > maxsavestack) {
        maxsavestack = saveptr;
        if (maxsavestack > savesize - 7)
            overflow(/* str 'save size' */ 621, savesize);
    }
    if (l == LEVELZERO)
        savestack[saveptr].hh.b0 = RESTOREZERO;
    else {

        savestack[saveptr] = eqtb[p];
        incr(saveptr);
        savestack[saveptr].hh.b0 = RESTOREOLDVALUE;
    }
    savestack[saveptr].hh.b1 = l;
    savestack[saveptr].hh.v.RH = p;
    incr(saveptr);
}
void zeqdefine(halfword p, quarterword t, halfword e) {
    eqdefine_regmem if ((eTeXmode == 1) && (eqtb[p].hh.b0 == t) &&
                        (eqtb[p].hh.v.RH == e)) {
        ;
#ifdef STAT
        if (eqtb[INTBASE + TRACINGASSIGNSCODE].cint > 0)
            restoretrace(p, /* str 'reassigning' */ 623);
#endif /* STAT */
        eqdestroy(eqtb[p]);
        return;
    };
#ifdef STAT
    if (eqtb[INTBASE + TRACINGASSIGNSCODE].cint > 0)
        restoretrace(p, /* str 'changing' */ 624);
#endif /* STAT */
    if (eqtb[p].hh.b1 == curlevel)
        eqdestroy(eqtb[p]);
    else if (curlevel > LEVELONE)
        eqsave(p, eqtb[p].hh.b1);
    eqtb[p].hh.b1 = curlevel;
    eqtb[p].hh.b0 = t;
    eqtb[p].hh.v.RH = e;
    ;
#ifdef STAT
    if (eqtb[INTBASE + TRACINGASSIGNSCODE].cint > 0)
        restoretrace(p, /* str 'into' */ 625);
#endif /* STAT */
}
void zeqworddefine(halfword p, integer w) {
    eqworddefine_regmem if ((eTeXmode == 1) && (eqtb[p].cint == w)) {
        ;
#ifdef STAT
        if (eqtb[INTBASE + TRACINGASSIGNSCODE].cint > 0)
            restoretrace(p, /* str 'reassigning' */ 623);
#endif /* STAT */
        return;
    };
#ifdef STAT
    if (eqtb[INTBASE + TRACINGASSIGNSCODE].cint > 0)
        restoretrace(p, /* str 'changing' */ 624);
#endif /* STAT */
    if (xeqlevel[p] != curlevel) {
        eqsave(p, xeqlevel[p]);
        xeqlevel[p] = curlevel;
    }
    eqtb[p].cint = w;
    ;
#ifdef STAT
    if (eqtb[INTBASE + TRACINGASSIGNSCODE].cint > 0)
        restoretrace(p, /* str 'into' */ 625);
#endif /* STAT */
}
void zgeqdefine(halfword p, quarterword t, halfword e) {
    geqdefine_regmem;
#ifdef STAT
    if (eqtb[INTBASE + TRACINGASSIGNSCODE].cint > 0)
        restoretrace(p, /* str 'globally changing' */ 626);
#endif /* STAT */
    {
        eqdestroy(eqtb[p]);
        eqtb[p].hh.b1 = LEVELONE;
        eqtb[p].hh.b0 = t;
        eqtb[p].hh.v.RH = e;
    };
#ifdef STAT
    if (eqtb[INTBASE + TRACINGASSIGNSCODE].cint > 0)
        restoretrace(p, /* str 'into' */ 625);
#endif /* STAT */
}
void zgeqworddefine(halfword p, integer w) {
    geqworddefine_regmem;
#ifdef STAT
    if (eqtb[INTBASE + TRACINGASSIGNSCODE].cint > 0)
        restoretrace(p, /* str 'globally changing' */ 626);
#endif /* STAT */
    {
        eqtb[p].cint = w;
        xeqlevel[p] = LEVELONE;
    };
#ifdef STAT
    if (eqtb[INTBASE + TRACINGASSIGNSCODE].cint > 0)
        restoretrace(p, /* str 'into' */ 625);
#endif /* STAT */
}
void zsaveforafter(halfword t) {
    saveforafter_regmem if (curlevel > LEVELONE) {
        if (saveptr > maxsavestack) {
            maxsavestack = saveptr;
            if (maxsavestack > savesize - 7)
                overflow(/* str 'save size' */ 621, savesize);
        }
        savestack[saveptr].hh.b0 = INSERTTOKEN;
        savestack[saveptr].hh.b1 = LEVELZERO;
        savestack[saveptr].hh.v.RH = t;
        savestack[saveptr].hh.me = curchrsig;
        incr(saveptr);
    }
}
void unsave(void) {
    unsave_regmem halfword p;
    quarterword l;
    halfword t;
    boolean a;
    a = false;
    if (curlevel > LEVELONE) {
        decr(curlevel);
        /* comment:Clear off top level from |save_stack| */ while (true) {

            decr(saveptr);
            if (savestack[saveptr].hh.b0 == LEVELBOUNDARY)
                goto labunsave30done;
            p = savestack[saveptr].hh.v.RH;
            if (savestack[saveptr].hh.b0 ==
                INSERTTOKEN) /* comment:Insert token |p| into \TeX's input
                              */
            {
                t = curtok;
                curtok = p;
                if (a) {
                    p = getavail();
                    mem[p].hh.v.LH = curtok;
                    mem[p].hh.v.RH = curinput.locfield;
                    curinput.locfield = p;
                    curinput.startfield = p;
                    if (curtok < RIGHTBRACELIMIT) {

                        if (curtok < LEFTBRACELIMIT)
                            decr(alignstate);
                        else
                            incr(alignstate);
                    }
                } else {

                    backinput();
                    a = (eTeXmode == 1);
                }
                curtok = t;
            } else if (savestack[saveptr].hh.b0 == RESTORESA) {
                sarestore();
                sachain = p;
                salevel = savestack[saveptr].hh.b1;
            } else {

                if (savestack[saveptr].hh.b0 == RESTOREOLDVALUE) {
                    l = savestack[saveptr].hh.b1;
                    decr(saveptr);
                } else
                    savestack[saveptr] = eqtb[UNDEFINEDCONTROLSEQUENCE];
                /* comment:Store \(s)|save_stack[save_ptr]| in |eqtb[p]|, unl */
                if ((p < INTBASE) || (p > EQTBSIZE)) {

                    if (eqtb[p].hh.b1 == LEVELONE) {
                        eqdestroy(savestack[saveptr]);
                        ;
#ifdef STAT
                        if (eqtb[INTBASE + TRACINGRESTORESCODE].cint > 0)
                            restoretrace(p, /* str 'retaining' */ 628);
#endif /* STAT */
                    } else {

                        eqdestroy(eqtb[p]);
                        eqtb[p] = savestack[saveptr];
                        ;
#ifdef STAT
                        if (eqtb[INTBASE + TRACINGRESTORESCODE].cint > 0)
                            restoretrace(p, /* str 'restoring' */ 629);
#endif /* STAT */
                    }
                } else if (xeqlevel[p] != LEVELONE) {
                    eqtb[p] = savestack[saveptr];
                    xeqlevel[p] = l;
                    ;
#ifdef STAT
                    if (eqtb[INTBASE + TRACINGRESTORESCODE].cint > 0)
                        restoretrace(p, /* str 'restoring' */ 629);
#endif /* STAT */
                } else {

                    ;
#ifdef STAT
                    if (eqtb[INTBASE + TRACINGRESTORESCODE].cint > 0)
                        restoretrace(p, /* str 'retaining' */ 628);
#endif /* STAT */
                }
            }
        }
    labunsave30done:;
#ifdef STAT
        if (eqtb[INTBASE + TRACINGGROUPSCODE].cint > 0)
            grouptrace(true);
#endif /* STAT */
        if (grpstack[inopen] == curboundary)
            groupwarning();
        curgroup = savestack[saveptr].hh.b1;
        curboundary = savestack[saveptr].hh.v.RH;
        if ((eTeXmode == 1))
            decr(saveptr);
    } else
        confusion(/* str 'curlevel' */ 627);
}
void preparemag(void) {
    preparemag_regmem if ((magset > 0) &&
                          (eqtb[INTBASE + MAGCODE].cint != magset)) {
        {
            if (interaction == ERRORSTOPMODE)
                ;
            if (filelineerrorstylep)
                printfileline();
            else
                printnl(/* str '! ' */ 264);
            print(/* str 'Incompatible magnification (' */ 631);
        }
        printint(eqtb[INTBASE + MAGCODE].cint);
        print(/* str ');' */ 632);
        printnl(/* str ' the previous value will be retained' */ 633);
        {
            helpptr = 2;
            helpline[1] =
                /* str 'I can handle only one magnification ratio per job' */
                634;
            helpline[0] =
                /* str 'reverted to the magnification you used earlier on' */
                635;
        }
        interror(magset);
        geqworddefine(/* @d3938@ */ /* @d3939@ */ 29294, magset);
    }
    if ((eqtb[INTBASE + MAGCODE].cint <= 0) ||
        (eqtb[INTBASE + MAGCODE].cint > 32768L)) {
        {
            if (interaction == ERRORSTOPMODE)
                ;
            if (filelineerrorstylep)
                printfileline();
            else
                printnl(/* str '! ' */ 264);
            print(
                /* str 'Illegal magnification has been changed to 1000' */ 636);
        }
        {
            helpptr = 1;
            helpline[0] =
                /* str 'The magnification ratio must be between 1 and 327' */
                637;
        }
        interror(eqtb[INTBASE + MAGCODE].cint);
        geqworddefine(/* @d3950@ */ /* @d3951@ */ 29294, 1000);
    }
    magset = eqtb[INTBASE + MAGCODE].cint;
}
void ztokenshow(halfword p) {
    tokenshow_regmem if (p != TEXNULL)
        showtokenlist(mem[p].hh.v.RH, TEXNULL, 10000000L);
}
void printmeaning(void) {
    printmeaning_regmem printcmdchr(curcmd, curchr);
    if (curcmd >= CALL) {
        printchar(/* str '' */ 58);
        println();
        tokenshow(curchr);
    } else if ((curcmd == TOPBOTMARK) && (curchr < 5)) {
        printchar(/* str '' */ 58);
        println();
        tokenshow(curmark[curchr]);
    }
}
void showcurcmdchr(void) {
    showcurcmdchr_regmem integer n;
    integer l;
    halfword p;
    begindiagnostic();
    printnl(/* str '{' */ 123);
    if (curlist.modefield != shownmode) {
        printmode(curlist.modefield);
        print(/* str '' */ 651);
        shownmode = curlist.modefield;
    }
    printcmdchr(curcmd, curchr);
    if (eqtb[INTBASE + TRACINGIFSCODE].cint > 0) {

        if (curcmd >= IFTEST) {

            if (curcmd <= FIORELSE) {
                print(/* str '' */ 651);
                if (curcmd == FIORELSE) {
                    printcmdchr(IFTEST, curif);
                    printchar(/* str ' ' */ 32);
                    n = 0;
                    l = ifline;
                } else {

                    n = 1;
                    l = line;
                }
                p = condptr;
                while (p != TEXNULL) {

                    incr(n);
                    p = mem[p].hh.v.RH;
                }
                print(/* str '(level ' */ 652);
                printint(n);
                printchar(/* str ')' */ 41);
                if (l != 0) {
                    print(/* str ' entered on line ' */ 2013);
                    printint(l);
                }
            }
        }
    }
    printchar(/* str '}' */ 125);
    enddiagnostic(false);
}
void showcontext(void) {
    showcontext_regmem
        unsigned char oldsetting;
    integer nn;
    boolean bottomline;
    /* comment:Local variables for formatting calculations */ integer i;
    integer j;
    integer l;
    integer m;
    integer n;
    integer p;
    integer q;
    baseptr = inputptr;
    inputstack[baseptr] = curinput;
    nn = -1;
    bottomline = false;
    while (true) {

        curinput = inputstack[baseptr];
        if ((curinput.statefield != TOKENLIST)) {

            if ((curinput.namefield > 19) || (baseptr == 0))
                bottomline = true;
        }
        if ((baseptr == inputptr) || bottomline ||
            (nn < eqtb[INTBASE + ERRORCONTEXTLINESCODE]
                      .cint)) /* comment:Display the current context */
        {
            if ((baseptr == inputptr) || (curinput.statefield != TOKENLIST) ||
                (curinput.indexfield != BACKEDUP) ||
                (curinput.locfield != TEXNULL)) {
                tally = 0;
                oldsetting = selector;
                if (curinput.statefield != TOKENLIST) {
                    /* comment:Print location of current line */
                    if (curinput.namefield <= 17) {

                        if ((curinput.namefield == 0)) {

                            if (baseptr == 0)
                                printnl(/* str '<>' */ 657);
                            else
                                printnl(/* str '<insert> ' */ 658);
                        } else {

                            printnl(/* str '<read ' */ 659);
                            if (curinput.namefield == 17)
                                printchar(/* str '' */ 42);
                            else
                                printint(curinput.namefield - 1);
                            printchar(/* str '>' */ 62);
                        }
                    } else if (curinput.indexfield != inopen) {
                        printnl(/* str 'l.' */ 660);
                        printint(linestack[curinput.indexfield + 1]);
                    } else {

                        printnl(/* str 'l.' */ 660);
                        printint(line);
                    }
                    printchar(/* str ' ' */ 32);
                    /* comment:Pseudoprint the line */ {

                        l = tally;
                        tally = 0;
                        selector = PSEUDO;
                        trickcount = 1000000L;
                    }
                    if (buffer[curinput.limitfield] ==
                        eqtb[INTBASE + ENDLINECHARCODE].cint)
                        j = curinput.limitfield;
                    else
                        j = curinput.limitfield + 1;
                    i = curinput.startfield;
                    mubyteskeep = mubytekeep;
                    mubytesstart = mubytestart;
                    mubytestart = false;
                    if (j > 0)
                        while (i < j) {

                            if (i == curinput.locfield) {
                                firstcount = tally;
                                trickcount =
                                    tally + 1 + errorline - halferrorline;
                                if (trickcount < errorline)
                                    trickcount = errorline;
                            }
                            printbuffer(i);
                        }
                    mubytekeep = mubyteskeep;
                    mubytestart = mubytesstart;
                } else {

                    /* comment:Print type of token list */ switch (
                        curinput.indexfield) {
                    case PARAMETER:
                        printnl(/* str '<argument> ' */ 661);
                        break;
                    case UTEMPLATE:
                    case VTEMPLATE:
                        printnl(/* str '<template> ' */ 662);
                        break;
                    case BACKEDUP:
                        if (curinput.locfield == TEXNULL)
                            printnl(/* str '<recently read> ' */ 663);
                        else
                            printnl(/* str '<to be read again> ' */ 664);
                        break;
                    case INSERTED:
                        printnl(/* str '<inserted text> ' */ 665);
                        break;
                    case MACRO: {
                        println();
                        printcs(curinput.namefield);
                    } break;
                    case OUTPUTTEXT:
                        printnl(/* str '<output> ' */ 666);
                        break;
                    case EVERYPARTEXT:
                        printnl(/* str '<everypar> ' */ 667);
                        break;
                    case EVERYMATHTEXT:
                        printnl(/* str '<everymath> ' */ 668);
                        break;
                    case EVERYDISPLAYTEXT:
                        printnl(/* str '<everydisplay> ' */ 669);
                        break;
                    case EVERYHBOXTEXT:
                        printnl(/* str '<everyhbox> ' */ 670);
                        break;
                    case EVERYVBOXTEXT:
                        printnl(/* str '<everyvbox> ' */ 671);
                        break;
                    case EVERYJOBTEXT:
                        printnl(/* str '<everyjob> ' */ 672);
                        break;
                    case EVERYCRTEXT:
                        printnl(/* str '<everycr> ' */ 673);
                        break;
                    case MARKTEXT:
                        printnl(/* str '<mark> ' */ 674);
                        break;
                    case EVERYEOFTEXT:
                        printnl(/* str '<everyeof> ' */ 675);
                        break;
                    case WRITETEXT:
                        printnl(/* str '<write> ' */ 676);
                        break;
                    default:
                        printnl(/* str '?' */ 63);
                        break;
                    }
                    /* comment:Pseudoprint the token list */ {

                        l = tally;
                        tally = 0;
                        selector = PSEUDO;
                        trickcount = 1000000L;
                    }
                    if (curinput.indexfield < MACRO)
                        showtokenlist(curinput.startfield, curinput.locfield,
                                      100000L);
                    else
                        showtokenlist(mem[curinput.startfield].hh.v.RH,
                                      curinput.locfield, 100000L);
                }
                selector = oldsetting;
                /* comment:Print two lines using the tricky pseudoprinted inf */
                if (trickcount == 1000000L) {
                    firstcount = tally;
                    trickcount = tally + 1 + errorline - halferrorline;
                    if (trickcount < errorline)
                        trickcount = errorline;
                }
                if (tally < trickcount)
                    m = tally - firstcount;
                else
                    m = trickcount - firstcount;
                if (l + firstcount <= halferrorline) {
                    p = 0;
                    n = l + firstcount;
                } else {

                    print(/* str '...' */ 277);
                    p = l + firstcount - halferrorline + 3;
                    n = halferrorline;
                }
                {
                    register integer for_end;
                    q = p;
                    for_end = firstcount - 1;
                    if (q <= for_end)
                        do
                            printchar(trickbuf[q % errorline]);
                        while (q++ < for_end);
                }
                println();
                {
                    register integer for_end;
                    q = 1;
                    for_end = n;
                    if (q <= for_end)
                        do
                            printchar(/* str ' ' */ 32);
                        while (q++ < for_end);
                }
                if (m + n <= errorline)
                    p = firstcount + m;
                else
                    p = firstcount + (errorline - n - 3);
                {
                    register integer for_end;
                    q = firstcount;
                    for_end = p - 1;
                    if (q <= for_end)
                        do
                            printchar(trickbuf[q % errorline]);
                        while (q++ < for_end);
                }
                if (m + n > errorline)
                    print(/* str '...' */ 277);
                incr(nn);
            }
        } else if (nn == eqtb[INTBASE + ERRORCONTEXTLINESCODE].cint) {
            printnl(/* str '...' */ 277);
            incr(nn);
        }
        if (bottomline)
            goto labshowcontext30done;
        decr(baseptr);
    }
labshowcontext30done:
    curinput = inputstack[inputptr];
}

void backinput(void) {
    backinput_regmem halfword p;
    while ((curinput.statefield == TOKENLIST) &&
           (curinput.locfield == TEXNULL) && (curinput.indexfield != VTEMPLATE))
        endtokenlist();
    p = getavail();
    mem[p].hh.v.LH = curtok;
    if (curtok < RIGHTBRACELIMIT) {

        if (curtok < LEFTBRACELIMIT)
            decr(alignstate);
        else
            incr(alignstate);
    }
    {
        if (inputptr > maxinstack) {
            maxinstack = inputptr;
            if (inputptr == stacksize)
                overflow(/* str 'input stack size' */ 677, stacksize);
        }
        inputstack[inputptr] = curinput;
        incr(inputptr);
    }
    curinput.statefield = TOKENLIST;
    curinput.startfield = p;
    curinput.indexfield = BACKEDUP;
    curinput.locfield = p;
}
void backerror(void) {
    backerror_regmem OKtointerrupt = false;
    backinput();
    OKtointerrupt = true;
    error();
}
void inserror(void) {
    inserror_regmem OKtointerrupt = false;
    backinput();
    curinput.indexfield = INSERTED;
    OKtointerrupt = true;
    error();
}
void beginfilereading(void) {
    beginfilereading_regmem if (inopen == maxinopen)
        overflow(/* str 'text input levels' */ 680, maxinopen);
    if (first == bufsize)
        overflow(/* str 'buffer size' */ 258, bufsize);
    incr(inopen);
    {
        if (inputptr > maxinstack) {
            maxinstack = inputptr;
            if (inputptr == stacksize)
                overflow(/* str 'input stack size' */ 677, stacksize);
        }
        inputstack[inputptr] = curinput;
        incr(inputptr);
    }
    curinput.indexfield = inopen;
    sourcefilenamestack[curinput.indexfield] = 0;
    fullsourcefilenamestack[curinput.indexfield] = 0;
    eofseen[curinput.indexfield] = false;
    grpstack[curinput.indexfield] = curboundary;
    ifstack[curinput.indexfield] = condptr;
    linestack[curinput.indexfield] = line;
    curinput.startfield = first;
    curinput.statefield = MIDLINE;
    curinput.namefield = 0;
}
void endfilereading(void) {
    endfilereading_regmem first = curinput.startfield;
    line = linestack[curinput.indexfield];
    if ((curinput.namefield == 18) || (curinput.namefield == 19))
        pseudoclose();
    else if (curinput.namefield > 17)
        aclose(inputfile[curinput.indexfield]);
    {
        decr(inputptr);
        curinput = inputstack[inputptr];
    }
    decr(inopen);
}
void clearforerrorprompt(void) {
    clearforerrorprompt_regmem while (
        (curinput.statefield != TOKENLIST) && (curinput.namefield == 0) &&
        (inputptr > 0) && (curinput.locfield > curinput.limitfield))
        endfilereading();
    println();
}
/* comment:Declare additional routines for enc\TeX */ void mubyteupdate(void) {
    mubyteupdate_regmem poolpointer j;
    halfword p;
    halfword q;
    integer inmutree;
    j = strstart[strptr];
    if (mubyteread[strpool[j]] == TEXNULL) {
        inmutree = 0;
        p = getavail();
        mubyteread[strpool[j]] = p;
        mem[p].hh.b1 = strpool[j];
        mem[p].hh.b0 = 0;
    } else {

        inmutree = 1;
        p = mubyteread[strpool[j]];
    }
    incr(j);
    while (j < poolptr) {

        if (inmutree == 0) {
            mem[p].hh.v.RH = getavail();
            p = mem[p].hh.v.RH;
            mem[p].hh.v.LH = getavail();
            p = mem[p].hh.v.LH;
            mem[p].hh.b1 = strpool[j];
            mem[p].hh.b0 = 0;
        } else if ((mem[p].hh.b0 > 0) && (mem[p].hh.b0 < 64)) {
            mem[p].hh.b0 = mem[p].hh.b0 + 64;
            q = mem[p].hh.v.RH;
            mem[p].hh.v.RH = getavail();
            p = mem[p].hh.v.RH;
            mem[p].hh.v.LH = q;
            mem[p].hh.v.RH = getavail();
            p = mem[p].hh.v.RH;
            mem[p].hh.v.LH = getavail();
            p = mem[p].hh.v.LH;
            mem[p].hh.b1 = strpool[j];
            mem[p].hh.b0 = 0;
            inmutree = 0;
        } else {

            if (mem[p].hh.b0 >= 64)
                p = mem[p].hh.v.RH;
            do {
                p = mem[p].hh.v.RH;
                if (mem[mem[p].hh.v.LH].hh.b1 == strpool[j]) {
                    p = mem[p].hh.v.LH;
                    goto labmubyteupdate22continue;
                }
            } while (!(mem[p].hh.v.RH == TEXNULL));
            mem[p].hh.v.RH = getavail();
            p = mem[p].hh.v.RH;
            mem[p].hh.v.LH = getavail();
            p = mem[p].hh.v.LH;
            mem[p].hh.b1 = strpool[j];
            mem[p].hh.b0 = 0;
            inmutree = 0;
        }
    labmubyteupdate22continue:
        incr(j);
    }
    if (inmutree == 1) {
        if (mem[p].hh.b0 == 0) {
            mem[p].hh.b0 = mubyteprefix + 64;
            q = mem[p].hh.v.RH;
            mem[p].hh.v.RH = getavail();
            p = mem[p].hh.v.RH;
            mem[p].hh.v.RH = q;
            mem[p].hh.v.LH = mubytestoken;
            return;
        }
        if (mem[p].hh.b0 >= 64) {
            mem[p].hh.b0 = mubyteprefix + 64;
            p = mem[p].hh.v.RH;
            mem[p].hh.v.LH = mubytestoken;
            return;
        }
    }
    mem[p].hh.b0 = mubyteprefix;
    mem[p].hh.v.RH = mubytestoken;
}
void zdisposemunode(halfword p) {
    disposemunode_regmem halfword q;
    if ((mem[p].hh.b0 > 0) && (mem[p].hh.b0 < 64)) {
        mem[p].hh.v.RH = avail;
        avail = p;
        mem[p].hh.me = 0;
        ;
#ifdef STAT
        decr(dynused);
#endif /* STAT */
    } else {

        if (mem[p].hh.b0 >= 64) {
            q = mem[p].hh.v.RH;
            {
                mem[p].hh.v.RH = avail;
                avail = p;
                mem[p].hh.me = 0;
                ;
#ifdef STAT
                decr(dynused);
#endif /* STAT */
            }
            p = q;
        }
        q = mem[p].hh.v.RH;
        {
            mem[p].hh.v.RH = avail;
            avail = p;
            mem[p].hh.me = 0;
            ;
#ifdef STAT
            decr(dynused);
#endif /* STAT */
        }
        p = q;
        while (p != TEXNULL) {

            disposemunode(mem[p].hh.v.LH);
            q = mem[p].hh.v.RH;
            {
                mem[p].hh.v.RH = avail;
                avail = p;
                mem[p].hh.me = 0;
                ;
#ifdef STAT
                decr(dynused);
#endif /* STAT */
            }
            p = q;
        }
    }
}
void zdisposemutableout(halfword cs) {
    disposemutableout_regmem halfword p, q, r;
    p = mubytecswrite[cs % 128];
    r = TEXNULL;
    while (p != TEXNULL)
        if (mem[p].hh.v.LH == cs) {
            if (r != TEXNULL)
                mem[r].hh.v.RH = mem[mem[p].hh.v.RH].hh.v.RH;
            else
                mubytecswrite[cs % 128] = mem[mem[p].hh.v.RH].hh.v.RH;
            q = mem[mem[p].hh.v.RH].hh.v.RH;
            {
                mem[mem[p].hh.v.RH].hh.v.RH = avail;
                avail = mem[p].hh.v.RH;
                mem[mem[p].hh.v.RH].hh.me = 0;
                ;
#ifdef STAT
                decr(dynused);
#endif /* STAT */
            }
            {
                mem[p].hh.v.RH = avail;
                avail = p;
                mem[p].hh.me = 0;
                ;
#ifdef STAT
                decr(dynused);
#endif /* STAT */
            }
            p = q;
        } else {

            r = mem[p].hh.v.RH;
            p = mem[r].hh.v.RH;
        }
}
void checkoutervalidity(void) {
    checkoutervalidity_regmem halfword p;
    halfword q;
    if (scannerstatus != NORMAL) {
        deletionsallowed = false;
        /* comment:Back up an outer control sequence so that it can b */
        if (curcs != 0) {
            if ((curinput.statefield == TOKENLIST) ||
                (curinput.namefield < 1) || (curinput.namefield > 17)) {
                p = getavail();
                mem[p].hh.v.LH = 4095 + curcs;
                begintokenlist(p, BACKEDUP);
            }
            curcmd = SPACER;
            curchr = /* str ' ' */ 32;
        }
        if (scannerstatus > SKIPPING) /* comment:Tell the user what has
                                                run away and try to recover */
        {
            runaway();
            if (curcs == 0) {
                if (interaction == ERRORSTOPMODE)
                    ;
                if (filelineerrorstylep)
                    printfileline();
                else
                    printnl(/* str '! ' */ 264);
                print(/* str 'File ended' */ 688);
            } else {

                curcs = 0;
                {
                    if (interaction == ERRORSTOPMODE)
                        ;
                    if (filelineerrorstylep)
                        printfileline();
                    else
                        printnl(/* str '! ' */ 264);
                    print(/* str 'Forbidden control sequence found' */ 689);
                }
            }
            /* comment:Print either `\.{definition}' or `\.{use}' or `\.{ */ p =
                getavail();
            switch (scannerstatus) {
            case DEFINING: {
                print(/* str ' while scanning definition' */ 695);
                mem[p].hh.v.LH = /* @d4098@ */ /* str '}' */ 637;
            } break;
            case MATCHING: {
                print(/* str ' while scanning use' */ 696);
                mem[p].hh.v.LH = partoken;
                longstate = OUTERCALL;
            } break;
            case ALIGNING: {
                print(/* str ' while scanning preamble' */ 697);
                mem[p].hh.v.LH = /* @d4105@ */ /* str '}' */ 637;
                q = p;
                p = getavail();
                mem[p].hh.v.RH = q;
                mem[p].hh.v.LH = /* @d4107@ */ 19610;
                alignstate = -1000000L;
            } break;
            case ABSORBING: {
                print(/* str ' while scanning text' */ 698);
                mem[p].hh.v.LH = /* @d4110@ */ /* str '}' */ 637;
            } break;
            }
            begintokenlist(p, INSERTED);
            print(/* str ' of ' */ 690);
            sprintcs(warningindex);
            {
                helpptr = 4;
                helpline[3] =
                    /* str 'I suspect you have forgotten a `}', causing me' */
                    691;
                helpline[2] =
                    /* str 'to read past where you wanted me to stop.' */ 692;
                helpline[1] = /* str 'I'll try to recover; but if the error is
                                 serious,' */
                    693;
                helpline[0] = /* str 'you'd better type `E' or `X' now and fix
                                 your fil' */
                    694;
            }
            error();
        } else {

            {
                if (interaction == ERRORSTOPMODE)
                    ;
                if (filelineerrorstylep)
                    printfileline();
                else
                    printnl(/* str '! ' */ 264);
                print(/* str 'Incomplete ' */ 682);
            }
            printcmdchr(IFTEST, curif);
            print(/* str '; all text was ignored after line ' */ 683);
            printint(skipline);
            {
                helpptr = 3;
                helpline[2] = /* str 'A forbidden control sequence occurred in
                                 skipped ' */
                    684;
                helpline[1] = /* str 'This kind of error happens when you say
                                 `\if...' ' */
                    685;
                helpline[0] = /* str 'the matching `\fi'. I've inserted a `\fi';
                                 this m' */
                    686;
            }
            if (curcs != 0)
                curcs = 0;
            else
                helpline[2] = /* str 'The file ended while I was skipping
                                 conditional t' */
                    687;
            curtok = /* @d4127@ */ 19613;
            inserror();
        }
        deletionsallowed = true;
    }
}
void getnext(void) {
    /* @d4128@ */ /* @d4129@ */ /* @d4130@ */ /* @d4131@ */ /* @d4132@ */
    getnext_regmem integer k;
    halfword t;
    integer i, j;
    boolean mubyteincs;
    halfword p;
    unsigned char cat;
    ASCIIcode c, cc;
    unsigned char d;
labgetnext20restart:
    curcs = 0;
    curchrsig = 0;
    if (curinput.statefield != TOKENLIST) /* comment:Input from external file,
                                             |goto restart| if no inp */
    {
    labgetnext25switch:
        if (curinput.locfield <= curinput.limitfield) {
            k = curinput.locfield;
            curchr = readbuffer(k);
            curinput.locfield = k;
            incr(curinput.locfield);
            if ((mubytetoken > 0)) {
                curinput.statefield = MIDLINE;
                curcs = mubytetoken - 4095;
                goto labgetnext40found;
            }
        labgetnext21reswitch:
            curcmd = eqtb[CATCODEBASE + curchr].hh.v.RH;
            /* comment:Change state if necessary, and |goto switch| if th */
            switch (curinput.statefield + curcmd) {
            /* comment:Cases where character is ignored */
            case MIDLINE + IGNORE:
            case SKIPBLANKS + IGNORE:
            case NEWLINE + IGNORE:
            case SKIPBLANKS + SPACER:
            case NEWLINE + SPACER:
                goto labgetnext25switch;
                break;
            case MIDLINE + ESCAPE:
            case SKIPBLANKS + ESCAPE:
            case NEWLINE + ESCAPE:
                /* comment:Scan a control sequence and set |state */ {

                    if (curinput.locfield > curinput.limitfield)
                        curcs = NULLCS;
                    else {

                    labgetnext26start_cs:
                        mubyteincs = false;
                        k = curinput.locfield;
                        mubyteskeep = mubytekeep;
                        curchr = readbuffer(k);
                        cat = eqtb[CATCODEBASE + curchr].hh.v.RH;
                        if ((eqtb[INTBASE + MUBYTEINCODE].cint > 0) &&
                            (!mubyteincs) &&
                            ((mubyteskip > 0) || (curchr != buffer[k])))
                            mubyteincs = true;
                        incr(k);
                        if (mubytetoken > 0) {
                            curinput.statefield = MIDLINE;
                            curcs = mubytetoken - 4095;
                            goto labgetnext40found;
                        }
                        if (cat == LETTER)
                            curinput.statefield = SKIPBLANKS;
                        else if (cat == SPACER)
                            curinput.statefield = SKIPBLANKS;
                        else
                            curinput.statefield = MIDLINE;
                        if ((cat == LETTER) &&
                            (k <=
                             curinput.limitfield)) /* comment:Scan ahead in the
                                                      buffer until finding a
                                                      nonletter */
                        {
                            do {
                                curchr = readbuffer(k);
                                cat = eqtb[CATCODEBASE + curchr].hh.v.RH;
                                if (mubytetoken > 0)
                                    cat = ESCAPE;
                                if ((eqtb[INTBASE + MUBYTEINCODE].cint > 0) &&
                                    (!mubyteincs) && (cat == LETTER) &&
                                    ((mubyteskip > 0) || (curchr != buffer[k])))
                                    mubyteincs = true;
                                incr(k);
                            } while (!((cat != LETTER) ||
                                       (k > curinput.limitfield)));
                            /* comment:If an expanded code is present, reduce it
                             * and |got */
                            {

                                if (buffer[k] == curchr) {

                                    if (cat == SUPMARK) {

                                        if (k < curinput.limitfield) {
                                            c = buffer[k + 1];
                                            if (c < 128) {
                                                d = 2;
                                                if ((((c >= /* str '0' */ 48) &&
                                                      (c <=
                                                       /* str '9' */ 57)) ||
                                                     ((c >= /* str 'a' */ 97) &&
                                                      (c <=
                                                       /* str 'f' */ 102)))) {

                                                    if (k + 2 <=
                                                        curinput.limitfield) {
                                                        cc = buffer[k + 2];
                                                        if ((((cc >=
                                                               /* str '0' */
                                                               48) &&
                                                              (cc <=
                                                               /* str '9' */
                                                               57)) ||
                                                             ((cc >=
                                                               /* str 'a' */
                                                               97) &&
                                                              (cc <=
                                                               /* str 'f' */
                                                               102))))
                                                            incr(d);
                                                    }
                                                }
                                                if (d > 2) {
                                                    if (c <= /* str '9' */ 57)
                                                        curchr =
                                                            /* str '0' */ c -
                                                            48;
                                                    else
                                                        curchr =
                                                            /* str 'a' */ c -
                                                            87;
                                                    if (cc <= /* str '9' */ 57)
                                                        curchr =
                                                            16 * curchr +
                                                            /* str '0' */ cc -
                                                            48;
                                                    else
                                                        curchr =
                                                            16 * curchr +
                                                            /* str 'a' */ cc -
                                                            87;
                                                    buffer[k - 1] = curchr;
                                                } else if (c < 64)
                                                    buffer[k - 1] = c + 64;
                                                else
                                                    buffer[k - 1] = c - 64;
                                                curinput.limitfield =
                                                    curinput.limitfield - d;
                                                first = first - d;
                                                if (eqtb[/* @d4199@ */
                                                         /* @d4200@ */ 29335]
                                                        .cint > 0)
                                                    mubytekeep =
                                                        k - curinput.locfield;
                                                while (k <=
                                                       curinput.limitfield) {

                                                    buffer[k] = buffer[k + d];
                                                    incr(k);
                                                }
                                                goto labgetnext26start_cs;
                                            }
                                        }
                                    }
                                }
                            }
                            if (cat != LETTER) {
                                decr(k);
                                k = k - mubyteskip;
                            }
                            if (k > curinput.locfield + 1) {
                                if (mubyteincs) {
                                    i = curinput.locfield;
                                    j = first;
                                    mubytekeep = mubyteskeep;
                                    if (j - curinput.locfield + k >
                                        maxbufstack) {
                                        maxbufstack = j - curinput.locfield + k;
                                        if (maxbufstack >= bufsize) {
                                            maxbufstack = bufsize;
                                            overflow(
                                                /* str 'buffer size' */ 258,
                                                bufsize);
                                        }
                                    }
                                    while (i < k) {

                                        buffer[j] = readbuffer(i);
                                        incr(i);
                                        incr(j);
                                    }
                                    if (j == first + 1)
                                        curcs = SINGLEBASE + buffer[first];
                                    else
                                        curcs = idlookup(first, j - first);
                                } else
                                    curcs = idlookup(curinput.locfield,
                                                     k - curinput.locfield);
                                curinput.locfield = k;
                                goto labgetnext40found;
                            }
                        } else /* comment:If an expanded code is present, reduce
                                  it and |got */
                        {

                            if (buffer[k] == curchr) {

                                if (cat == SUPMARK) {

                                    if (k < curinput.limitfield) {
                                        c = buffer[k + 1];
                                        if (c < 128) {
                                            d = 2;
                                            if ((((c >= /* str '0' */ 48) &&
                                                  (c <= /* str '9' */ 57)) ||
                                                 ((c >= /* str 'a' */ 97) &&
                                                  (c <= /* str 'f' */ 102)))) {

                                                if (k + 2 <=
                                                    curinput.limitfield) {
                                                    cc = buffer[k + 2];
                                                    if ((((cc >=
                                                           /* str '0' */ 48) &&
                                                          (cc <=
                                                           /* str '9' */ 57)) ||
                                                         ((cc >= /* str 'a' */
                                                           97) &&
                                                          (cc <=
                                                           /* str 'f' */ 102))))
                                                        incr(d);
                                                }
                                            }
                                            if (d > 2) {
                                                if (c <= /* str '9' */ 57)
                                                    curchr =
                                                        /* str '0' */ c - 48;
                                                else
                                                    curchr =
                                                        /* str 'a' */ c - 87;
                                                if (cc <= /* str '9' */ 57)
                                                    curchr = 16 * curchr +
                                                             /* str '0' */ cc -
                                                             48;
                                                else
                                                    curchr = 16 * curchr +
                                                             /* str 'a' */ cc -
                                                             87;
                                                buffer[k - 1] = curchr;
                                            } else if (c < 64)
                                                buffer[k - 1] = c + 64;
                                            else
                                                buffer[k - 1] = c - 64;
                                            curinput.limitfield =
                                                curinput.limitfield - d;
                                            first = first - d;
                                            if (eqtb[/* @d4222@ */ /* @d4223@ */
                                                     29335]
                                                    .cint > 0)
                                                mubytekeep =
                                                    k - curinput.locfield;
                                            while (k <= curinput.limitfield) {

                                                buffer[k] = buffer[k + d];
                                                incr(k);
                                            }
                                            goto labgetnext26start_cs;
                                        }
                                    }
                                }
                            }
                        }
                        mubytekeep = mubyteskeep;
                        curcs = SINGLEBASE + readbuffer(curinput.locfield);
                        incr(curinput.locfield);
                    }
                labgetnext40found:
                    curcmd = eqtb[curcs].hh.b0;
                    curchr = eqtb[curcs].hh.v.RH;
                    if (curcmd >= OUTERCALL)
                        checkoutervalidity();
                    if (writenoexpanding) {
                        p = mubytecswrite[curcs % 128];
                        while (p != TEXNULL)
                            if (mem[p].hh.v.LH == curcs) {
                                curcmd = RELAX;
                                curchr = 256;
                                p = TEXNULL;
                            } else
                                p = mem[mem[p].hh.v.RH].hh.v.RH;
                    }
                }
                break;
            case MIDLINE + ACTIVECHAR:
            case SKIPBLANKS + ACTIVECHAR:
            case NEWLINE + ACTIVECHAR:
                /* comment:Process an active-character control sequence and s */
                {

                    curcs = curchr + ACTIVEBASE;
                    curcmd = eqtb[curcs].hh.b0;
                    curchr = eqtb[curcs].hh.v.RH;
                    curinput.statefield = MIDLINE;
                    if (curcmd >= OUTERCALL)
                        checkoutervalidity();
                }
                break;
            case MIDLINE + SUPMARK:
            case SKIPBLANKS + SUPMARK:
            case NEWLINE + SUPMARK:
                /* comment:If this |sup_mark| starts an expanded character li */
                {

                    if (curchr == buffer[curinput.locfield]) {

                        if (curinput.locfield < curinput.limitfield) {
                            c = buffer[curinput.locfield + 1];
                            if (c < 128) {
                                curinput.locfield = curinput.locfield + 2;
                                if ((((c >= /* str '0' */ 48) &&
                                      (c <= /* str '9' */ 57)) ||
                                     ((c >= /* str 'a' */ 97) &&
                                      (c <= /* str 'f' */ 102)))) {

                                    if (curinput.locfield <=
                                        curinput.limitfield) {
                                        cc = buffer[curinput.locfield];
                                        if ((((cc >= /* str '0' */ 48) &&
                                              (cc <= /* str '9' */ 57)) ||
                                             ((cc >= /* str 'a' */ 97) &&
                                              (cc <= /* str 'f' */ 102)))) {
                                            incr(curinput.locfield);
                                            if (c <= /* str '9' */ 57)
                                                curchr = /* str '0' */ c - 48;
                                            else
                                                curchr = /* str 'a' */ c - 87;
                                            if (cc <= /* str '9' */ 57)
                                                curchr = 16 * curchr +
                                                         /* str '0' */ cc - 48;
                                            else
                                                curchr = 16 * curchr +
                                                         /* str 'a' */ cc - 87;
                                            goto labgetnext21reswitch;
                                        }
                                    }
                                }
                                if (c < 64)
                                    curchr = c + 64;
                                else
                                    curchr = c - 64;
                                goto labgetnext21reswitch;
                            }
                        }
                    }
                    curinput.statefield = MIDLINE;
                }
                break;
            case MIDLINE + INVALIDCHAR:
            case SKIPBLANKS + INVALIDCHAR:
            case NEWLINE + INVALIDCHAR:
                /* comment:Decry the invalid character and |goto restart| */ {

                    {
                        if (interaction == ERRORSTOPMODE)
                            ;
                        if (filelineerrorstylep)
                            printfileline();
                        else
                            printnl(/* str '! ' */ 264);
                        print(
                            /* str 'Text line contains an invalid character' */
                            699);
                    }
                    {
                        helpptr = 2;
                        helpline[1] = /* str 'A funny symbol that I can't read
                                         has just been in' */
                            700;
                        helpline[0] = /* str 'Continue, and I'll forget that it
                                         ever happened.' */
                            701;
                    }
                    deletionsallowed = false;
                    error();
                    deletionsallowed = true;
                    goto labgetnext20restart;
                }
                break;
            /* comment:Handle situations involving spaces, braces, change */
            case MIDLINE + SPACER:
                /* comment:Enter |skip_blanks| state, emit a space */ {

                    curinput.statefield = SKIPBLANKS;
                    curchr = /* str ' ' */ 32;
                }
                break;
            case MIDLINE + CARRET:
                /* comment:Finish line, emit a space */ {

                    curinput.locfield = curinput.limitfield + 1;
                    curcmd = SPACER;
                    curchr = /* str ' ' */ 32;
                }
                break;
            case SKIPBLANKS + CARRET:
            case MIDLINE + COMMENT:
            case SKIPBLANKS + COMMENT:
            case NEWLINE + COMMENT:
                /* comment:Finish line, |goto switch| */ {

                    curinput.locfield = curinput.limitfield + 1;
                    goto labgetnext25switch;
                }
                break;
            case NEWLINE + CARRET:
                /* comment:Finish line, emit a \.{\\par} */ {

                    curinput.locfield = curinput.limitfield + 1;
                    curcs = parloc;
                    curcmd = eqtb[curcs].hh.b0;
                    curchr = eqtb[curcs].hh.v.RH;
                    if (curcmd >= OUTERCALL)
                        checkoutervalidity();
                }
                break;
            case MIDLINE + LEFTBRACE:
                incr(alignstate);
                break;
            case SKIPBLANKS + LEFTBRACE:
            case NEWLINE + LEFTBRACE: {
                curinput.statefield = MIDLINE;
                incr(alignstate);
            } break;
            case MIDLINE + RIGHTBRACE:
                decr(alignstate);
                break;
            case SKIPBLANKS + RIGHTBRACE:
            case NEWLINE + RIGHTBRACE: {
                curinput.statefield = MIDLINE;
                decr(alignstate);
            } break;
            case SKIPBLANKS + MATHSHIFT:
            case SKIPBLANKS + TABMARK:
            case SKIPBLANKS + MACPARAM:
            case SKIPBLANKS + SUBMARK:
            case SKIPBLANKS + LETTER:
            case SKIPBLANKS + OTHERCHAR:
            case NEWLINE + MATHSHIFT:
            case NEWLINE + TABMARK:
            case NEWLINE + MACPARAM:
            case NEWLINE + SUBMARK:
            case NEWLINE + LETTER:
            case NEWLINE + OTHERCHAR:
                curinput.statefield = MIDLINE;
                break;
            default:;
                break;
            }
            if (curinput.indexfield == 1)
                curchrsig =
                    getcharsigslot(curinput.indexfield, line,
                                   curinput.locfield - curinput.startfield,
                                   alignstate - 1000000L, curcs);
        } else {

            curinput.statefield = NEWLINE;
            /* comment:Move to next line of file, or |goto restart| if th */
            if (curinput.namefield > 17) /* comment:Read next line of file into
                                            |buffer|, or |goto res */
            {
                incr(line);
                first = curinput.startfield;
                if (!forceeof) {

                    if (curinput.namefield <= 19) {
                        if (pseudoinput())
                            firmuptheline();
                        else if ((eqtb[EVERYEOFLOC].hh.v.RH != TEXNULL) &&
                                 !eofseen[curinput.indexfield]) {
                            curinput.limitfield = first - 1;
                            eofseen[curinput.indexfield] = true;
                            begintokenlist(eqtb[EVERYEOFLOC].hh.v.RH,
                                           EVERYEOFTEXT);
                            goto labgetnext20restart;
                        } else
                            forceeof = true;
                    } else {

                        if (inputln(inputfile[curinput.indexfield], true))
                            firmuptheline();
                        else if ((eqtb[EVERYEOFLOC].hh.v.RH != TEXNULL) &&
                                 !eofseen[curinput.indexfield]) {
                            curinput.limitfield = first - 1;
                            eofseen[curinput.indexfield] = true;
                            begintokenlist(eqtb[EVERYEOFLOC].hh.v.RH,
                                           EVERYEOFTEXT);
                            goto labgetnext20restart;
                        } else
                            forceeof = true;
                    }
                }
                if (forceeof) {
                    if (eqtb[INTBASE + TRACINGNESTINGCODE].cint > 0) {

                        if ((grpstack[inopen] != curboundary) ||
                            (ifstack[inopen] != condptr))
                            filewarning();
                    }
                    if (curinput.namefield >= 19) {
                        printchar(/* str ')' */ 41);
                        decr(openparens);
                        fflush(stdout);
                    }
                    forceeof = false;
                    endfilereading();
                    checkoutervalidity();
                    goto labgetnext20restart;
                }
                if ((eqtb[INTBASE + ENDLINECHARCODE].cint < 0) ||
                    (eqtb[INTBASE + ENDLINECHARCODE].cint > 255))
                    decr(curinput.limitfield);
                else
                    buffer[curinput.limitfield] =
                        eqtb[INTBASE + ENDLINECHARCODE].cint;
                first = curinput.limitfield + 1;
                curinput.locfield = curinput.startfield;
            } else {

                if (!(curinput.namefield == 0)) {
                    curcmd = 0;
                    curchr = 0;
                    return;
                }
                if (inputptr > 0) {
                    endfilereading();
                    goto labgetnext20restart;
                }
                if (selector < LOGONLY)
                    openlogfile();
                if (interaction > NONSTOPMODE) {
                    if ((eqtb[INTBASE + ENDLINECHARCODE].cint < 0) ||
                        (eqtb[INTBASE + ENDLINECHARCODE].cint > 255))
                        incr(curinput.limitfield);
                    if (curinput.limitfield == curinput.startfield)
                        printnl(
                            /* str '(Please type a command or say `\end')' */
                            702);
                    println();
                    first = curinput.startfield;
                    {
                        ;
                        print(/* str '' */ 42);
                        terminput();
                    }
                    curinput.limitfield = last;
                    if ((eqtb[INTBASE + ENDLINECHARCODE].cint < 0) ||
                        (eqtb[INTBASE + ENDLINECHARCODE].cint > 255))
                        decr(curinput.limitfield);
                    else
                        buffer[curinput.limitfield] =
                            eqtb[INTBASE + ENDLINECHARCODE].cint;
                    first = curinput.limitfield + 1;
                    curinput.locfield = curinput.startfield;
                } else
                    fatalerror(
                        /* str ' (job aborted, no legal \end found)' */ 703);
            }
            {
                if (interrupt != 0)
                    pauseforinstructions();
            }
            goto labgetnext25switch;
        }
    } else /* comment:Input from token list, |goto restart| if end of li */
        if (curinput.locfield != TEXNULL) {
        t = mem[curinput.locfield].hh.v.LH;
        curchrsig = mem[curinput.locfield].hh.me;
        curinput.locfield = mem[curinput.locfield].hh.v.RH;
        if (t >= 4095) {
            curcs = t - 4095;
            curcmd = eqtb[curcs].hh.b0;
            curchr = eqtb[curcs].hh.v.RH;
            if (curcmd >= OUTERCALL) {

                if (curcmd == DONTEXPAND) /* comment:Get the next token,
                                                    suppressing expansion */
                {
                    curcs = mem[curinput.locfield].hh.v.LH - 4095;
                    curinput.locfield = TEXNULL;
                    curcmd = eqtb[curcs].hh.b0;
                    curchr = eqtb[curcs].hh.v.RH;
                    if (curcmd > MAXCOMMAND) {
                        curcmd = RELAX;
                        curchr = NOEXPANDFLAG;
                    }
                } else
                    checkoutervalidity();
            }
            if (writenoexpanding) {
                p = mubytecswrite[curcs % 128];
                while (p != TEXNULL)
                    if (mem[p].hh.v.LH == curcs) {
                        curcmd = RELAX;
                        curchr = 256;
                        p = TEXNULL;
                    } else
                        p = mem[mem[p].hh.v.RH].hh.v.RH;
            }
        } else {

            curcmd = t / 256;
            curchr = t % 256;
            switch (curcmd) {
            case LEFTBRACE:
                incr(alignstate);
                break;
            case RIGHTBRACE:
                decr(alignstate);
                break;
            case OUTPARAM:
                /* comment:Insert macro parameter and |goto restart| */ {

                    begintokenlist(paramstack[curinput.limitfield + curchr -
                                              1], /* @d4391@ */
                                   0);
                    goto labgetnext20restart;
                }
                break;
            default:;
                break;
            }
        }
    } else {

        endtokenlist();
        goto labgetnext20restart;
    }
    /* comment:If an alignment entry has just ended, take appropr */
    if (curcmd <= CARRET) {

        if (curcmd >= TABMARK) {

            if (alignstate == 0) /* comment:Insert the \(v)\<v_j> template and
                                    |goto restart| */
            {
                if ((scannerstatus == ALIGNING) || (curalign == TEXNULL))
                    fatalerror(/* str '(interwoven alignment preambles are not
                                  allowed)' */
                               679);
                curcmd = mem[curalign + LISTOFFSET].hh.v.LH;
                mem[curalign + LISTOFFSET].hh.v.LH = curchr;
                if (curcmd == OMIT)
                    begintokenlist(memtop - 10, VTEMPLATE);
                else
                    begintokenlist(mem[curalign + DEPTHOFFSET].cint, VTEMPLATE);
                alignstate = 1000000L;
                goto labgetnext20restart;
            }
        }
    }
}
void firmuptheline(void) {
    firmuptheline_regmem integer k;
    curinput.limitfield = last;
    if (eqtb[INTBASE + PAUSINGCODE].cint > 0) {

        if (interaction > NONSTOPMODE) {
            ;
            println();
            k = curinput.startfield;
            while (k < curinput.limitfield) {

                printbuffer(k);
            }
            first = curinput.limitfield;
            {
                ;
                print(/* str '=>' */ 704);
                terminput();
            }
            if (last > first) {
                {
                    register integer for_end;
                    k = first;
                    for_end = last - 1;
                    if (k <= for_end)
                        do
                            buffer[k + curinput.startfield - first] = buffer[k];
                        while (k++ < for_end);
                }
                curinput.limitfield = curinput.startfield + last - first;
            }
        }
    }
}
void gettoken(void) {
    gettoken_regmem nonewcontrolsequence = false;
    getnext();
    nonewcontrolsequence = true;
    if (curcs == 0)
        curtok = (curcmd * 256) + curchr;
    else
        curtok = 4095 + curcs;
}
/* comment:Declare the procedure called |macro_call| */ void macrocall(void) {
    /* @d4413@ */ /* @d4414@ */ /* @d4415@ */ /* @d4416@ */ /* @d4417@ */
    macrocall_regmem halfword r;
    halfword p;
    halfword q;
    halfword s;
    halfword t;
    halfword u, v;
    halfword rbraceptr;
    smallnumber n;
    halfword unbalance;
    halfword m;
    halfword refcount;
    smallnumber savescannerstatus;
    halfword savewarningindex;
    ASCIIcode matchchr;
    savescannerstatus = scannerstatus;
    savewarningindex = warningindex;
    warningindex = curcs;
    refcount = curchr;
    r = mem[refcount].hh.v.RH;
    n = 0;
    fillcsinfo(mem[r].hh.v.RH);
    if (eqtb[INTBASE + TRACINGMACROSCODE].cint >
        0) /* comment:Show the text of the macro being expanded */
    {
        begindiagnostic();
        println();
        printcs(warningindex);
        tokenshow(refcount);
        enddiagnostic(false);
    }
    if (mem[r].hh.v.LH == PROTECTEDTOKEN)
        r = mem[r].hh.v.RH;
    if (mem[r].hh.v.LH != ENDMATCHTOKEN) /* comment:Scan the parameters and
                                                 make |link(r)| point to th */
    {
        scannerstatus = MATCHING;
        unbalance = 0;
        longstate = eqtb[curcs].hh.b0;
        if (longstate >= OUTERCALL)
            longstate = longstate - 2;
        do {
            mem[memtop - 3].hh.v.RH = TEXNULL;
            if ((mem[r].hh.v.LH > /* @d4426@ */ 3583) ||
                (mem[r].hh.v.LH < MATCHTOKEN))
                s = TEXNULL;
            else {

                matchchr = mem[r].hh.v.LH /* @d4428@ */ - 3328;
                s = mem[r].hh.v.RH;
                r = s;
                p = memtop - 3;
                m = 0;
            }
        /* comment:Scan a parameter until its delimiter string has be */
        labmacrocall22continue:
            gettoken();
            if (curtok == mem[r].hh.v.LH) /* comment:Advance \(r)|r|; |goto
                                             found| if the parameter del */
            {
                r = mem[r].hh.v.RH;
                if ((mem[r].hh.v.LH >= MATCHTOKEN) &&
                    (mem[r].hh.v.LH <= ENDMATCHTOKEN)) {
                    if (curtok < LEFTBRACELIMIT)
                        decr(alignstate);
                    goto labmacrocall40found;
                } else
                    goto labmacrocall22continue;
            }
            /* comment:Contribute the recently matched tokens to the curr */
            if (s != r) {

                if (s == TEXNULL) /* comment:Report an improper use of the
                                          macro and abort */
                {
                    {
                        if (interaction == ERRORSTOPMODE)
                            ;
                        if (filelineerrorstylep)
                            printfileline();
                        else
                            printnl(/* str '! ' */ 264);
                        print(/* str 'Use of ' */ 737);
                    }
                    sprintcs(warningindex);
                    print(/* str ' doesn't match its definition' */ 738);
                    {
                        helpptr = 4;
                        helpline[3] = /* str 'If you say, e.g., `\def\a1{...}',
                                         then you must a' */
                            739;
                        helpline[2] = /* str 'put `1' after `\a', since control
                                         sequence names ' */
                            740;
                        helpline[1] = /* str 'made up of letters only. The macro
                                         here has not b' */
                            741;
                        helpline[0] = /* str 'followed by the required stuff, so
                                         I'm ignoring i' */
                            742;
                    }
                    error();
                    goto labmacrocall10exit;
                } else {

                    t = s;
                    do {
                        {
                            q = getavail();
                            mem[p].hh.v.RH = q;
                            mem[q].hh.v.LH = mem[t].hh.v.LH;
                            p = q;
                        }
                        mem[p].hh.me = mem[t].hh.me;
                        incr(m);
                        u = mem[t].hh.v.RH;
                        v = s;
                        while (true) {

                            if (u == r) {

                                if (curtok != mem[v].hh.v.LH)
                                    goto labmacrocall30done;
                                else {

                                    r = mem[v].hh.v.RH;
                                    goto labmacrocall22continue;
                                }
                            }
                            if (mem[u].hh.v.LH != mem[v].hh.v.LH)
                                goto labmacrocall30done;
                            u = mem[u].hh.v.RH;
                            v = mem[v].hh.v.RH;
                        }
                    labmacrocall30done:
                        t = mem[t].hh.v.RH;
                    } while (!(t == r));
                    r = s;
                }
            }
            if (curtok == partoken) {

                if (longstate != LONGCALL) /* comment:Report a runaway
                                                       argument and abort */
                {
                    if (longstate == CALL) {
                        runaway();
                        {
                            if (interaction == ERRORSTOPMODE)
                                ;
                            if (filelineerrorstylep)
                                printfileline();
                            else
                                printnl(/* str '! ' */ 264);
                            print(/* str 'Paragraph ended before ' */ 732);
                        }
                        sprintcs(warningindex);
                        print(/* str ' was complete' */ 733);
                        {
                            helpptr = 3;
                            helpline[2] = /* str 'I suspect you've forgotten a
                                             `}', causing me to a' */
                                734;
                            helpline[1] = /* str 'control sequence to too much
                                             text. How can we rec' */
                                735;
                            helpline[0] = /* str 'My plan is to forget the whole
                                             thing and hope for' */
                                736;
                        }
                        backerror();
                    }
                    pstack[n] = mem[memtop - 3].hh.v.RH;
                    alignstate = alignstate - unbalance;
                    {
                        register integer for_end;
                        m = 0;
                        for_end = n;
                        if (m <= for_end)
                            do
                                flushlist(pstack[m]);
                            while (m++ < for_end);
                    }
                    goto labmacrocall10exit;
                }
            }
            if (curtok < RIGHTBRACELIMIT) {

                if (curtok < LEFTBRACELIMIT) /* comment:Contribute an entire
                                                group to the current paramete */
                {
                    unbalance = 1;
                    while (true) {

                        {
                            {
                                q = avail;
                                if (q == TEXNULL)
                                    q = getavail();
                                else {

                                    avail = mem[q].hh.v.RH;
                                    mem[q].hh.v.RH = TEXNULL;
                                    mem[q].hh.me = curchrsig;
                                    ;
#ifdef STAT
                                    incr(dynused);
#endif /* STAT */
                                }
                            }
                            mem[p].hh.v.RH = q;
                            mem[q].hh.v.LH = curtok;
                            p = q;
                        }
                        gettoken();
                        if (curtok == partoken) {

                            if (longstate !=
                                LONGCALL) /* comment:Report a runaway
                                                      argument and abort */
                            {
                                if (longstate == CALL) {
                                    runaway();
                                    {
                                        if (interaction == ERRORSTOPMODE)
                                            ;
                                        if (filelineerrorstylep)
                                            printfileline();
                                        else
                                            printnl(/* str '! ' */ 264);
                                        print(
                                            /* str 'Paragraph ended before ' */
                                            732);
                                    }
                                    sprintcs(warningindex);
                                    print(/* str ' was complete' */ 733);
                                    {
                                        helpptr = 3;
                                        helpline[2] =
                                            /* str 'I suspect you've forgotten a
                                               `}', causing me to a' */
                                            734;
                                        helpline[1] =
                                            /* str 'control sequence to too much
                                               text. How can we rec' */
                                            735;
                                        helpline[0] =
                                            /* str 'My plan is to forget the
                                               whole thing and hope for' */
                                            736;
                                    }
                                    backerror();
                                }
                                pstack[n] = mem[memtop - 3].hh.v.RH;
                                alignstate = alignstate - unbalance;
                                {
                                    register integer for_end;
                                    m = 0;
                                    for_end = n;
                                    if (m <= for_end)
                                        do
                                            flushlist(pstack[m]);
                                        while (m++ < for_end);
                                }
                                goto labmacrocall10exit;
                            }
                        }
                        if (curtok < RIGHTBRACELIMIT) {

                            if (curtok < LEFTBRACELIMIT)
                                incr(unbalance);
                            else {

                                decr(unbalance);
                                if (unbalance == 0)
                                    goto labmacrocall31done1;
                            }
                        }
                    }
                labmacrocall31done1:
                    rbraceptr = p;
                    {
                        q = getavail();
                        mem[p].hh.v.RH = q;
                        mem[q].hh.v.LH = curtok;
                        p = q;
                    }
                } else /* comment:Report an extra right brace and |goto
                          continue| */
                {

                    backinput();
                    {
                        if (interaction == ERRORSTOPMODE)
                            ;
                        if (filelineerrorstylep)
                            printfileline();
                        else
                            printnl(/* str '! ' */ 264);
                        print(/* str 'Argument of ' */ 724);
                    }
                    sprintcs(warningindex);
                    print(/* str ' has an extra }' */ 725);
                    {
                        helpptr = 6;
                        helpline[5] = /* str 'I've run across a `}' that doesn't
                                         seem to match ' */
                            726;
                        helpline[4] = /* str 'For example, `\def\a#1{...}' and
                                         `\a}' would prod' */
                            727;
                        helpline[3] = /* str 'this error. If you simply proceed
                                         now, the `\par'' */
                            728;
                        helpline[2] = /* str 'I've just inserted will cause me
                                         to report a runa' */
                            729;
                        helpline[1] = /* str 'argument that might be the root of
                                         the problem. B' */
                            730;
                        helpline[0] = /* str 'your `}' was spurious, just type
                                         `2' and it will ' */
                            731;
                    }
                    incr(alignstate);
                    longstate = CALL;
                    curtok = partoken;
                    inserror();
                    goto labmacrocall22continue;
                }
            } else /* comment:Store the current token, but |goto continue| if it
                    */
            {

                if (curtok == SPACETOKEN) {

                    if (mem[r].hh.v.LH <= ENDMATCHTOKEN) {

                        if (mem[r].hh.v.LH >= MATCHTOKEN)
                            goto labmacrocall22continue;
                    }
                }
                {
                    q = getavail();
                    mem[p].hh.v.RH = q;
                    mem[q].hh.v.LH = curtok;
                    p = q;
                }
            }
            incr(m);
            if (mem[r].hh.v.LH > ENDMATCHTOKEN)
                goto labmacrocall22continue;
            if (mem[r].hh.v.LH < MATCHTOKEN)
                goto labmacrocall22continue;
        labmacrocall40found:
            if (s != TEXNULL) /* comment:Tidy up the parameter just
                                      scanned, and tuck it aw */
            {
                if ((m == 1) && (mem[p].hh.v.LH < RIGHTBRACELIMIT) &&
                    (p != memtop - 3)) {
                    mem[rbraceptr].hh.v.RH = TEXNULL;
                    {
                        mem[p].hh.v.RH = avail;
                        avail = p;
                        mem[p].hh.me = 0;
                        ;
#ifdef STAT
                        decr(dynused);
#endif /* STAT */
                    }
                    p = mem[memtop - 3].hh.v.RH;
                    pstack[n] = mem[p].hh.v.RH;
                    {
                        mem[p].hh.v.RH = avail;
                        avail = p;
                        mem[p].hh.me = 0;
                        ;
#ifdef STAT
                        decr(dynused);
#endif /* STAT */
                    }
                } else
                    pstack[n] = mem[memtop - 3].hh.v.RH;
                incr(n);
                if (eqtb[INTBASE + TRACINGMACROSCODE].cint > 0) {
                    begindiagnostic();
                    printnl(matchchr);
                    printint(n);
                    print(/* str '<-' */ 743);
                    showtokenlist(pstack[n - 1], TEXNULL, 1000);
                    enddiagnostic(false);
                }
            }
        } while (!(mem[r].hh.v.LH == ENDMATCHTOKEN));
    }
    /* comment:Feed the macro body and its parameters to the scan */ while (
        (curinput.statefield == TOKENLIST) && (curinput.locfield == TEXNULL) &&
        (curinput.indexfield != VTEMPLATE))
        endtokenlist();
    begintokenlist(refcount, MACRO);
    curinput.namefield = warningindex;
    curinput.locfield = mem[r].hh.v.RH;
    if (n > 0) {
        if (paramptr + n > maxparamstack) {
            maxparamstack = paramptr + n;
            if (maxparamstack > paramsize)
                overflow(/* str 'parameter stack size' */ 723, paramsize);
        }
        {
            register integer for_end;
            m = 0;
            for_end = n - 1;
            if (m <= for_end)
                do
                    paramstack[paramptr + m] = pstack[m];
                while (m++ < for_end);
        }
        paramptr = paramptr + n;
    }
labmacrocall10exit:
    scannerstatus = savescannerstatus;
    warningindex = savewarningindex;
}
/* comment:Declare the procedure called |insert_relax| */ void
insertrelax(void) {
    insertrelax_regmem curtok = 4095 + curcs;
    backinput();
    curtok = /* @d4517@ */ 19616;
    backinput();
    curinput.indexfield = INSERTED;
}
/* comment:Declare \eTeX\ procedures for expanding */ void
znewindex(quarterword i, halfword q) {
    newindex_regmem smallnumber k;
    curptr = getnode(INDEXNODESIZE);
    mem[curptr].hh.b0 = i;
    mem[curptr].hh.b1 = 0;
    mem[curptr].hh.v.RH = q;
    {
        register integer for_end;
        k = 1;
        for_end = /* @d4521@ */ 8;
        if (k <= for_end)
            do
                mem[curptr + k] = sanull;
            while (k++ < for_end);
    }
}
void zfindsaelement(smallnumber t, halfword n, boolean w) {
    /* @d4522@ */ /* @d4523@ */ /* @d4524@ */ /* @d4525@ */ /* @d4526@ */
    findsaelement_regmem halfword q;
    smallnumber i;
    curptr = saroot[t];
    {
        if (curptr == TEXNULL) {

            if (w)
                goto labfindsaelement45not_found;
            else /* @d4529@ */
                return;
        }
    }
    q = curptr;
    i = n / 4096;
    if (odd(i))
        curptr = mem[q + (i / 2) + 1].hh.v.RH;
    else
        curptr = mem[q + (i / 2) + 1].hh.v.LH;
    {
        if (curptr == TEXNULL) {

            if (w)
                goto labfindsaelement46not_found1;
            else /* @d4531@ */
                return;
        }
    }
    q = curptr;
    i = (n / 256) % 16;
    if (odd(i))
        curptr = mem[q + (i / 2) + 1].hh.v.RH;
    else
        curptr = mem[q + (i / 2) + 1].hh.v.LH;
    {
        if (curptr == TEXNULL) {

            if (w)
                goto labfindsaelement47not_found2;
            else /* @d4533@ */
                return;
        }
    }
    q = curptr;
    i = (n / 16) % 16;
    if (odd(i))
        curptr = mem[q + (i / 2) + 1].hh.v.RH;
    else
        curptr = mem[q + (i / 2) + 1].hh.v.LH;
    {
        if (curptr == TEXNULL) {

            if (w)
                goto labfindsaelement48not_found3;
            else /* @d4535@ */
                return;
        }
    }
    q = curptr;
    i = n % 16;
    if (odd(i))
        curptr = mem[q + (i / 2) + 1].hh.v.RH;
    else
        curptr = mem[q + (i / 2) + 1].hh.v.LH;
    if ((curptr == TEXNULL) && w)
        goto labfindsaelement49not_found4;
    return;
labfindsaelement45not_found:
    newindex(t, TEXNULL);
    saroot[t] = curptr;
    q = curptr;
    i = n / 4096;
labfindsaelement46not_found1:
    newindex(i, q);
    {
        if (odd(i))
            mem[q + (i / 2) + 1].hh.v.RH = curptr;
        else
            mem[q + (i / 2) + 1].hh.v.LH = curptr;
        incr(mem[q].hh.b1);
    }
    q = curptr;
    i = (n / 256) % 16;
labfindsaelement47not_found2:
    newindex(i, q);
    {
        if (odd(i))
            mem[q + (i / 2) + 1].hh.v.RH = curptr;
        else
            mem[q + (i / 2) + 1].hh.v.LH = curptr;
        incr(mem[q].hh.b1);
    }
    q = curptr;
    i = (n / 16) % 16;
labfindsaelement48not_found3:
    newindex(i, q);
    {
        if (odd(i))
            mem[q + (i / 2) + 1].hh.v.RH = curptr;
        else
            mem[q + (i / 2) + 1].hh.v.LH = curptr;
        incr(mem[q].hh.b1);
    }
    q = curptr;
    i = n % 16;
labfindsaelement49not_found4
    : /* comment:Create a new array element of type |t| with index  */
    if (t == MARKVAL) {
        curptr = getnode(MARKCLASSNODESIZE);
        mem[curptr + 1] = sanull;
        mem[curptr + 2] = sanull;
        mem[curptr + 3] = sanull;
    } else {

        if (t <= DIMENVAL) {
            curptr = getnode(WORDNODESIZE);
            mem[curptr + 2].cint = 0;
            mem[curptr + 1].hh.v.RH = n;
        } else {

            curptr = getnode(POINTERNODESIZE);
            if (t <= MUVAL) {
                mem[curptr + 1].hh.v.RH = membot;
                incr(mem[membot].hh.v.RH);
            } else
                mem[curptr + 1].hh.v.RH = TEXNULL;
        }
        mem[curptr + 1].hh.v.LH = TEXNULL;
    }
    mem[curptr].hh.b0 = 16 * t + i;
    mem[curptr].hh.b1 = LEVELONE;
    mem[curptr].hh.v.RH = q;
    {
        if (odd(i))
            mem[q + (i / 2) + 1].hh.v.RH = curptr;
        else
            mem[q + (i / 2) + 1].hh.v.LH = curptr;
        incr(mem[q].hh.b1);
    }
}
void expand(void) {
    expand_regmem halfword t;
    boolean b;
    halfword p, q, r;
    integer j;
    integer cvbackup;
    smallnumber cvlbackup, radixbackup, cobackup;
    halfword backupbackup;
    smallnumber savescannerstatus;
    incr(expanddepthcount);
    if (expanddepthcount >= expanddepth)
        overflow(/* str 'expansion depth' */ 705, expanddepth);
    cvbackup = curval;
    cvlbackup = curvallevel;
    radixbackup = radix;
    cobackup = curorder;
    backupbackup = mem[memtop - 13].hh.v.RH;
labexpand21reswitch:
    if (curcmd < CALL) /* comment:Expand a nonmacro */
    {
        if (eqtb[INTBASE + TRACINGCOMMANDSCODE].cint > 1)
            showcurcmdchr();
        switch (curcmd) {
        case TOPBOTMARK:
            /* comment:Insert the \(a)appropriate mark text into the scan */ {

                t = curchr % 5;
                if (curchr >= 5)
                    scanregisternum();
                else
                    curval = 0;
                if (curval == 0)
                    curptr = curmark[t];
                else /* comment:Compute the mark pointer for mark type |t| and
                        cla */
                {

                    findsaelement(MARKVAL, curval, false);
                    if (curptr != TEXNULL) {

                        if (odd(t))
                            curptr = mem[curptr + (t / 2) + 1].hh.v.RH;
                        else
                            curptr = mem[curptr + (t / 2) + 1].hh.v.LH;
                    }
                }
                if (curptr != TEXNULL)
                    begintokenlist(curptr, MARKTEXT);
            }
            break;
        case EXPANDAFTER:
            if (curchr == 0) /* comment:Expand the token after the next token */
            {
                gettoken();
                t = curtok;
                gettoken();
                if (curcmd > MAXCOMMAND)
                    expand();
                else
                    backinput();
                curtok = t;
                backinput();
            } else /* comment:Negate a boolean conditional and |goto reswitch|
                    */
            {

                gettoken();
                if ((curcmd == IFTEST) && (curchr != IFCASECODE)) {
                    curchr = curchr + UNLESSCODE;
                    goto labexpand21reswitch;
                }
                {
                    if (interaction == ERRORSTOPMODE)
                        ;
                    if (filelineerrorstylep)
                        printfileline();
                    else
                        printnl(/* str '! ' */ 264);
                    print(/* str 'You can't use `' */ 786);
                }
                printesc(/* str 'unless' */ 928);
                print(/* str '' before `' */ 2042);
                printcmdchr(curcmd, curchr);
                printchar(/* str ''' */ 39);
                {
                    helpptr = 1;
                    helpline[0] = /* str 'Continue, and I'll forget that it ever
                                     happened.' */
                        701;
                }
                backerror();
            }
            break;
        case NOEXPAND:
            if (curchr == 0) /* comment:Suppress expansion of the next token */
            {
                savescannerstatus = scannerstatus;
                scannerstatus = NORMAL;
                gettoken();
                scannerstatus = savescannerstatus;
                t = curtok;
                backinput();
                if (t >= 4095) {
                    p = getavail();
                    mem[p].hh.v.LH = /* @d4582@ */ 19618;
                    mem[p].hh.v.RH = curinput.locfield;
                    curinput.startfield = p;
                    curinput.locfield = p;
                }
            } else /* comment:Implement \.{\\pdfprimitive} */ {

                savescannerstatus = scannerstatus;
                scannerstatus = NORMAL;
                gettoken();
                scannerstatus = savescannerstatus;
                if (curcs < HASHBASE)
                    curcs = primlookup(curcs - SINGLEBASE);
                else
                    curcs = primlookup(hash[curcs].v.RH);
                if (curcs != UNDEFINEDPRIMITIVE) {
                    t = eqtb[PRIMEQTBBASE + curcs].hh.b0;
                    if (t > MAXCOMMAND) {
                        curcmd = t;
                        curchr = eqtb[PRIMEQTBBASE + curcs].hh.v.RH;
                        curtok = (curcmd * 256) + curchr;
                        curcs = 0;
                        goto labexpand21reswitch;
                    } else {

                        backinput();
                        p = getavail();
                        mem[p].hh.v.LH = /* @d4592@ */ 19620;
                        mem[p].hh.v.RH = curinput.locfield;
                        curinput.locfield = p;
                        curinput.startfield = p;
                    }
                }
            }
            break;
        case CSNAME:
            /* comment:Manufacture a control sequence name */ {

                r = getavail();
                p = r;
                b = isincsname;
                isincsname = true;
                do {
                    getxtoken();
                    if (curcs == 0) {
                        q = getavail();
                        mem[p].hh.v.RH = q;
                        mem[q].hh.v.LH = curtok;
                        p = q;
                    }
                } while (!(curcs != 0));
                if ((curcmd != ENDCSNAME) ||
                    (curchr !=
                     0)) /* comment:Complain about missing \.{\\endcsname} */
                {
                    {
                        if (interaction == ERRORSTOPMODE)
                            ;
                        if (filelineerrorstylep)
                            printfileline();
                        else
                            printnl(/* str '! ' */ 264);
                        print(/* str 'Missing ' */ 712);
                    }
                    printesc(/* str 'endcsname' */ 581);
                    print(/* str ' inserted' */ 713);
                    {
                        helpptr = 2;
                        helpline[1] = /* str 'The control sequence marked <to be
                                         read again> sh' */
                            714;
                        helpline[0] = /* str 'not appear between \csname and
                                         \endcsname.' */
                            715;
                    }
                    backerror();
                }
                isincsname = b;
                /* comment:Look up the characters of list |r| in the hash tab */
                j = first;
                p = mem[r].hh.v.RH;
                while (p != TEXNULL) {

                    if (j >= maxbufstack) {
                        maxbufstack = j + 1;
                        if (maxbufstack == bufsize)
                            overflow(/* str 'buffer size' */ 258, bufsize);
                    }
                    buffer[j] = mem[p].hh.v.LH % 256;
                    incr(j);
                    p = mem[p].hh.v.RH;
                }
                if (j > first + 1) {
                    nonewcontrolsequence = false;
                    curcs = idlookup(first, j - first);
                    nonewcontrolsequence = true;
                } else if (j == first)
                    curcs = NULLCS;
                else
                    curcs = SINGLEBASE + buffer[first];
                flushlist(r);
                if (eqtb[curcs].hh.b0 == UNDEFINEDCS) {
                    eqdefine(curcs, RELAX, 256);
                }
                curtok = curcs + 4095;
                backinput();
            }
            break;
        case CONVERT:
            convtoks();
            break;
        case THE:
            insthetoks();
            break;
        case IFTEST:
            conditional();
            break;
        case FIORELSE:
            /* comment:Terminate the current conditional and skip to \.{\ */ {

                if (eqtb[INTBASE + TRACINGIFSCODE].cint > 0) {

                    if (eqtb[INTBASE + TRACINGCOMMANDSCODE].cint <= 1)
                        showcurcmdchr();
                }
                if (curchr > iflimit) {

                    if (iflimit == IFCODE)
                        insertrelax();
                    else {

                        {
                            if (interaction == ERRORSTOPMODE)
                                ;
                            if (filelineerrorstylep)
                                printfileline();
                            else
                                printnl(/* str '! ' */ 264);
                            print(/* str 'Extra ' */ 932);
                        }
                        printcmdchr(FIORELSE, curchr);
                        {
                            helpptr = 1;
                            helpline[0] = /* str 'I'm ignoring this; it doesn't
                                             match any \if.' */
                                933;
                        }
                        error();
                    }
                } else {

                    while (curchr != FICODE)
                        passtext();
                    /* comment:Pop the condition stack */ {

                        if (ifstack[inopen] == condptr)
                            ifwarning();
                        p = condptr;
                        ifline = mem[p + 1].cint;
                        curif = mem[p].hh.b1;
                        iflimit = mem[p].hh.b0;
                        condptr = mem[p].hh.v.RH;
                        freenode(p, IFNODESIZE);
                    }
                }
            }
            break;
        case INPUT:
            /* comment:Initiate or terminate input from a file */ if (curchr ==
                                                                      1)
                forceeof = true /* comment:Cases for |input| */;
            else if (curchr == 2)
                pseudostart();
            else if (nameinprogress)
                insertrelax();
            else
                startinput();
            break;
        default:
            /* comment:Complain about an undefined macro */ {

                {
                    if (interaction == ERRORSTOPMODE)
                        ;
                    if (filelineerrorstylep)
                        printfileline();
                    else
                        printnl(/* str '! ' */ 264);
                    print(/* str 'Undefined control sequence' */ 706);
                }
                {
                    helpptr = 5;
                    helpline[4] = /* str 'The control sequence at the end of the
                                     top line' */
                        707;
                    helpline[3] = /* str 'of your error message was never
                                     \def'ed. If you h' */
                        708;
                    helpline[2] = /* str 'misspelled it (e.g., `\hobx'), type
                                     `I' and the c' */
                        709;
                    helpline[1] = /* str 'spelling (e.g., `I\hbox'). Otherwise
                                     just continu' */
                        710;
                    helpline[0] = /* str 'and I'll forget about whatever was
                                     undefined.' */
                        711;
                }
                error();
            }
            break;
        }
    } else if (curcmd < ENDTEMPLATE)
        macrocall();
    else /* comment:Insert a token containing |frozen_endv| */ {

        curtok = /* @d4642@ */ 19615;
        backinput();
    }
    curval = cvbackup;
    curvallevel = cvlbackup;
    radix = radixbackup;
    curorder = cobackup;
    mem[memtop - 13].hh.v.RH = backupbackup;
    decr(expanddepthcount);
}
void getxtoken(void) {
    getxtoken_regmem labgetxtoken20restart : getnext();
    if (curcmd <= MAXCOMMAND)
        goto labgetxtoken30done;
    if (curcmd >= CALL) {

        if (curcmd < ENDTEMPLATE)
            macrocall();
        else {

            curcs = FROZENENDV;
            curcmd = ENDV;
            goto labgetxtoken30done;
        }
    } else
        expand();
    goto labgetxtoken20restart;
labgetxtoken30done:
    if (curcs == 0)
        curtok = (curcmd * 256) + curchr;
    else
        curtok = 4095 + curcs;
}
void xtoken(void) {
    xtoken_regmem while (curcmd > MAXCOMMAND) {

        expand();
        getnext();
    }
    if (curcs == 0)
        curtok = (curcmd * 256) + curchr;
    else
        curtok = 4095 + curcs;
}
void scanleftbrace(void) {
    scanleftbrace_regmem
        /* comment:Get the next non-blank non-relax non-call token */ do {
        getxtoken();
    }
    while (!((curcmd != SPACER) && (curcmd != RELAX)))
        ;
    if (curcmd != LEFTBRACE) {
        {
            if (interaction == ERRORSTOPMODE)
                ;
            if (filelineerrorstylep)
                printfileline();
            else
                printnl(/* str '! ' */ 264);
            print(/* str 'Missing { inserted' */ 744);
        }
        {
            helpptr = 4;
            helpline[3] =
                /* str 'A left brace was mandatory here, so I've put one ' */
                745;
            helpline[2] =
                /* str 'You might want to delete andor insert some corre' */
                746;
            helpline[1] =
                /* str 'so that I will find a matching right brace soon.' */
                747;
            helpline[0] =
                /* str '(If you're confused by all this, try typing `I}' ' */
                748;
        }
        backerror();
        curtok = /* @d4667@ */ /* str '{' */ 379;
        curcmd = LEFTBRACE;
        curchr = /* str '{' */ 123;
        incr(alignstate);
    }
}
void scanoptionalequals(void) {
    scanoptionalequals_regmem
        /* comment:Get the next non-blank non-call token */ do {
        getxtoken();
    }
    while (!(curcmd != SPACER))
        ;
    if (curtok != /* @d4673@ */ /* str '=' */ 3133)
        backinput();
}
boolean zscankeyword(strnumber s) {
    register boolean Result;
    scankeyword_regmem halfword p;
    halfword q;
    poolpointer k;
    halfword savecurcs;
    p = memtop - 13;
    mem[p].hh.v.RH = TEXNULL;
    k = strstart[s];
    savecurcs = curcs;
    while (k < strstart[s + 1]) {

        getxtoken();
        if ((curcs == 0) &&
            ((curchr == strpool[k]) ||
             (curchr == strpool[k] /* str 'a' */ /* str 'A' */ - 32))) {
            {
                q = getavail();
                mem[p].hh.v.RH = q;
                mem[q].hh.v.LH = curtok;
                p = q;
            }
            incr(k);
        } else if ((curcmd != SPACER) || (p != memtop - 13)) {
            backinput();
            if (p != memtop - 13)
                begintokenlist(mem[memtop - 13].hh.v.RH, BACKEDUP);
            curcs = savecurcs;
            Result = false;
            return Result;
        }
    }
    flushlist(mem[memtop - 13].hh.v.RH);
    Result = true;
    return Result;
}
void muerror(void) {
    muerror_regmem {
        if (interaction == ERRORSTOPMODE)
            ;
        if (filelineerrorstylep)
            printfileline();
        else
            printnl(/* str '! ' */ 264);
        print(/* str 'Incompatible glue units' */ 749);
    }
    {
        helpptr = 1;
        helpline[0] =
            /* str 'I'm going to assume that 1mu=1pt when they're mix' */ 750;
    }
    error();
}
/* comment:Declare procedures that scan restricted classes of */ void
scaneightbitint(void) {
    scaneightbitint_regmem scanint();
    if ((curval < 0) || (curval > 255)) {
        {
            if (interaction == ERRORSTOPMODE)
                ;
            if (filelineerrorstylep)
                printfileline();
            else
                printnl(/* str '! ' */ 264);
            print(/* str 'Bad register code' */ 788);
        }
        {
            helpptr = 2;
            helpline[1] =
                /* str 'A register number must be between 0 and 255.' */ 789;
            helpline[0] = /* str 'I changed this one to zero.' */ 790;
        }
        interror(curval);
        curval = 0;
    }
}
void scancharnum(void) {
    scancharnum_regmem scanint();
    if ((curval < 0) || (curval > 255)) {
        {
            if (interaction == ERRORSTOPMODE)
                ;
            if (filelineerrorstylep)
                printfileline();
            else
                printnl(/* str '! ' */ 264);
            print(/* str 'Bad character code' */ 791);
        }
        {
            helpptr = 2;
            helpline[1] =
                /* str 'A character number must be between 0 and 255.' */ 792;
            helpline[0] = /* str 'I changed this one to zero.' */ 790;
        }
        interror(curval);
        curval = 0;
    }
}
void scanfourbitint(void) {
    scanfourbitint_regmem scanint();
    if ((curval < 0) || (curval > 15)) {
        {
            if (interaction == ERRORSTOPMODE)
                ;
            if (filelineerrorstylep)
                printfileline();
            else
                printnl(/* str '! ' */ 264);
            print(/* str 'Bad number' */ 793);
        }
        {
            helpptr = 2;
            helpline[1] =
                /* str 'Since I expected to read a number between 0 and 1' */
                794;
            helpline[0] = /* str 'I changed this one to zero.' */ 790;
        }
        interror(curval);
        curval = 0;
    }
}
void scanfifteenbitint(void) {
    scanfifteenbitint_regmem scanint();
    if ((curval < 0) || (curval > 32767)) {
        {
            if (interaction == ERRORSTOPMODE)
                ;
            if (filelineerrorstylep)
                printfileline();
            else
                printnl(/* str '! ' */ 264);
            print(/* str 'Bad mathchar' */ 795);
        }
        {
            helpptr = 2;
            helpline[1] =
                /* str 'A mathchar number must be between 0 and 32767.' */ 796;
            helpline[0] = /* str 'I changed this one to zero.' */ 790;
        }
        interror(curval);
        curval = 0;
    }
}
void scantwentysevenbitint(void) {
    scantwentysevenbitint_regmem scanint();
    if ((curval < 0) || (curval > 134217727L)) {
        {
            if (interaction == ERRORSTOPMODE)
                ;
            if (filelineerrorstylep)
                printfileline();
            else
                printnl(/* str '! ' */ 264);
            print(/* str 'Bad delimiter code' */ 797);
        }
        {
            helpptr = 2;
            helpline[1] =
                /* str 'A numeric delimiter code must be between 0 and 2^' */
                798;
            helpline[0] = /* str 'I changed this one to zero.' */ 790;
        }
        interror(curval);
        curval = 0;
    }
}
void scanregisternum(void) {
    scanregisternum_regmem scanint();
    if ((curval < 0) || (curval > maxregnum)) {
        {
            if (interaction == ERRORSTOPMODE)
                ;
            if (filelineerrorstylep)
                printfileline();
            else
                printnl(/* str '! ' */ 264);
            print(/* str 'Bad register code' */ 788);
        }
        {
            helpptr = 2;
            helpline[1] = maxreghelpline;
            helpline[0] = /* str 'I changed this one to zero.' */ 790;
        }
        interror(curval);
        curval = 0;
    }
}
void scanfourbitintor18(void) {
    scanfourbitintor18_regmem scanint();
    if ((curval < 0) || ((curval > 15) && (curval != 18))) {
        {
            if (interaction == ERRORSTOPMODE)
                ;
            if (filelineerrorstylep)
                printfileline();
            else
                printnl(/* str '! ' */ 264);
            print(/* str 'Bad number' */ 793);
        }
        {
            helpptr = 2;
            helpline[1] =
                /* str 'Since I expected to read a number between 0 and 1' */
                794;
            helpline[0] = /* str 'I changed this one to zero.' */ 790;
        }
        interror(curval);
        curval = 0;
    }
}
/* comment:Declare \eTeX\ procedures for scanning */ void
getxorprotected(void) {
    getxorprotected_regmem while (true) {

        gettoken();
        if (curcmd <= MAXCOMMAND)
            return;
        if ((curcmd >= CALL) && (curcmd < ENDTEMPLATE)) {

            if (mem[mem[curchr].hh.v.RH].hh.v.LH == PROTECTEDTOKEN)
                return;
        }
        expand();
    }
}
integer zeffectivechar(boolean errp, internalfontnumber f, quarterword c) {
    register integer Result;
    effectivechar_regmem integer basec;
    integer result;
    result = c;
    if (!mltexenabledp)
        goto labeffectivechar40found;
    if (fontec[f] >= c) {

        if (fontbc[f] <= c) {

            if ((fontinfo[charbase[f] + c].qqqq.b0 > MINQUARTERWORD))
                goto labeffectivechar40found;
        }
    }
    if (c >= eqtb[INTBASE + CHARSUBDEFMINCODE].cint) {

        if (c <= eqtb[INTBASE + CHARSUBDEFMAXCODE].cint) {

            if ((eqtb[CHARSUBCODEBASE + c].hh.v.RH > 0)) {
                basec = (eqtb[CHARSUBCODEBASE + c].hh.v.RH % 256);
                result = basec;
                if (!errp)
                    goto labeffectivechar40found;
                if (fontec[f] >= basec) {

                    if (fontbc[f] <= basec) {

                        if ((fontinfo[charbase[f] + basec].qqqq.b0 >
                             MINQUARTERWORD))
                            goto labeffectivechar40found;
                    }
                }
            }
        }
    }
    if (errp) {
        begindiagnostic();
        printnl(/* str 'Missing character' */ 983);
        print(/* str 'substitution for ' */ 2075);
        print(c);
        print(/* str ' in font ' */ 984);
        slowprint(fontname[f]);
        printchar(/* str '!' */ 33);
        enddiagnostic(false);
        result = fontbc[f];
    }
labeffectivechar40found:
    Result = result;
    return Result;
}
/* comment:Declare procedures that scan font-related stuff */ integer
ztestnoligatures(internalfontnumber f) {
    register integer Result;
    testnoligatures_regmem integer c;
    Result = 1;
    {
        register integer for_end;
        c = fontbc[f];
        for_end = fontec[f];
        if (c <= for_end)
            do
                if ((fontinfo[charbase[f] + c].qqqq.b0 > MINQUARTERWORD)) {

                    if (odd(((fontinfo[charbase[f] + c].qqqq.b2) % 4))) {
                        Result = 0;
                        return Result;
                    }
                }
            while (c++ < for_end);
    }
    return Result;
}
integer zgettagcode(internalfontnumber f, eightbits c) {
    register integer Result;
    gettagcode_regmem smallnumber i;
    if (((fontbc[f] <= c) && (c <= fontec[f]) &&
         (fontinfo[charbase[f] + c].qqqq.b0 > MINQUARTERWORD))) {
        i = ((fontinfo[charbase[f] + c].qqqq.b2) % 4);
        if (i == LIGTAG)
            Result = 1;
        else if (i == LISTTAG)
            Result = 2;
        else if (i == EXTTAG)
            Result = 4;
        else
            Result = 0;
    } else
        Result = -1;
    return Result;
}
void scanfontident(void) {
    scanfontident_regmem internalfontnumber f;
    halfword m;
    /* comment:Get the next non-blank non-call token */ do {
        getxtoken();
    } while (!(curcmd != SPACER));
    if ((curcmd == DEFFONT) || (curcmd == LETTERSPACEFONT) ||
        (curcmd == PDFCOPYFONT))
        f = eqtb[CURFONTLOC].hh.v.RH;
    else if (curcmd == SETFONT)
        f = curchr;
    else if (curcmd == DEFFAMILY) {
        m = curchr;
        scanfourbitint();
        f = eqtb[m + curval].hh.v.RH;
    } else {

        {
            if (interaction == ERRORSTOPMODE)
                ;
            if (filelineerrorstylep)
                printfileline();
            else
                printnl(/* str '! ' */ 264);
            print(/* str 'Missing font identifier' */ 975);
        }
        {
            helpptr = 2;
            helpline[1] =
                /* str 'I was looking for a control sequence whose' */ 976;
            helpline[0] =
                /* str 'current meaning has been defined by \font.' */ 977;
        }
        backerror();
        f = FONTBASE;
    }
    curval = f;
}
void zfindfontdimen(boolean writing) {
    findfontdimen_regmem internalfontnumber f;
    integer n;
    scanint();
    n = curval;
    scanfontident();
    f = curval;
    if (n <= 0)
        curval = fmemptr;
    else {

        if (writing && (n <= SPACESHRINKCODE) && (n >= SPACECODE) &&
            (fontglue[f] != TEXNULL)) {
            deleteglueref(fontglue[f]);
            fontglue[f] = TEXNULL;
        }
        if (n > fontparams[f]) {

            if (f < fontptr)
                curval = fmemptr;
            else /* comment:Increase the number of parameters in the last font
                  */
            {

                do {
                    if (fmemptr == fontmemsize)
                        overflow(/* str 'font memory' */ 982, fontmemsize);
                    fontinfo[fmemptr].cint = 0;
                    incr(fmemptr);
                    incr(fontparams[f]);
                } while (!(n == fontparams[f]));
                curval = fmemptr - 1;
            }
        } else
            curval = n + parambase[f];
    }
    /* comment:Issue an error message if |cur_val=fmem_ptr| */ if (curval ==
                                                                   fmemptr) {
        {
            if (interaction == ERRORSTOPMODE)
                ;
            if (filelineerrorstylep)
                printfileline();
            else
                printnl(/* str '! ' */ 264);
            print(/* str 'Font ' */ 957);
        }
        printesc(hash[FONTIDBASE + f].v.RH);
        print(/* str ' has only ' */ 978);
        printint(fontparams[f]);
        print(/* str ' fontdimen parameters' */ 979);
        {
            helpptr = 2;
            helpline[1] =
                /* str 'To increase the number of font parameters, you mu' */
                980;
            helpline[0] =
                /* str 'use \fontdimen immediately after the \font is loa' */
                981;
        }
        error();
    }
}
void zscansomethinginternal(smallnumber level, boolean negative) {
    scansomethinginternal_regmem halfword m;
    integer n, k;
    halfword q, r;
    halfword tx;
    fourquarters i;
    integer p;
labscansomethinginternal20restart:
    m = curchr;
    switch (curcmd) {
    case DEFCODE:
        /* comment:Fetch a character code from some table */ {

            scancharnum();
            if (m == XORDCODEBASE) {
                curval = xord[curval];
                curvallevel = INTVAL;
            } else if (m == XCHRCODEBASE) {
                curval = xchr[curval];
                curvallevel = INTVAL;
            } else if (m == XPRNCODEBASE) {
                curval = xprn[curval];
                curvallevel = INTVAL;
            } else if (m == MATHCODEBASE) {
                curval = eqtb[MATHCODEBASE + curval].hh.v.RH;
                curvallevel = INTVAL;
            } else if (m < MATHCODEBASE) {
                curval = eqtb[m + curval].hh.v.RH;
                curvallevel = INTVAL;
            } else {

                curval = eqtb[m + curval].cint;
                curvallevel = INTVAL;
            }
        }
        break;
    case TOKSREGISTER:
    case ASSIGNTOKS:
    case DEFFAMILY:
    case SETFONT:
    case DEFFONT:
    case LETTERSPACEFONT:
    case PDFCOPYFONT:
        /* comment:Fetch a token list or font identifier, provided th */
        if (level != TOKVAL) {
            {
                if (interaction == ERRORSTOPMODE)
                    ;
                if (filelineerrorstylep)
                    printfileline();
                else
                    printnl(/* str '! ' */ 264);
                print(/* str 'Missing number, treated as zero' */ 751);
            }
            {
                helpptr = 3;
                helpline[2] =
                    /* str 'A number should have been here; I inserted `0'.' */
                    752;
                helpline[1] = /* str '(If you can't figure out why I needed to
                                 see a nu' */
                    753;
                helpline[0] = /* str 'look up `weird error' in the index to The
                                 TeXbook' */
                    754;
            }
            backerror();
            {
                curval = 0;
                curvallevel = DIMENVAL;
            }
        } else if (curcmd <= ASSIGNTOKS) {
            if (curcmd < ASSIGNTOKS) {

                if (m == membot) {
                    scanregisternum();
                    if (curval < 256)
                        curval = eqtb[TOKSBASE + curval].hh.v.RH;
                    else {

                        findsaelement(TOKVAL, curval, false);
                        if (curptr == TEXNULL)
                            curval = TEXNULL;
                        else
                            curval = mem[curptr + 1].hh.v.RH;
                    }
                } else
                    curval = mem[m + 1].hh.v.RH;
            } else
                curval = eqtb[m].hh.v.RH;
            curvallevel = TOKVAL;
        } else {

            backinput();
            scanfontident();
            {
                curval = FONTIDBASE + curval;
                curvallevel = IDENTVAL;
            }
        }
        break;
    case ASSIGNINT: {
        curval = eqtb[m].cint;
        curvallevel = INTVAL;
    } break;
    case ASSIGNDIMEN: {
        curval = eqtb[m].cint;
        curvallevel = DIMENVAL;
    } break;
    case ASSIGNGLUE: {
        curval = eqtb[m].hh.v.RH;
        curvallevel = GLUEVAL;
    } break;
    case ASSIGNMUGLUE: {
        curval = eqtb[m].hh.v.RH;
        curvallevel = MUVAL;
    } break;
    case SETAUX:
        /* comment:Fetch the |space_factor| or the |prev_depth| */
        if (abs(curlist.modefield) != m) {
            {
                if (interaction == ERRORSTOPMODE)
                    ;
                if (filelineerrorstylep)
                    printfileline();
                else
                    printnl(/* str '! ' */ 264);
                print(/* str 'Improper ' */ 781);
            }
            printcmdchr(SETAUX, m);
            {
                helpptr = 4;
                helpline[3] = /* str 'You can refer to \spacefactor only in
                                 horizontal ' */
                    782;
                helpline[2] = /* str 'you can refer to \prevdepth only in
                                 vertical mode' */
                    783;
                helpline[1] =
                    /* str 'neither of these is meaningful inside \write. So' */
                    784;
                helpline[0] = /* str 'I'm forgetting what you said and using
                                 zero inste' */
                    785;
            }
            error();
            if (level != TOKVAL) {
                curval = 0;
                curvallevel = DIMENVAL;
            } else {

                curval = 0;
                curvallevel = INTVAL;
            }
        } else if (m == VMODE) {
            curval = curlist.auxfield.cint;
            curvallevel = DIMENVAL;
        } else {

            curval = curlist.auxfield.hh.v.LH;
            curvallevel = INTVAL;
        }
        break;
    case SETPREVGRAF:
        /* comment:Fetch the |prev_graf| */ if (curlist.modefield == 0) {
            curval = 0;
            curvallevel = INTVAL;
        } else {

            nest[nestptr] = curlist;
            p = nestptr;
            while (abs(nest[p].modefield) != VMODE)
                decr(p);
            {
                curval = nest[p].pgfield;
                curvallevel = INTVAL;
            }
        }
        break;
    case SETPAGEINT:
        /* comment:Fetch the |dead_cycles| or the |insert_penalties| */ {

            if (m == 0)
                curval = /* comment:Cases for `Fetch the |dead_cycles| or the
                            |insert_ */
                    deadcycles;
            else if (m == 2)
                curval = interaction;
            else
                curval = insertpenalties;
            curvallevel = INTVAL;
        }
        break;
    case SETPAGEDIMEN:
        /* comment:Fetch something on the |page_so_far| */ {

            if ((pagecontents == EMPTY) && (!outputactive)) {

                if (m == 0)
                    curval = 1073741823L;
                else
                    curval = 0;
            } else
                curval = pagesofar[m];
            curvallevel = DIMENVAL;
        }
        break;
    case SETSHAPE:
        /* comment:Fetch the |par_shape| size */ {

            if (m > PARSHAPELOC) /* comment:Fetch a penalties array
                                            element */
            {
                scanint();
                if ((eqtb[m].hh.v.RH == TEXNULL) || (curval < 0))
                    curval = 0;
                else {

                    if (curval > mem[eqtb[m].hh.v.RH + 1].cint)
                        curval = mem[eqtb[m].hh.v.RH + 1].cint;
                    curval = mem[eqtb[m].hh.v.RH + curval + 1].cint;
                }
            } else if (eqtb[PARSHAPELOC].hh.v.RH == TEXNULL)
                curval = 0;
            else
                curval = mem[eqtb[PARSHAPELOC].hh.v.RH].hh.v.LH;
            curvallevel = INTVAL;
        }
        break;
    case SETBOXDIMEN:
        /* comment:Fetch a box dimension */ {

            scanregisternum();
            if (curval < 256)
                q = eqtb[BOXBASE + curval].hh.v.RH;
            else {

                findsaelement(4, curval, false);
                if (curptr == TEXNULL)
                    q = TEXNULL;
                else
                    q = mem[curptr + 1].hh.v.RH;
            }
            if (q == TEXNULL)
                curval = 0;
            else
                curval = mem[q + m].cint;
            curvallevel = DIMENVAL;
        }
        break;
    case CHARGIVEN:
    case MATHGIVEN: {
        curval = curchr;
        curvallevel = INTVAL;
    } break;
    case ASSIGNFONTDIMEN:
        /* comment:Fetch a font dimension */ {

            findfontdimen(false);
            fontinfo[fmemptr].cint = 0;
            {
                curval = fontinfo[curval].cint;
                curvallevel = DIMENVAL;
            }
        }
        break;
    case ASSIGNFONTINT:
        /* comment:Fetch a font integer */ {

            scanfontident();
            if (m == 0) {
                curval = hyphenchar[curval];
                curvallevel = INTVAL;
            } else if (m == 1) {
                curval = skewchar[curval];
                curvallevel = INTVAL;
            } else if (m == 6) {
                curval = testnoligatures(curval);
                curvallevel = INTVAL;
            } else {

                n = curval;
                scancharnum();
                k = curval;
                switch (m) {
                case 2: {
                    curval = getlpcode(n, k);
                    curvallevel = INTVAL;
                } break;
                case 3: {
                    curval = getrpcode(n, k);
                    curvallevel = INTVAL;
                } break;
                case 4: {
                    curval = getefcode(n, k);
                    curvallevel = INTVAL;
                } break;
                case 5: {
                    curval = gettagcode(n, k);
                    curvallevel = INTVAL;
                } break;
                case 7: {
                    curval = getknbscode(n, k);
                    curvallevel = INTVAL;
                } break;
                case 8: {
                    curval = getstbscode(n, k);
                    curvallevel = INTVAL;
                } break;
                case 9: {
                    curval = getshbscode(n, k);
                    curvallevel = INTVAL;
                } break;
                case 10: {
                    curval = getknbccode(n, k);
                    curvallevel = INTVAL;
                } break;
                case 11: {
                    curval = getknaccode(n, k);
                    curvallevel = INTVAL;
                } break;
                }
            }
        }
        break;
    case REGISTER:
        /* comment:Fetch a register */ {

            if ((m < membot) ||
                (m > /* @d4894@ */ /* @d4895@ */ /* @d4896@ */ /* @d4897@ */
                         /* @d4898@ */ membot + 19)) {
                curvallevel = (mem[m].hh.b0 / 16);
                if (curvallevel < GLUEVAL)
                    curval = mem[m + 2].cint;
                else
                    curval = mem[m + 1].hh.v.RH;
            } else {

                scanregisternum();
                curvallevel = m - membot;
                if (curval > 255) {
                    findsaelement(curvallevel, curval, false);
                    if (curptr == TEXNULL) {

                        if (curvallevel < GLUEVAL)
                            curval = 0;
                        else
                            curval = membot;
                    } else if (curvallevel < GLUEVAL)
                        curval = mem[curptr + 2].cint;
                    else
                        curval = mem[curptr + 1].hh.v.RH;
                } else
                    switch (curvallevel) {
                    case INTVAL:
                        curval = eqtb[COUNTBASE + curval].cint;
                        break;
                    case DIMENVAL:
                        curval = eqtb[SCALEDBASE + curval].cint;
                        break;
                    case GLUEVAL:
                        curval = eqtb[SKIPBASE + curval].hh.v.RH;
                        break;
                    case MUVAL:
                        curval = eqtb[MUSKIPBASE + curval].hh.v.RH;
                        break;
                    }
            }
        }
        break;
    case LASTITEM:
        /* comment:Fetch an item in the current node, if appropriate */
        if (m >= INPUTLINENOCODE) {

            if (m >= ETEXGLUE) /* comment:Process an expression and
                                          |return| */
            {
                if (m < ETEXMU) {
                    switch (m) {
                        /* comment:Cases for fetching a glue value */ /* @d4917@
                                                                       */
                    case 37:
                        scanmuglue();
                        break;
                    }
                    curvallevel = GLUEVAL;
                } else if (m < ETEXEXPR) {
                    switch (m) {
                        /* comment:Cases for fetching a mu value */ /* @d4921@
                                                                     */
                    case 38:
                        scannormalglue();
                        break;
                    }
                    curvallevel = MUVAL;
                } else {

                    curvallevel = /* @d4923@ */ /* @d4924@ */ m - 39;
                    scanexpr();
                }
                while (curvallevel > level) {

                    if (curvallevel == GLUEVAL) {
                        m = curval;
                        curval = mem[m + WIDTHOFFSET].cint;
                        deleteglueref(m);
                    } else if (curvallevel == MUVAL)
                        muerror();
                    decr(curvallevel);
                }
                if (negative) {

                    if (curvallevel >= GLUEVAL) {
                        m = curval;
                        curval = newspec(m);
                        deleteglueref(m);
                        /* comment:Negate all three glue components of |cur_val|
                         */
                        {

                            mem[curval + WIDTHOFFSET].cint =
                                -(integer)mem[curval + WIDTHOFFSET].cint;
                            mem[curval + 2].cint =
                                -(integer)mem[curval + 2].cint;
                            mem[curval + 3].cint =
                                -(integer)mem[curval + 3].cint;
                        }
                    } else
                        curval = -(integer)curval;
                }
                return;
            } else if (m >= ETEXDIM) {
                switch (m) {
                    /* comment:Cases for fetching a dimension value */ /* @d4935@
                                                                        */
                case 28:
                case FONTCHARHTCODE:
                case FONTCHARDPCODE:
                case FONTCHARICCODE: {
                    scanfontident();
                    q = curval;
                    scancharnum();
                    if ((fontbc[q] <= curval) && (fontec[q] >= curval)) {
                        i = fontinfo[charbase[q] +
                                     effectivechar(true, q, curval)]
                                .qqqq;
                        switch (m) {
                        case FONTCHARWDCODE:
                            curval = fontinfo[widthbase[q] + i.b0].cint;
                            break;
                        case FONTCHARHTCODE:
                            curval = fontinfo[heightbase[q] + (i.b1) / 16].cint;
                            break;
                        case FONTCHARDPCODE:
                            curval = fontinfo[depthbase[q] + (i.b1) % 16].cint;
                            break;
                        case FONTCHARICCODE:
                            curval = fontinfo[italicbase[q] + (i.b2) / 4].cint;
                            break;
                        }
                    } else
                        curval = 0;
                } break;
                case PARSHAPELENGTHCODE:
                case PARSHAPEINDENTCODE:
                case PARSHAPEDIMENCODE: {
                    q = curchr - PARSHAPELENGTHCODE;
                    scanint();
                    if ((eqtb[PARSHAPELOC].hh.v.RH == TEXNULL) || (curval <= 0))
                        curval = 0;
                    else {

                        if (q == 2) {
                            q = curval % 2;
                            curval = (curval + q) / 2;
                        }
                        if (curval > mem[eqtb[PARSHAPELOC].hh.v.RH].hh.v.LH)
                            curval = mem[eqtb[PARSHAPELOC].hh.v.RH].hh.v.LH;
                        curval = mem[eqtb[PARSHAPELOC].hh.v.RH + 2 * curval - q]
                                     .cint;
                    }
                    curvallevel = DIMENVAL;
                } break;
                case GLUESTRETCHCODE:
                case GLUESHRINKCODE: {
                    scannormalglue();
                    q = curval;
                    if (m == GLUESTRETCHCODE)
                        curval = mem[q + 2].cint;
                    else
                        curval = mem[q + 3].cint;
                    deleteglueref(q);
                } break;
                }
                curvallevel = DIMENVAL;
            } else {

                switch (m) {
                case INPUTLINENOCODE:
                    curval = line;
                    break;
                case BADNESSCODE:
                    curval = lastbadness;
                    break;
                case PDFTEXVERSIONCODE:
                    curval = 140;
                    break;
                case PDFLASTOBJCODE:
                    curval = pdflastobj;
                    break;
                case PDFLASTXFORMCODE:
                    curval = pdflastxform;
                    break;
                case PDFLASTXIMAGECODE:
                    curval = pdflastximage;
                    break;
                case PDFLASTXIMAGEPAGESCODE:
                    curval = pdflastximagepages;
                    break;
                case PDFLASTANNOTCODE:
                    curval = pdflastannot;
                    break;
                case PDFLASTXPOSCODE:
                    curval = pdflastxpos;
                    break;
                case PDFLASTYPOSCODE:
                    curval = pdflastypos;
                    break;
                case PDFRETVALCODE:
                    curval = pdfretval;
                    break;
                case PDFLASTXIMAGECOLORDEPTHCODE:
                    curval = pdflastximagecolordepth;
                    break;
                case ELAPSEDTIMECODE:
                    curval = getmicrointerval();
                    break;
                case RANDOMSEEDCODE:
                    curval = randomseed;
                    break;
                case PDFSHELLESCAPECODE: {
                    if (shellenabledp) {
                        if (restrictedshell)
                            curval = 2;
                        else
                            curval = 1;
                    } else
                        curval = 0;
                } break;
                case PDFLASTLINKCODE:
                    curval = pdflastlink;
                    break;
                /* comment:Cases for fetching an integer value */
                case ETEXVERSIONCODE:
                    curval = ETEXVERSION;
                    break;
                case CURRENTGROUPLEVELCODE:
                    curval = curlevel - LEVELONE;
                    break;
                case CURRENTGROUPTYPECODE:
                    curval = curgroup;
                    break;
                case CURRENTIFLEVELCODE: {
                    q = condptr;
                    curval = 0;
                    while (q != TEXNULL) {

                        incr(curval);
                        q = mem[q].hh.v.RH;
                    }
                } break;
                case CURRENTIFTYPECODE:
                    if (condptr == TEXNULL)
                        curval = 0;
                    else if (curif < UNLESSCODE)
                        curval = curif + 1;
                    else
                        curval = -(integer)(/* @d4981@ */ curif - 31);
                    break;
                case CURRENTIFBRANCHCODE:
                    if ((iflimit == ORCODE) || (iflimit == ELSECODE))
                        curval = 1;
                    else if (iflimit == FICODE)
                        curval = -1;
                    else
                        curval = 0;
                    break;
                case GLUESTRETCHORDERCODE:
                case GLUESHRINKORDERCODE: {
                    scannormalglue();
                    q = curval;
                    if (m == GLUESTRETCHORDERCODE)
                        curval = mem[q].hh.b0;
                    else
                        curval = mem[q].hh.b1;
                    deleteglueref(q);
                } break;
                }
                curvallevel = INTVAL;
            }
        } else {

            if (curchr == GLUEVAL)
                curval = membot;
            else
                curval = 0;
            tx = curlist.tailfield;
            if (!(tx >= himemmin)) {

                if ((mem[tx].hh.b0 == MATHNODE) &&
                    (mem[tx].hh.b1 == ENDMCODE)) {
                    r = curlist.headfield;
                    do {
                        q = r;
                        r = mem[q].hh.v.RH;
                    } while (!(r == tx));
                    tx = q;
                }
            }
            if (curchr == LASTNODETYPECODE) {
                curvallevel = INTVAL;
                if ((tx == curlist.headfield) || (curlist.modefield == 0))
                    curval = -1;
            } else
                curvallevel = curchr;
            if (!(tx >= himemmin) && (curlist.modefield != 0))
                switch (curchr) {
                case INTVAL:
                    if (mem[tx].hh.b0 == PENALTYNODE)
                        curval = mem[tx + 1].cint;
                    break;
                case DIMENVAL:
                    if (mem[tx].hh.b0 == KERNNODE)
                        curval = mem[tx + WIDTHOFFSET].cint;
                    break;
                case GLUEVAL:
                    if (mem[tx].hh.b0 == GLUENODE) {
                        curval = mem[tx + 1].hh.v.LH;
                        if (mem[tx].hh.b1 == MUGLUE)
                            curvallevel = MUVAL;
                    }
                    break;
                case LASTNODETYPECODE:
                    if (mem[tx].hh.b0 <= UNSETNODE)
                        curval = mem[tx].hh.b0 + 1;
                    else
                        curval = /* @d5006@ */ 15;
                    break;
                }
            else if ((curlist.modefield == VMODE) && (tx == curlist.headfield))
                switch (curchr) {
                case INTVAL:
                    curval = lastpenalty;
                    break;
                case DIMENVAL:
                    curval = lastkern;
                    break;
                case GLUEVAL:
                    if (lastglue != 2147483647L)
                        curval = lastglue;
                    break;
                case LASTNODETYPECODE:
                    curval = lastnodetype;
                    break;
                }
        }
        break;
    case IGNORESPACES:
        if (curchr ==
            1) /* comment:Reset |cur_tok| for unexpandable primitives, goto  */
        {
            gettoken();
            if (curcs < HASHBASE)
                curcs = primlookup(curcs - SINGLEBASE);
            else
                curcs = primlookup(hash[curcs].v.RH);
            if (curcs != UNDEFINEDPRIMITIVE) {
                curcmd = eqtb[PRIMEQTBBASE + curcs].hh.b0;
                curchr = eqtb[PRIMEQTBBASE + curcs].hh.v.RH;
                curcs = PRIMEQTBBASE + curcs;
                curtok = 4095 + curcs;
            } else {

                curcmd = RELAX;
                curchr = 0;
                curtok = /* @d5021@ */ 19616;
                curcs = FROZENRELAX;
            }
            goto labscansomethinginternal20restart;
        }
        break;
    default:
        /* comment:Complain that \.{\\the} can't do this; give zero r */ {

            {
                if (interaction == ERRORSTOPMODE)
                    ;
                if (filelineerrorstylep)
                    printfileline();
                else
                    printnl(/* str '! ' */ 264);
                print(/* str 'You can't use `' */ 786);
            }
            printcmdchr(curcmd, curchr);
            print(/* str '' after ' */ 787);
            printesc(/* str 'the' */ 617);
            {
                helpptr = 1;
                helpline[0] = /* str 'I'm forgetting what you said and using
                                 zero inste' */
                    785;
            }
            error();
            if (level != TOKVAL) {
                curval = 0;
                curvallevel = DIMENVAL;
            } else {

                curval = 0;
                curvallevel = INTVAL;
            }
        }
        break;
    }
    while (curvallevel >
           level) /* comment:Convert \(c)|cur_val| to a lower level */ {

        if (curvallevel == GLUEVAL)
            curval = mem[curval + WIDTHOFFSET].cint;
        else if (curvallevel == MUVAL)
            muerror();
        decr(curvallevel);
    }
    /* comment:Fix the reference count, if any, and negate |cur_v */
    if (negative) {

        if (curvallevel >= GLUEVAL) {
            curval = newspec(curval);
            /* comment:Negate all three glue components of |cur_val| */ {

                mem[curval + WIDTHOFFSET].cint =
                    -(integer)mem[curval + WIDTHOFFSET].cint;
                mem[curval + 2].cint = -(integer)mem[curval + 2].cint;
                mem[curval + 3].cint = -(integer)mem[curval + 3].cint;
            }
        } else
            curval = -(integer)curval;
    } else if ((curvallevel >= GLUEVAL) && (curvallevel <= MUVAL))
        incr(mem[curval].hh.v.RH);
}
void scanint(void) {
    scanint_regmem boolean negative;
    integer m;
    smallnumber d;
    boolean vacuous;
    boolean OKsofar;
    radix = 0;
    OKsofar = true;
    /* comment:Get the next non-blank non-sign token; set |negati */ negative =
        false;
    do {
        /* comment:Get the next non-blank non-call token */ do {
            getxtoken();
        } while (!(curcmd != SPACER));
        if (curtok == /* @d5051@ */ /* str '-' */ 3117) {
            negative = !negative;
            curtok = /* @d5053@ */ /* str '+' */ 3115;
        }
    } while (!(curtok != /* @d5055@ */ /* str '+' */ 3115));
labscanint20restart:
    if (curtok == ALPHATOKEN) /* comment:Scan an alphabetic
                                         character code into |cur_val| */
    {
        gettoken();
        if (curtok < 4095) {
            curval = curchr;
            if (curcmd <= RIGHTBRACE) {

                if (curcmd == RIGHTBRACE)
                    incr(alignstate);
                else
                    decr(alignstate);
            }
        } else if (curtok < /* @d5062@ */ 4352)
            curval = /* @d5063@ */ curtok - 4096;
        else
            curval = /* @d5064@ */ curtok - 4352;
        if (curval > 255) {
            {
                if (interaction == ERRORSTOPMODE)
                    ;
                if (filelineerrorstylep)
                    printfileline();
                else
                    printnl(/* str '! ' */ 264);
                print(/* str 'Improper alphabetic constant' */ 799);
            }
            {
                helpptr = 2;
                helpline[1] = /* str 'A one-character control sequence belongs
                                 after a ' */
                    800;
                helpline[0] =
                    /* str 'So I'm essentially inserting \0 here.' */ 801;
            }
            curval = /* str '0' */ 48;
            backerror();
        } else /* comment:Scan an optional space */ {

            getxtoken();
            if (curcmd != SPACER)
                backinput();
        }
    } else if (curtok ==
               /* @d5073@ */ 19620) /* comment:Reset |cur_tok| for
                                       unexpandable primitives, goto  */
    {
        gettoken();
        if (curcs < HASHBASE)
            curcs = primlookup(curcs - SINGLEBASE);
        else
            curcs = primlookup(hash[curcs].v.RH);
        if (curcs != UNDEFINEDPRIMITIVE) {
            curcmd = eqtb[PRIMEQTBBASE + curcs].hh.b0;
            curchr = eqtb[PRIMEQTBBASE + curcs].hh.v.RH;
            curcs = PRIMEQTBBASE + curcs;
            curtok = 4095 + curcs;
        } else {

            curcmd = RELAX;
            curchr = 0;
            curtok = /* @d5082@ */ 19616;
            curcs = FROZENRELAX;
        }
        goto labscanint20restart;
    } else if ((curcmd >= MININTERNAL) && (curcmd <= MAXINTERNAL))
        scansomethinginternal(INTVAL, false);
    else /* comment:Scan a numeric constant */ {

        radix = 10;
        m = 214748364L;
        if (curtok == OCTALTOKEN) {
            radix = 8;
            m = 268435456L;
            getxtoken();
        } else if (curtok == HEXTOKEN) {
            radix = 16;
            m = 134217728L;
            getxtoken();
        }
        vacuous = true;
        curval = 0;
        /* comment:Accumulate the constant until |cur_tok| is not a s */ while (
            true) {

            if ((curtok < ZEROTOKEN + radix) && (curtok >= ZEROTOKEN) &&
                (curtok <= /* @d5094@ */ 3129))
                d = curtok - ZEROTOKEN;
            else if (radix == 16) {

                if ((curtok <= /* @d5096@ */ 2886) && (curtok >= ATOKEN))
                    d = /* @d5098@ */ curtok - 2871;
                else if ((curtok <= /* @d5099@ */ 3142) &&
                         (curtok >= OTHERATOKEN))
                    d = /* @d5101@ */ curtok - 3127;
                else
                    goto labscanint30done;
            } else
                goto labscanint30done;
            vacuous = false;
            if ((curval >= m) && ((curval > m) || (d > 7) || (radix != 10))) {
                if (OKsofar) {
                    {
                        if (interaction == ERRORSTOPMODE)
                            ;
                        if (filelineerrorstylep)
                            printfileline();
                        else
                            printnl(/* str '! ' */ 264);
                        print(/* str 'Number too big' */ 802);
                    }
                    {
                        helpptr = 2;
                        helpline[1] = /* str 'I can only go up to
                                         2147483647='17777777777=""7FF' */
                            803;
                        helpline[0] = /* str 'so I'm using that number instead
                                         of yours.' */
                            804;
                    }
                    error();
                    curval = 2147483647L;
                    OKsofar = false;
                }
            } else
                curval = curval * radix + d;
            getxtoken();
        }
    labscanint30done:;
        if (vacuous) /* comment:Express astonishment that no number was here */
        {
            {
                if (interaction == ERRORSTOPMODE)
                    ;
                if (filelineerrorstylep)
                    printfileline();
                else
                    printnl(/* str '! ' */ 264);
                print(/* str 'Missing number, treated as zero' */ 751);
            }
            {
                helpptr = 3;
                helpline[2] =
                    /* str 'A number should have been here; I inserted `0'.' */
                    752;
                helpline[1] = /* str '(If you can't figure out why I needed to
                                 see a nu' */
                    753;
                helpline[0] = /* str 'look up `weird error' in the index to The
                                 TeXbook' */
                    754;
            }
            backerror();
        } else if (curcmd != SPACER)
            backinput();
    }
    if (negative)
        curval = -(integer)curval;
}
void zscandimen(boolean mu, boolean inf, boolean shortcut) {
    /* @d5118@ */ /* @d5119@ */ /* @d5120@ */ /* @d5121@ */ /* @d5122@ */
    scandimen_regmem boolean negative;
    integer f;
    /* comment:Local variables for dimension calculations */ integer num, denom;
    smallnumber k, kk;
    halfword p, q;
    scaled v;
    integer savecurval;
    f = 0;
    aritherror = false;
    curorder = NORMAL;
    negative = false;
    if (!shortcut) {
        /* comment:Get the next non-blank non-sign token; set |negati */
        negative = false;
        do {
            /* comment:Get the next non-blank non-call token */ do {
                getxtoken();
            } while (!(curcmd != SPACER));
            if (curtok == /* @d5130@ */ /* str '-' */ 3117) {
                negative = !negative;
                curtok = /* @d5132@ */ /* str '+' */ 3115;
            }
        } while (!(curtok != /* @d5134@ */ /* str '+' */ 3115));
        if ((curcmd >= MININTERNAL) &&
            (curcmd <= MAXINTERNAL)) /* comment:Fetch an internal dimension
                                             and |goto attach_sign| */
        {

            if (mu) {
                scansomethinginternal(MUVAL, false);
                /* comment:Coerce glue to a dimension */ if (curvallevel >=
                                                             GLUEVAL) {
                    v = mem[curval + WIDTHOFFSET].cint;
                    deleteglueref(curval);
                    curval = v;
                }
                if (curvallevel == MUVAL)
                    goto labscandimen89attach_sign;
                if (curvallevel != INTVAL)
                    muerror();
            } else {

                scansomethinginternal(DIMENVAL, false);
                if (curvallevel == DIMENVAL)
                    goto labscandimen89attach_sign;
            }
        } else {

            backinput();
            if (curtok == CONTINENTALPOINTTOKEN)
                curtok = POINTTOKEN;
            if (curtok != POINTTOKEN)
                scanint();
            else {

                radix = 10;
                curval = 0;
            }
            if (curtok == CONTINENTALPOINTTOKEN)
                curtok = POINTTOKEN;
            if ((radix == 10) &&
                (curtok == POINTTOKEN)) /* comment:Scan decimal fraction */
            {
                k = 0;
                p = TEXNULL;
                gettoken();
                while (true) {

                    getxtoken();
                    if ((curtok > /* @d5156@ */ 3129) || (curtok < ZEROTOKEN))
                        goto labscandimen31done1;
                    if (k < 17) {
                        q = getavail();
                        mem[q].hh.v.RH = p;
                        mem[q].hh.v.LH = curtok - ZEROTOKEN;
                        p = q;
                        incr(k);
                    }
                }
            labscandimen31done1 : {
                register integer for_end;
                kk = k;
                for_end = 1;
                if (kk >= for_end)
                    do {
                        dig[kk - 1] = mem[p].hh.v.LH;
                        q = p;
                        p = mem[p].hh.v.RH;
                        {
                            mem[q].hh.v.RH = avail;
                            avail = q;
                            mem[q].hh.me = 0;
                            ;
#ifdef STAT
                            decr(dynused);
#endif /* STAT */
                        }
                    } while (kk-- > for_end);
            }
                f = rounddecimals(k);
                if (curcmd != SPACER)
                    backinput();
            }
        }
    }
    if (curval < 0) {
        negative = !negative;
        curval = -(integer)curval;
    }
    /* comment:Scan units and set |cur_val| to $x\cdot(|cur_val|+ */
    if (inf) /* comment:Scan for \(f)\.{fil} units; |goto attach_fraction| */ {

        if (scankeyword(/* str 'fil' */ 316)) {
            curorder = FIL;
            while (scankeyword(/* str 'l' */ 108)) {

                if (curorder == FILLL) {
                    {
                        if (interaction == ERRORSTOPMODE)
                            ;
                        if (filelineerrorstylep)
                            printfileline();
                        else
                            printnl(/* str '! ' */ 264);
                        print(/* str 'Illegal unit of measure (' */ 806);
                    }
                    print(/* str 'replaced by filll)' */ 807);
                    {
                        helpptr = 1;
                        helpline[0] =
                            /* str 'I dddon't go any higher than filll.' */ 808;
                    }
                    error();
                } else
                    incr(curorder);
            }
            goto labscandimen88attach_fraction;
        }
    }
    /* comment:Scan for \(u)units that are internal dimensions; | */
    savecurval = curval;
    /* comment:Get the next non-blank non-call token */ do {
        getxtoken();
    } while (!(curcmd != SPACER));
    if ((curcmd < MININTERNAL) || (curcmd > MAXINTERNAL))
        backinput();
    else {

        if (mu) {
            scansomethinginternal(MUVAL, false);
            /* comment:Coerce glue to a dimension */ if (curvallevel >=
                                                         GLUEVAL) {
                v = mem[curval + WIDTHOFFSET].cint;
                deleteglueref(curval);
                curval = v;
            }
            if (curvallevel != MUVAL)
                muerror();
        } else
            scansomethinginternal(DIMENVAL, false);
        v = curval;
        goto labscandimen40found;
    }
    if (mu)
        goto labscandimen45not_found;
    if (scankeyword(/* str 'em' */ 809))
        v = (/* comment:The em width for |cur_font| */ fontinfo
                 [QUADCODE + parambase[eqtb[CURFONTLOC].hh.v.RH]]
                     .cint);
    else if (scankeyword(/* str 'ex' */ 810))
        v = (/* comment:The x-height for |cur_font| */ fontinfo
                 [XHEIGHTCODE + parambase[eqtb[CURFONTLOC].hh.v.RH]]
                     .cint);
    else if (scankeyword(/* str 'px' */ 811))
        v = eqtb[DIMENBASE + PDFPXDIMENCODE].cint;
    else
        goto labscandimen45not_found;
    /* comment:Scan an optional space */ {

        getxtoken();
        if (curcmd != SPACER)
            backinput();
    }
labscandimen40found:
    curval = multandadd(savecurval, v, xnoverd(v, f, 65536L), 1073741823L);
    goto labscandimen89attach_sign;
labscandimen45not_found:;
    if (mu) /* comment:Scan for \(m)\.{mu} units and |goto attach_fractio */ {

        if (scankeyword(/* str 'mu' */ 344))
            goto labscandimen88attach_fraction;
        else {

            {
                if (interaction == ERRORSTOPMODE)
                    ;
                if (filelineerrorstylep)
                    printfileline();
                else
                    printnl(/* str '! ' */ 264);
                print(/* str 'Illegal unit of measure (' */ 806);
            }
            print(/* str 'mu inserted)' */ 812);
            {
                helpptr = 4;
                helpline[3] =
                    /* str 'The unit of measurement in math glue must be mu.' */
                    813;
                helpline[2] = /* str 'To recover gracefully from this error,
                                 it's best ' */
                    814;
                helpline[1] = /* str 'delete the erroneous units; e.g., type `2'
                                 to del' */
                    815;
                helpline[0] =
                    /* str 'two letters. (See Chapter 27 of The TeXbook.)' */
                    816;
            }
            error();
            goto labscandimen88attach_fraction;
        }
    }
    if (scankeyword(/* str 'true' */ 805)) /* comment:Adjust \(f)for the
                                              magnification ratio */
    {
        preparemag();
        if (eqtb[INTBASE + MAGCODE].cint != 1000) {
            curval = xnoverd(curval, 1000, eqtb[INTBASE + MAGCODE].cint);
            f = (1000 * f + 65536L * texremainder) /
                eqtb[INTBASE + MAGCODE].cint;
            curval = curval + (f / 65536L);
            f = f % 65536L;
        }
    }
    if (scankeyword(/* str 'pt' */ 312))
        goto labscandimen88attach_fraction;
    /* comment:Scan for \(a)all other units and adjust |cur_val|  */
    if (scankeyword(/* str 'in' */ 817)) {
        num = 7227;
        denom = 100;
    } else if (scankeyword(/* str 'pc' */ 818)) {
        num = 12;
        denom = 1;
    } else if (scankeyword(/* str 'cm' */ 819)) {
        num = 7227;
        denom = 254;
    } else if (scankeyword(/* str 'mm' */ 820)) {
        num = 7227;
        denom = 2540;
    } else if (scankeyword(/* str 'bp' */ 821)) {
        num = 7227;
        denom = 7200;
    } else if (scankeyword(/* str 'dd' */ 822)) {
        num = 1238;
        denom = 1157;
    } else if (scankeyword(/* str 'cc' */ 823)) {
        num = 14856;
        denom = 1157;
    } else if (scankeyword(/* str 'nd' */ 824)) {
        num = 685;
        denom = 642;
    } else if (scankeyword(/* str 'nc' */ 825)) {
        num = 1370;
        denom = 107;
    } else if (scankeyword(/* str 'sp' */ 826))
        goto labscandimen30done;
    else /* comment:Complain about unknown unit and |goto done2| */ {

        {
            if (interaction == ERRORSTOPMODE)
                ;
            if (filelineerrorstylep)
                printfileline();
            else
                printnl(/* str '! ' */ 264);
            print(/* str 'Illegal unit of measure (' */ 806);
        }
        print(/* str 'pt inserted)' */ 827);
        {
            helpptr = 6;
            helpline[5] =
                /* str 'Dimensions can be in units of em, ex, in, pt, pc,' */
                828;
            helpline[4] =
                /* str 'cm, mm, dd, cc, nd, nc, bp, or sp; but yours is a' */
                829;
            helpline[3] =
                /* str 'I'll assume that you meant to say pt, for printer' */
                830;
            helpline[2] =
                /* str 'To recover gracefully from this error, it's best ' */
                814;
            helpline[1] =
                /* str 'delete the erroneous units; e.g., type `2' to del' */
                815;
            helpline[0] =
                /* str 'two letters. (See Chapter 27 of The TeXbook.)' */ 816;
        }
        error();
        goto labscandimen32done2;
    }
    curval = xnoverd(curval, num, denom);
    f = (num * f + 65536L * texremainder) / denom;
    curval = curval + (f / 65536L);
    f = f % 65536L;
labscandimen32done2:;
labscandimen88attach_fraction:
    if (curval >= 16384)
        aritherror = true;
    else
        curval = curval * 65536L + f;
labscandimen30done:;
    /* comment:Scan an optional space */ {

        getxtoken();
        if (curcmd != SPACER)
            backinput();
    }
labscandimen89attach_sign:
    if (aritherror ||
        (abs(curval) >= 1073741824L)) /* comment:Report that this
                                         dimension is out of range */
    {
        {
            if (interaction == ERRORSTOPMODE)
                ;
            if (filelineerrorstylep)
                printfileline();
            else
                printnl(/* str '! ' */ 264);
            print(/* str 'Dimension too large' */ 831);
        }
        {
            helpptr = 2;
            helpline[1] =
                /* str 'I can't work with sizes bigger than about 19 feet' */
                832;
            helpline[0] =
                /* str 'Continue and I'll use the largest value I can.' */ 833;
        }
        error();
        curval = 1073741823L;
        aritherror = false;
    }
    if (negative)
        curval = -(integer)curval;
}
void zscanglue(smallnumber level) {
    scanglue_regmem boolean negative;
    halfword q;
    boolean mu;
    mu = (level == MUVAL);
    /* comment:Get the next non-blank non-sign token; set |negati */ negative =
        false;
    do {
        /* comment:Get the next non-blank non-call token */ do {
            getxtoken();
        } while (!(curcmd != SPACER));
        if (curtok == /* @d5267@ */ /* str '-' */ 3117) {
            negative = !negative;
            curtok = /* @d5269@ */ /* str '+' */ 3115;
        }
    } while (!(curtok != /* @d5271@ */ /* str '+' */ 3115));
    if ((curcmd >= MININTERNAL) && (curcmd <= MAXINTERNAL)) {
        scansomethinginternal(level, negative);
        if (curvallevel >= GLUEVAL) {
            if (curvallevel != level)
                muerror();
            return;
        }
        if (curvallevel == INTVAL)
            scandimen(mu, false, true);
        else if (level == MUVAL)
            muerror();
    } else {

        backinput();
        scandimen(mu, false, false);
        if (negative)
            curval = -(integer)curval;
    }
    /* comment:Create a new glue specification whose width is |cu */ q =
        newspec(membot);
    mem[q + WIDTHOFFSET].cint = curval;
    if (scankeyword(/* str 'plus' */ 834)) {
        scandimen(mu, true, false);
        mem[q + 2].cint = curval;
        mem[q].hh.b0 = curorder;
    }
    if (scankeyword(/* str 'minus' */ 835)) {
        scandimen(mu, true, false);
        mem[q + 3].cint = curval;
        mem[q].hh.b1 = curorder;
    }
    curval = q;
}
/* comment:Declare procedures needed for expressions */
/* comment:Declare subprocedures for |scan_expr| */ integer
zaddorsub(integer x, integer y, integer maxanswer, boolean negative) {
    register integer Result;
    addorsub_regmem integer a;
    if (negative)
        y = -(integer)y;
    if (x >= 0) {

        if (y <= maxanswer - x)
            a = x + y;
        else {

            aritherror = true;
            a = 0;
        }
    } else if (y >= -(integer)maxanswer - x)
        a = x + y;
    else {

        aritherror = true;
        a = 0;
    }
    Result = a;
    return Result;
}
integer zquotient(integer n, integer d) {
    register integer Result;
    quotient_regmem boolean negative;
    integer a;
    if (d == 0) {
        aritherror = true;
        a = 0;
    } else {

        if (d > 0)
            negative = false;
        else {

            d = -(integer)d;
            negative = true;
        }
        if (n < 0) {
            n = -(integer)n;
            negative = !negative;
        }
        a = n / d;
        n = n - a * d;
        d = n - d;
        if (d + n >= 0)
            incr(a);
        if (negative)
            a = -(integer)a;
    }
    Result = a;
    return Result;
}
integer zfract(integer x, integer n, integer d, integer maxanswer) {
    /* @d5286@ */  integer
        Result;
    fract_regmem boolean negative;
    integer a;
    integer f;
    integer h;
    integer r;
    integer t;
    if (d == 0)
        goto labfract88too_big;
    a = 0;
    if (d > 0)
        negative = false;
    else {

        d = -(integer)d;
        negative = true;
    }
    if (x < 0) {
        x = -(integer)x;
        negative = !negative;
    } else if (x == 0)
        goto labfract30done;
    if (n < 0) {
        n = -(integer)n;
        negative = !negative;
    }
    t = n / d;
    if (t > maxanswer / x)
        goto labfract88too_big;
    a = t * x;
    n = n - t * d;
    if (n == 0)
        goto labfract40found;
    t = x / d;
    if (t > (maxanswer - a) / n)
        goto labfract88too_big;
    a = a + t * n;
    x = x - t * d;
    if (x == 0)
        goto labfract40found;
    if (x < n) {
        t = x;
        x = n;
        n = t;
    }
    /* comment:Compute \(f)$f=\lfloor xnd+{1\over2}\rfloor$ */ f = 0;
    r = (d / 2) - d;
    h = -(integer)r;
    while (true) {

        if (odd(n)) {
            r = r + x;
            if (r >= 0) {
                r = r - d;
                incr(f);
            }
        }
        n = n / 2;
        if (n == 0)
            goto labfract41found1;
        if (x < h)
            x = x + x;
        else {

            t = x - d;
            x = t + x;
            f = f + n;
            if (x < n) {
                if (x == 0)
                    goto labfract41found1;
                t = x;
                x = n;
                n = t;
            }
        }
    }
labfract41found1:
    if (f > (maxanswer - a))
        goto labfract88too_big;
    a = a + f;
labfract40found:
    if (negative)
        a = -(integer)a;
    goto labfract30done;
labfract88too_big : {

    aritherror = true;
    a = 0;
}
labfract30done:
    Result = a;
    return Result;
}
void scanexpr(void) {
    scanexpr_regmem boolean a, b;
    smallnumber l;
    smallnumber r;
    smallnumber s;
    smallnumber o;
    integer e;
    integer t;
    integer f;
    integer n;
    halfword p;
    halfword q;
    l = curvallevel;
    a = aritherror;
    b = false;
    p = TEXNULL;
/* comment:Scan and evaluate an expression |e| of type |l| */
labscanexpr20restart:
    r = EXPRNONE;
    e = 0;
    s = EXPRNONE;
    t = 0;
    n = 0;
labscanexpr22continue:
    if (s == EXPRNONE)
        o = l;
    else
        o = INTVAL;
    /* comment:Scan a factor |f| of type |o| or start a subexpres */
    /* comment:Get the next non-blank non-call token */ do {
        getxtoken();
    } while (!(curcmd != SPACER));
    if (curtok ==
        /* @d5318@ */ /* str '(' */ 3112) /* comment:Push the expression stack
                                             and |goto restart| */
    {
        q = getnode(EXPRNODESIZE);
        mem[q].hh.v.RH = p;
        mem[q].hh.b0 = l;
        mem[q].hh.b1 = 4 * s + r;
        mem[q + 1].cint = e;
        mem[q + 2].cint = t;
        mem[q + 3].cint = n;
        p = q;
        l = o;
        goto labscanexpr20restart;
    }
    backinput();
    if (o == INTVAL)
        scanint();
    else if (o == DIMENVAL)
        scandimen(false, false, false);
    else if (o == GLUEVAL)
        scannormalglue();
    else
        scanmuglue();
    f = curval;
labscanexpr40found: /* comment:Scan the next operator and set |o| */
    /* comment:Get the next non-blank non-call token */ do {
        getxtoken();
    } while (!(curcmd != SPACER));
    if (curtok == /* @d5330@ */ /* str '+' */ 3115)
        o = EXPRADD;
    else if (curtok == /* @d5333@ */ /* str '-' */ 3117)
        o = EXPRSUB;
    else if (curtok == /* @d5336@ */ /* str '' */ 3114)
        o = EXPRMULT;
    else if (curtok == /* @d5339@ */ /* str '' */ 3119)
        o = EXPRDIV;
    else {

        o = EXPRNONE;
        if (p == TEXNULL) {
            if (curcmd != RELAX)
                backinput();
        } else if (curtok != /* @d5344@ */ /* str ')' */ 3113) {
            {
                if (interaction == ERRORSTOPMODE)
                    ;
                if (filelineerrorstylep)
                    printfileline();
                else
                    printnl(/* str '! ' */ 264);
                print(/* str 'Missing ) inserted for expression' */ 2052);
            }
            {
                helpptr = 1;
                helpline[0] =
                    /* str 'I was expecting to see `+', `-', `', `', or `)'' */
                    2053;
            }
            backerror();
        }
    }
    aritherror = b;
    /* comment:Make sure that |f| is in the proper range */
    if ((l == INTVAL) || (s > EXPRSUB)) {
        if ((f > 2147483647L) || (f < TEXNULL)) {
            aritherror = true;
            f = 0;
        }
    } else if (l == DIMENVAL) {
        if (abs(f) > 1073741823L) {
            aritherror = true;
            f = 0;
        }
    } else {

        if ((abs(mem[f + WIDTHOFFSET].cint) > 1073741823L) ||
            (abs(mem[f + 2].cint) > 1073741823L) ||
            (abs(mem[f + 3].cint) > 1073741823L)) {
            aritherror = true;
            deleteglueref(f);
            f = newspec(membot);
        }
    }
    switch (s) {
    /* comment:Cases for evaluation of the current term */ case EXPRNONE:
        if ((l >= GLUEVAL) && (o != EXPRNONE)) {
            t = newspec(f);
            deleteglueref(f);
            if (mem[t + 2].cint == 0)
                mem[t].hh.b0 = NORMAL;
            if (mem[t + 3].cint == 0)
                mem[t].hh.b1 = NORMAL;
        } else
            t = f;
        break;
    case EXPRMULT:
        if (o == EXPRDIV) {
            n = f;
            o = EXPRSCALE;
        } else if (l == INTVAL)
            t = multandadd(t, f, 0, 2147483647L);
        else if (l == DIMENVAL)
            t = multandadd(t, f, 0, 1073741823L);
        else {

            mem[t + WIDTHOFFSET].cint =
                multandadd(mem[t + WIDTHOFFSET].cint, f, 0, 1073741823L);
            mem[t + 2].cint = multandadd(mem[t + 2].cint, f, 0, 1073741823L);
            mem[t + 3].cint = multandadd(mem[t + 3].cint, f, 0, 1073741823L);
        }
        break;
    case EXPRDIV:
        if (l < GLUEVAL)
            t = quotient(t, f);
        else {

            mem[t + WIDTHOFFSET].cint = quotient(mem[t + WIDTHOFFSET].cint, f);
            mem[t + 2].cint = quotient(mem[t + 2].cint, f);
            mem[t + 3].cint = quotient(mem[t + 3].cint, f);
        }
        break;
    case EXPRSCALE:
        if (l == INTVAL)
            t = fract(t, n, f, 2147483647L);
        else if (l == DIMENVAL)
            t = fract(t, n, f, 1073741823L);
        else {

            mem[t + WIDTHOFFSET].cint =
                fract(mem[t + WIDTHOFFSET].cint, n, f, 1073741823L);
            mem[t + 2].cint = fract(mem[t + 2].cint, n, f, 1073741823L);
            mem[t + 3].cint = fract(mem[t + 3].cint, n, f, 1073741823L);
        }
        break;
    }
    if (o > EXPRSUB)
        s = o;
    else /* comment:Evaluate the current expression */ {

        s = EXPRNONE;
        if (r == EXPRNONE)
            e = t;
        else if (l == INTVAL)
            e = addorsub(e, t, 2147483647L, r == EXPRSUB);
        else if (l == DIMENVAL)
            e = addorsub(e, t, 1073741823L, r == EXPRSUB);
        else /* comment:Compute the sum or difference of two glue specs */ {

            mem[e + WIDTHOFFSET].cint =
                addorsub(mem[e + WIDTHOFFSET].cint, mem[t + WIDTHOFFSET].cint,
                         1073741823L, r == EXPRSUB);
            if (mem[e].hh.b0 == mem[t].hh.b0)
                mem[e + 2].cint = addorsub(mem[e + 2].cint, mem[t + 2].cint,
                                           1073741823L, r == EXPRSUB);
            else if ((mem[e].hh.b0 < mem[t].hh.b0) && (mem[t + 2].cint != 0)) {
                mem[e + 2].cint = mem[t + 2].cint;
                mem[e].hh.b0 = mem[t].hh.b0;
            }
            if (mem[e].hh.b1 == mem[t].hh.b1)
                mem[e + 3].cint = addorsub(mem[e + 3].cint, mem[t + 3].cint,
                                           1073741823L, r == EXPRSUB);
            else if ((mem[e].hh.b1 < mem[t].hh.b1) && (mem[t + 3].cint != 0)) {
                mem[e + 3].cint = mem[t + 3].cint;
                mem[e].hh.b1 = mem[t].hh.b1;
            }
            deleteglueref(t);
            if (mem[e + 2].cint == 0)
                mem[e].hh.b0 = NORMAL;
            if (mem[e + 3].cint == 0)
                mem[e].hh.b1 = NORMAL;
        }
        r = o;
    }
    b = aritherror;
    if (o != EXPRNONE)
        goto labscanexpr22continue;
    if (p != TEXNULL) /* comment:Pop the expression stack and |goto found| */
    {
        f = e;
        q = p;
        e = mem[q + 1].cint;
        t = mem[q + 2].cint;
        n = mem[q + 3].cint;
        s = mem[q].hh.b1 / 4;
        r = mem[q].hh.b1 % 4;
        l = mem[q].hh.b0;
        p = mem[q].hh.v.RH;
        freenode(q, EXPRNODESIZE);
        goto labscanexpr40found;
    }
    if (b) {
        {
            if (interaction == ERRORSTOPMODE)
                ;
            if (filelineerrorstylep)
                printfileline();
            else
                printnl(/* str '! ' */ 264);
            print(/* str 'Arithmetic overflow' */ 1641);
        }
        {
            helpptr = 2;
            helpline[1] = /* str 'I can't evaluate this expression,' */ 2051;
            helpline[0] = /* str 'since the result is out of range.' */ 1643;
        }
        error();
        if (l >= GLUEVAL) {
            deleteglueref(e);
            e = membot;
            incr(mem[e].hh.v.RH);
        } else
            e = 0;
    }
    aritherror = a;
    curval = e;
    curvallevel = l;
}
void scannormalglue(void) { scannormalglue_regmem scanglue(GLUEVAL); }
void scanmuglue(void) { scanmuglue_regmem scanglue(MUVAL); }
halfword scanrulespec(void) {
    register halfword Result;
    scanrulespec_regmem halfword q;
    q = newrule();
    if (curcmd == VRULE)
        mem[q + WIDTHOFFSET].cint = DEFAULTRULE;
    else {

        mem[q + HEIGHTOFFSET].cint = DEFAULTRULE;
        mem[q + DEPTHOFFSET].cint = 0;
    }
labscanrulespec21reswitch:
    if (scankeyword(/* str 'width' */ 836)) {
        scandimen(false, false, false);
        mem[q + WIDTHOFFSET].cint = curval;
        goto labscanrulespec21reswitch;
    }
    if (scankeyword(/* str 'height' */ 837)) {
        scandimen(false, false, false);
        mem[q + HEIGHTOFFSET].cint = curval;
        goto labscanrulespec21reswitch;
    }
    if (scankeyword(/* str 'depth' */ 838)) {
        scandimen(false, false, false);
        mem[q + DEPTHOFFSET].cint = curval;
        goto labscanrulespec21reswitch;
    }
    Result = q;
    return Result;
}
/* comment:Declare \eTeX\ procedures for token lists */ void
scangeneraltext(void) {
    scangeneraltext_regmem
        unsigned char s;
    halfword w;
    halfword d;
    halfword p;
    halfword q;
    halfword unbalance;
    s = scannerstatus;
    w = warningindex;
    d = defref;
    scannerstatus = ABSORBING;
    warningindex = curcs;
    defref = getavail();
    mem[defref].hh.v.LH = TEXNULL;
    p = defref;
    scanleftbrace();
    unbalance = 1;
    while (true) {

        gettoken();
        if (curtok < RIGHTBRACELIMIT) {

            if (curcmd < RIGHTBRACE)
                incr(unbalance);
            else {

                decr(unbalance);
                if (unbalance == 0)
                    goto labscangeneraltext40found;
            }
        }
        {
            q = getavail();
            mem[p].hh.v.RH = q;
            mem[q].hh.v.LH = curtok;
            p = q;
        }
    }
labscangeneraltext40found:
    q = mem[defref].hh.v.RH;
    {
        mem[defref].hh.v.RH = avail;
        avail = defref;
        mem[defref].hh.me = 0;
        ;
#ifdef STAT
        decr(dynused);
#endif /* STAT */
    }
    if (q == TEXNULL)
        curval = memtop - 3;
    else
        curval = p;
    mem[memtop - 3].hh.v.RH = q;
    scannerstatus = s;
    warningindex = w;
    defref = d;
}
void pseudostart(void) {
    pseudostart_regmem
        unsigned char oldsetting;
    strnumber s;
    poolpointer l, m;
    halfword p, q, r;
    fourquarters w;
    integer nl, sz;
    scangeneraltext();
    oldsetting = selector;
    selector = NEWSTRING;
    tokenshow(memtop - 3);
    selector = oldsetting;
    flushlist(mem[memtop - 3].hh.v.RH);
    {
        if (poolptr + 1 > poolsize)
            overflow(/* str 'pool size' */ 259, poolsize - initpoolptr);
    }
    s = makestring();
    /* comment:Convert string |s| into a new pseudo file */ strpool[poolptr] =
        /* str ' ' */ 32;
    l = strstart[s];
    nl = eqtb[INTBASE + NEWLINECHARCODE].cint;
    p = getavail();
    q = p;
    while (l < poolptr) {

        m = l;
        while ((l < poolptr) && (strpool[l] != nl))
            incr(l);
        sz = (l - m + 7) / 4;
        if (sz == 1)
            sz = 2;
        r = getnode(sz);
        mem[q].hh.v.RH = r;
        q = r;
        mem[q].hh.v.LH = sz;
        while (sz > 2) {

            decr(sz);
            incr(r);
            w.b0 = strpool[m];
            w.b1 = strpool[m + 1];
            w.b2 = strpool[m + 2];
            w.b3 = strpool[m + 3];
            mem[r].qqqq = w;
            m = m + 4;
        }
        w.b0 = /* str ' ' */ 32;
        w.b1 = /* str ' ' */ 32;
        w.b2 = /* str ' ' */ 32;
        w.b3 = /* str ' ' */ 32;
        if (l > m) {
            w.b0 = strpool[m];
            if (l > m + 1) {
                w.b1 = strpool[m + 1];
                if (l > m + 2) {
                    w.b2 = strpool[m + 2];
                    if (l > m + 3)
                        w.b3 = strpool[m + 3];
                }
            }
        }
        mem[r + 1].qqqq = w;
        if (strpool[l] == nl)
            incr(l);
    }
    mem[p].hh.v.LH = mem[p].hh.v.RH;
    mem[p].hh.v.RH = pseudofiles;
    pseudofiles = p;
    {
        decr(strptr);
        poolptr = strstart[strptr];
    }
    /* comment:Initiate input from new pseudo file */ beginfilereading();
    line = 0;
    curinput.limitfield = curinput.startfield;
    curinput.locfield = curinput.limitfield + 1;
    if (eqtb[INTBASE + TRACINGSCANTOKENSCODE].cint > 0) {
        if (termoffset > maxprintline - 3)
            println();
        else if ((termoffset > 0) || (fileoffset > 0))
            printchar(/* str ' ' */ 32);
        curinput.namefield = 19;
        print(/* str '( ' */ 2034);
        incr(openparens);
        fflush(stdout);
    } else
        curinput.namefield = 18;
}
halfword zstrtoks(poolpointer b) {
    register halfword Result;
    strtoks_regmem halfword p;
    halfword q;
    halfword t;
    poolpointer k;
    {
        if (poolptr + 1 > poolsize)
            overflow(/* str 'pool size' */ 259, poolsize - initpoolptr);
    }
    p = memtop - 3;
    mem[p].hh.v.RH = TEXNULL;
    k = b;
    while (k < poolptr) {

        t = strpool[k];
        if (t == /* str ' ' */ 32)
            t = SPACETOKEN;
        else
            t = OTHERTOKEN + t;
        {
            {
                q = avail;
                if (q == TEXNULL)
                    q = getavail();
                else {

                    avail = mem[q].hh.v.RH;
                    mem[q].hh.v.RH = TEXNULL;
                    mem[q].hh.me = curchrsig;
                    ;
#ifdef STAT
                    incr(dynused);
#endif /* STAT */
                }
            }
            mem[p].hh.v.RH = q;
            mem[q].hh.v.LH = t;
            p = q;
        }
        incr(k);
    }
    poolptr = b;
    Result = p;
    return Result;
}
halfword thetoks(void) {
    register halfword Result;
    thetoks_regmem
        unsigned char oldsetting;
    halfword p, q, r;
    poolpointer b;
    smallnumber c;
    /* comment:Handle \.{\\unexpanded} or \.{\\detokenize} and |r */
    if (odd(curchr)) {
        c = curchr;
        scangeneraltext();
        if (c == 1)
            Result = curval;
        else {

            oldsetting = selector;
            selector = NEWSTRING;
            b = poolptr;
            p = getavail();
            mem[p].hh.v.RH = mem[memtop - 3].hh.v.RH;
            tokenshow(p);
            flushlist(p);
            selector = oldsetting;
            Result = strtoks(b);
        }
        return Result;
    }
    getxtoken();
    scansomethinginternal(TOKVAL, false);
    if (curvallevel >= IDENTVAL) /* comment:Copy the token list */
    {
        p = memtop - 3;
        mem[p].hh.v.RH = TEXNULL;
        if (curvallevel == IDENTVAL) {
            q = getavail();
            mem[p].hh.v.RH = q;
            mem[q].hh.v.LH = 4095 + curval;
            p = q;
        } else if (curval != TEXNULL) {
            r = mem[curval].hh.v.RH;
            while (r != TEXNULL) {

                {
                    {
                        q = avail;
                        if (q == TEXNULL)
                            q = getavail();
                        else {

                            avail = mem[q].hh.v.RH;
                            mem[q].hh.v.RH = TEXNULL;
                            mem[q].hh.me = curchrsig;
                            ;
#ifdef STAT
                            incr(dynused);
#endif /* STAT */
                        }
                    }
                    mem[p].hh.v.RH = q;
                    mem[q].hh.v.LH = mem[r].hh.v.LH;
                    p = q;
                }
                mem[p].hh.me = mem[r].hh.me;
                r = mem[r].hh.v.RH;
            }
        }
        Result = p;
    } else {

        oldsetting = selector;
        selector = NEWSTRING;
        b = poolptr;
        switch (curvallevel) {
        case INTVAL:
            printint(curval);
            break;
        case DIMENVAL: {
            printscaled(curval);
            print(/* str 'pt' */ 312);
        } break;
        case GLUEVAL: {
            printspec(curval, /* str 'pt' */ 312);
            deleteglueref(curval);
        } break;
        case MUVAL: {
            printspec(curval, /* str 'mu' */ 344);
            deleteglueref(curval);
        } break;
        }
        selector = oldsetting;
        Result = strtoks(b);
    }
    return Result;
}
void insthetoks(void) {
    insthetoks_regmem mem[memtop - 12].hh.v.RH = thetoks();
    begintokenlist(mem[memtop - 3].hh.v.RH, INSERTED);
}
void convtoks(void) {
    convtoks_regmem
        unsigned char oldsetting;
    halfword p, q;
    unsigned char c;
    smallnumber savescannerstatus;
    halfword savedefref;
    halfword savewarningindex;
    boolean bool;
    integer i;
    integer j;
    poolpointer b;
    strnumber s;
    strnumber t;
    strnumber u;
    c = curchr;
    u = 0;
    /* comment:Scan the argument for command |c| */ switch (c) {
    case NUMBERCODE:
    case ROMANNUMERALCODE:
        scanint();
        break;
    case STRINGCODE:
    case MEANINGCODE: {
        savescannerstatus = scannerstatus;
        scannerstatus = NORMAL;
        gettoken();
        scannerstatus = savescannerstatus;
    } break;
    case FONTNAMECODE:
        scanfontident();
        break;
    case ETEXREVISIONCODE:;
        break;
    case EXPANDEDCODE: {
        savescannerstatus = scannerstatus;
        savewarningindex = warningindex;
        savedefref = defref;
        if (strstart[strptr] < poolptr)
            u = makestring();
        scanpdfexttoks();
        warningindex = savewarningindex;
        scannerstatus = savescannerstatus;
        begintokenlist(mem[defref].hh.v.RH, INSERTED);
        defref = savedefref;
        if (u != 0) {
            decr(strptr);
            u = 0;
        }
        return;
    } break;
    case PDFTEXREVISIONCODE:;
        break;
    case PDFTEXBANNERCODE:;
        break;
    case PDFFONTNAMECODE:
    case PDFFONTOBJNUMCODE:
    case PDFFONTSIZECODE: {
        scanfontident();
        if (curval == FONTBASE)
            pdferror(/* str 'font' */ 595,
                     /* str 'invalid font identifier' */ 873);
        if (c != PDFFONTSIZECODE) {
            pdfcheckvfcurval();
            if (!fontused[curval])
                pdfinitfontcurval();
        }
    } break;
    case PDFPAGEREFCODE: {
        scanint();
        if (curval <= 0)
            pdferror(/* str 'pageref' */ 874,
                     /* str 'invalid page number' */ 875);
    } break;
    case LEFTMARGINKERNCODE:
    case RIGHTMARGINKERNCODE: {
        scanregisternum();
        if (curval < 256)
            p = eqtb[BOXBASE + curval].hh.v.RH;
        else {

            findsaelement(4, curval, false);
            if (curptr == TEXNULL)
                p = TEXNULL;
            else
                p = mem[curptr + 1].hh.v.RH;
        }
        if ((p == TEXNULL) || (mem[p].hh.b0 != HLISTNODE))
            pdferror(/* str 'marginkern' */ 876,
                     /* str 'a non-empty hbox expected' */ 877);
    } break;
    case PDFXFORMNAMECODE: {
        scanint();
        pdfcheckobj(7, curval);
    } break;
    case PDFESCAPESTRINGCODE: {
        savescannerstatus = scannerstatus;
        savewarningindex = warningindex;
        savedefref = defref;
        if (strstart[strptr] < poolptr)
            u = makestring();
        scanpdfexttoks();
        s = tokenstostring(defref);
        deletetokenref(defref);
        defref = savedefref;
        warningindex = savewarningindex;
        scannerstatus = savescannerstatus;
        b = poolptr;
        escapestring(strstart[s]);
        mem[memtop - 12].hh.v.RH = strtoks(b);
        flushstr(s);
        begintokenlist(mem[memtop - 3].hh.v.RH, INSERTED);
        if (u != 0) {
            decr(strptr);
            u = 0;
        }
        return;
    } break;
    case PDFESCAPENAMECODE: {
        savescannerstatus = scannerstatus;
        savewarningindex = warningindex;
        savedefref = defref;
        if (strstart[strptr] < poolptr)
            u = makestring();
        scanpdfexttoks();
        s = tokenstostring(defref);
        deletetokenref(defref);
        defref = savedefref;
        warningindex = savewarningindex;
        scannerstatus = savescannerstatus;
        b = poolptr;
        escapename(strstart[s]);
        mem[memtop - 12].hh.v.RH = strtoks(b);
        flushstr(s);
        begintokenlist(mem[memtop - 3].hh.v.RH, INSERTED);
        if (u != 0) {
            decr(strptr);
            u = 0;
        }
        return;
    } break;
    case PDFESCAPEHEXCODE: {
        savescannerstatus = scannerstatus;
        savewarningindex = warningindex;
        savedefref = defref;
        if (strstart[strptr] < poolptr)
            u = makestring();
        scanpdfexttoks();
        s = tokenstostring(defref);
        deletetokenref(defref);
        defref = savedefref;
        warningindex = savewarningindex;
        scannerstatus = savescannerstatus;
        b = poolptr;
        escapehex(strstart[s]);
        mem[memtop - 12].hh.v.RH = strtoks(b);
        flushstr(s);
        begintokenlist(mem[memtop - 3].hh.v.RH, INSERTED);
        if (u != 0) {
            decr(strptr);
            u = 0;
        }
        return;
    } break;
    case PDFUNESCAPEHEXCODE: {
        savescannerstatus = scannerstatus;
        savewarningindex = warningindex;
        savedefref = defref;
        if (strstart[strptr] < poolptr)
            u = makestring();
        scanpdfexttoks();
        s = tokenstostring(defref);
        deletetokenref(defref);
        defref = savedefref;
        warningindex = savewarningindex;
        scannerstatus = savescannerstatus;
        b = poolptr;
        unescapehex(strstart[s]);
        mem[memtop - 12].hh.v.RH = strtoks(b);
        flushstr(s);
        begintokenlist(mem[memtop - 3].hh.v.RH, INSERTED);
        if (u != 0) {
            decr(strptr);
            u = 0;
        }
        return;
    } break;
    case PDFCREATIONDATECODE: {
        b = poolptr;
        getcreationdate();
        mem[memtop - 12].hh.v.RH = strtoks(b);
        begintokenlist(mem[memtop - 3].hh.v.RH, INSERTED);
        return;
    } break;
    case PDFFILEMODDATECODE: {
        savescannerstatus = scannerstatus;
        savewarningindex = warningindex;
        savedefref = defref;
        if (strstart[strptr] < poolptr)
            u = makestring();
        scanpdfexttoks();
        s = tokenstostring(defref);
        deletetokenref(defref);
        defref = savedefref;
        warningindex = savewarningindex;
        scannerstatus = savescannerstatus;
        b = poolptr;
        getfilemoddate(s);
        mem[memtop - 12].hh.v.RH = strtoks(b);
        flushstr(s);
        begintokenlist(mem[memtop - 3].hh.v.RH, INSERTED);
        if (u != 0) {
            decr(strptr);
            u = 0;
        }
        return;
    } break;
    case PDFFILESIZECODE: {
        savescannerstatus = scannerstatus;
        savewarningindex = warningindex;
        savedefref = defref;
        if (strstart[strptr] < poolptr)
            u = makestring();
        scanpdfexttoks();
        s = tokenstostring(defref);
        deletetokenref(defref);
        defref = savedefref;
        warningindex = savewarningindex;
        scannerstatus = savescannerstatus;
        b = poolptr;
        getfilesize(s);
        mem[memtop - 12].hh.v.RH = strtoks(b);
        flushstr(s);
        begintokenlist(mem[memtop - 3].hh.v.RH, INSERTED);
        if (u != 0) {
            decr(strptr);
            u = 0;
        }
        return;
    } break;
    case PDFMDFIVESUMCODE: {
        savescannerstatus = scannerstatus;
        savewarningindex = warningindex;
        savedefref = defref;
        if (strstart[strptr] < poolptr)
            u = makestring();
        bool = scankeyword(/* str 'file' */ 878);
        scanpdfexttoks();
        s = tokenstostring(defref);
        deletetokenref(defref);
        defref = savedefref;
        warningindex = savewarningindex;
        scannerstatus = savescannerstatus;
        b = poolptr;
        getmd5sum(s, bool);
        mem[memtop - 12].hh.v.RH = strtoks(b);
        flushstr(s);
        begintokenlist(mem[memtop - 3].hh.v.RH, INSERTED);
        if (u != 0) {
            decr(strptr);
            u = 0;
        }
        return;
    } break;
    case PDFFILEDUMPCODE: {
        savescannerstatus = scannerstatus;
        savewarningindex = warningindex;
        savedefref = defref;
        if (strstart[strptr] < poolptr)
            u = makestring();
        curval = 0;
        if ((scankeyword(/* str 'offset' */ 879))) {
            scanint();
            if ((curval < 0)) {
                {
                    if (interaction == ERRORSTOPMODE)
                        ;
                    if (filelineerrorstylep)
                        printfileline();
                    else
                        printnl(/* str '! ' */ 264);
                    print(/* str 'Bad file offset' */ 880);
                }
                {
                    helpptr = 2;
                    helpline[1] = /* str 'A file offset must be between 0 and
                                     2^{31}-1,' */
                        881;
                    helpline[0] = /* str 'I changed this one to zero.' */ 790;
                }
                interror(curval);
                curval = 0;
            }
        }
        i = curval;
        curval = 0;
        if ((scankeyword(/* str 'length' */ 882))) {
            scanint();
            if ((curval < 0)) {
                {
                    if (interaction == ERRORSTOPMODE)
                        ;
                    if (filelineerrorstylep)
                        printfileline();
                    else
                        printnl(/* str '! ' */ 264);
                    print(/* str 'Bad dump length' */ 883);
                }
                {
                    helpptr = 2;
                    helpline[1] = /* str 'A dump length must be between 0 and
                                     2^{31}-1,' */
                        884;
                    helpline[0] = /* str 'I changed this one to zero.' */ 790;
                }
                interror(curval);
                curval = 0;
            }
        }
        j = curval;
        scanpdfexttoks();
        s = tokenstostring(defref);
        deletetokenref(defref);
        defref = savedefref;
        warningindex = savewarningindex;
        scannerstatus = savescannerstatus;
        b = poolptr;
        getfiledump(s, i, j);
        mem[memtop - 12].hh.v.RH = strtoks(b);
        flushstr(s);
        begintokenlist(mem[memtop - 3].hh.v.RH, INSERTED);
        if (u != 0) {
            decr(strptr);
            u = 0;
        }
        return;
    } break;
    case PDFMATCHCODE: {
        savescannerstatus = scannerstatus;
        savewarningindex = warningindex;
        savedefref = defref;
        if (strstart[strptr] < poolptr)
            u = makestring();
        bool = scankeyword(/* str 'icase' */ 885);
        i = -1;
        if (scankeyword(/* str 'subcount' */ 886)) {
            scanint();
            i = curval;
        }
        scanpdfexttoks();
        s = tokenstostring(defref);
        deletetokenref(defref);
        scanpdfexttoks();
        t = tokenstostring(defref);
        deletetokenref(defref);
        defref = savedefref;
        warningindex = savewarningindex;
        scannerstatus = savescannerstatus;
        b = poolptr;
        matchstrings(s, t, i, bool);
        mem[memtop - 12].hh.v.RH = strtoks(b);
        flushstr(t);
        flushstr(s);
        begintokenlist(mem[memtop - 3].hh.v.RH, INSERTED);
        if (u != 0) {
            decr(strptr);
            u = 0;
        }
        return;
    } break;
    case PDFLASTMATCHCODE: {
        scanint();
        if (curval < 0) {
            {
                if (interaction == ERRORSTOPMODE)
                    ;
                if (filelineerrorstylep)
                    printfileline();
                else
                    printnl(/* str '! ' */ 264);
                print(/* str 'Bad match number' */ 887);
            }
            {
                helpptr = 2;
                helpline[1] =
                    /* str 'Since I expected zero or a positive number,' */ 888;
                helpline[0] = /* str 'I changed this one to zero.' */ 790;
            }
            interror(curval);
            curval = 0;
        }
        b = poolptr;
        getmatch(curval);
        mem[memtop - 12].hh.v.RH = strtoks(b);
        begintokenlist(mem[memtop - 3].hh.v.RH, INSERTED);
        return;
    } break;
    case PDFSTRCMPCODE: {
        savescannerstatus = scannerstatus;
        savewarningindex = warningindex;
        savedefref = defref;
        if (strstart[strptr] < poolptr)
            u = makestring();
        comparestrings();
        defref = savedefref;
        warningindex = savewarningindex;
        scannerstatus = savescannerstatus;
        if (u != 0) {
            decr(strptr);
            u = 0;
        }
    } break;
    case PDFCOLORSTACKINITCODE: {
        bool = scankeyword(/* str 'page' */ 889);
        if (scankeyword(/* str 'direct' */ 890))
            curval = 2;
        else if (scankeyword(/* str 'page' */ 889))
            curval = 1;
        else
            curval = 0;
        savescannerstatus = scannerstatus;
        savewarningindex = warningindex;
        savedefref = defref;
        if (strstart[strptr] < poolptr)
            u = makestring();
        scanpdfexttoks();
        s = tokenstostring(defref);
        deletetokenref(defref);
        defref = savedefref;
        warningindex = savewarningindex;
        scannerstatus = savescannerstatus;
        curval = newcolorstack(s, curval, bool);
        flushstr(s);
        curvallevel = INTVAL;
        if (curval < 0) {
            {
                if (interaction == ERRORSTOPMODE)
                    ;
                if (filelineerrorstylep)
                    printfileline();
                else
                    printnl(/* str '! ' */ 264);
                print(/* str 'Too many color stacks' */ 891);
            }
            {
                helpptr = 2;
                helpline[1] =
                    /* str 'The number of color stacks is limited to 32768.' */
                    892;
                helpline[0] =
                    /* str 'I'll use the default color stack 0 here.' */ 893;
            }
            error();
            curval = 0;
            if (u != 0) {
                decr(strptr);
                u = 0;
            }
        }
    } break;
    case JOBNAMECODE:
        if (jobname == 0)
            openlogfile();
        break;
    case UNIFORMDEVIATECODE:
        scanint();
        break;
    case NORMALDEVIATECODE:;
        break;
    case PDFINSERTHTCODE:
        scanregisternum();
        break;
    case PDFXIMAGEBBOXCODE: {
        scanint();
        pdfcheckobj(8, curval);
        i = pdfmem[objtab[curval].int4 + 4];
        scanint();
        j = curval;
        if ((j < 1) || (j > 4))
            pdferror(/* str 'pdfximagebbox' */ 871,
                     /* str 'invalid parameter' */ 894);
    } break;
    }
    oldsetting = selector;
    selector = NEWSTRING;
    b = poolptr;
    /* comment:Print the result of command |c| */ switch (c) {
    case NUMBERCODE:
        printint(curval);
        break;
    case ROMANNUMERALCODE:
        printromanint(curval);
        break;
    case STRINGCODE:
        if (curcs != 0)
            sprintcs(curcs);
        else
            printchar(curchr);
        break;
    case MEANINGCODE:
        printmeaning();
        break;
    case FONTNAMECODE: {
        print(fontname[curval]);
        if (fontsize[curval] != fontdsize[curval]) {
            print(/* str ' at ' */ 895);
            printscaled(fontsize[curval]);
            print(/* str 'pt' */ 312);
        }
    } break;
    case ETEXREVISIONCODE:
        print(/* str '.6' */ 256);
        break;
    case PDFTEXREVISIONCODE:
        print(/* str '20' */ 257);
        break;
    case PDFTEXBANNERCODE:
        print(pdftexbanner);
        break;
    case PDFFONTNAMECODE:
    case PDFFONTOBJNUMCODE: {
        {
            if (pdffontnum[curval] < 0)
                ff = -(integer)pdffontnum[curval];
            else
                ff = curval;
        }
        if (c == PDFFONTNAMECODE)
            printint(objtab[pdffontnum[ff]].int0);
        else
            printint(pdffontnum[ff]);
    } break;
    case PDFFONTSIZECODE: {
        printscaled(fontsize[curval]);
        print(/* str 'pt' */ 312);
    } break;
    case PDFPAGEREFCODE:
        printint(getobj(1, curval, false));
        break;
    case LEFTMARGINKERNCODE: {
        p = mem[p + LISTOFFSET].hh.v.RH;
        while (
            (p != TEXNULL) &&
            ((!(p >= himemmin) &&
              ((mem[p].hh.b0 == INSNODE) || (mem[p].hh.b0 == MARKNODE) ||
               (mem[p].hh.b0 == ADJUSTNODE) || (mem[p].hh.b0 == PENALTYNODE) ||
               ((mem[p].hh.b0 == WHATSITNODE) &&
                (mem[p].hh.b1 != /* @d5604@ */ 12) &&
                (mem[p].hh.b1 != /* @d5605@ */ 10)) ||
               ((mem[p].hh.b0 == DISCNODE) && (mem[p + 1].hh.v.LH == TEXNULL) &&
                (mem[p + 1].hh.v.RH == TEXNULL) && (mem[p].hh.b1 == 0)) ||
               ((mem[p].hh.b0 == MATHNODE) &&
                (mem[p + WIDTHOFFSET].cint == 0)) ||
               ((mem[p].hh.b0 == KERNNODE) &&
                ((mem[p + WIDTHOFFSET].cint == 0) ||
                 (mem[p].hh.b1 == NORMAL))) ||
               ((mem[p].hh.b0 == GLUENODE) && (mem[p + 1].hh.v.LH == membot)) ||
               ((mem[p].hh.b0 == HLISTNODE) &&
                (mem[p + WIDTHOFFSET].cint == 0) &&
                (mem[p + HEIGHTOFFSET].cint == 0) &&
                (mem[p + DEPTHOFFSET].cint == 0) &&
                (mem[p + LISTOFFSET].hh.v.RH == TEXNULL)))) ||
             ((!(p >= himemmin)) && (mem[p].hh.b0 == GLUENODE) &&
              (mem[p].hh.b1 == /* @d5619@ */ 8))))
            p = mem[p].hh.v.RH;
        if ((p != TEXNULL) && (!(p >= himemmin)) &&
            (mem[p].hh.b0 == MARGINKERNNODE) && (mem[p].hh.b1 == 0))
            printscaled(mem[p + WIDTHOFFSET].cint);
        else
            print(/* str '0' */ 48);
        print(/* str 'pt' */ 312);
    } break;
    case RIGHTMARGINKERNCODE: {
        q = mem[p + LISTOFFSET].hh.v.RH;
        p = prevrightmost(q, TEXNULL);
        while (
            (p != TEXNULL) &&
            ((!(p >= himemmin) &&
              ((mem[p].hh.b0 == INSNODE) || (mem[p].hh.b0 == MARKNODE) ||
               (mem[p].hh.b0 == ADJUSTNODE) || (mem[p].hh.b0 == PENALTYNODE) ||
               ((mem[p].hh.b0 == WHATSITNODE) &&
                (mem[p].hh.b1 != /* @d5631@ */ 12) &&
                (mem[p].hh.b1 != /* @d5632@ */ 10)) ||
               ((mem[p].hh.b0 == DISCNODE) && (mem[p + 1].hh.v.LH == TEXNULL) &&
                (mem[p + 1].hh.v.RH == TEXNULL) && (mem[p].hh.b1 == 0)) ||
               ((mem[p].hh.b0 == MATHNODE) &&
                (mem[p + WIDTHOFFSET].cint == 0)) ||
               ((mem[p].hh.b0 == KERNNODE) &&
                ((mem[p + WIDTHOFFSET].cint == 0) ||
                 (mem[p].hh.b1 == NORMAL))) ||
               ((mem[p].hh.b0 == GLUENODE) && (mem[p + 1].hh.v.LH == membot)) ||
               ((mem[p].hh.b0 == HLISTNODE) &&
                (mem[p + WIDTHOFFSET].cint == 0) &&
                (mem[p + HEIGHTOFFSET].cint == 0) &&
                (mem[p + DEPTHOFFSET].cint == 0) &&
                (mem[p + LISTOFFSET].hh.v.RH == TEXNULL)))) ||
             ((!(p >= himemmin)) && (mem[p].hh.b0 == GLUENODE) &&
              (mem[p].hh.b1 == /* @d5646@ */ 9))))
            p = prevrightmost(q, p);
        if ((p != TEXNULL) && (!(p >= himemmin)) &&
            (mem[p].hh.b0 == MARGINKERNNODE) && (mem[p].hh.b1 == 1))
            printscaled(mem[p + WIDTHOFFSET].cint);
        else
            print(/* str '0' */ 48);
        print(/* str 'pt' */ 312);
    } break;
    case PDFXFORMNAMECODE:
        printint(objtab[curval].int0);
        break;
    case PDFSTRCMPCODE:
        printint(curval);
        break;
    case PDFCOLORSTACKINITCODE:
        printint(curval);
        break;
    case UNIFORMDEVIATECODE:
        printint(unifrand(curval));
        break;
    case NORMALDEVIATECODE:
        printint(normrand());
        break;
    case PDFINSERTHTCODE: {
        i = curval;
        p = memtop;
        while (i >= mem[mem[p].hh.v.RH].hh.b1)
            p = mem[p].hh.v.RH;
        if (mem[p].hh.b1 == i)
            printscaled(mem[p + HEIGHTOFFSET].cint);
        else
            print(/* str '0' */ 48);
        print(/* str 'pt' */ 312);
    } break;
    case PDFXIMAGEBBOXCODE: {
        if (ispdfimage(i)) {
            switch (j) {
            case 1:
                printscaled(epdforigx(i));
                break;
            case 2:
                printscaled(epdforigy(i));
                break;
            case 3:
                printscaled(epdforigx(i) + imagewidth(i));
                break;
            case 4:
                printscaled(epdforigy(i) + imageheight(i));
                break;
            }
        } else
            printscaled(0);
        print(/* str 'pt' */ 312);
    } break;
    case JOBNAMECODE:
        print(jobname);
        break;
    }
    selector = oldsetting;
    mem[memtop - 12].hh.v.RH = strtoks(b);
    begintokenlist(mem[memtop - 3].hh.v.RH, INSERTED);
}
halfword zscantoks(boolean macrodef, boolean xpand) {
    register halfword Result;
    scantoks_regmem halfword t;
    halfword s;
    halfword p;
    halfword q;
    halfword unbalance;
    halfword hashbrace;
    if (macrodef)
        scannerstatus = DEFINING;
    else
        scannerstatus = ABSORBING;
    warningindex = curcs;
    defref = getavail();
    mem[defref].hh.v.LH = TEXNULL;
    p = defref;
    hashbrace = 0;
    t = ZEROTOKEN;
    if (macrodef) /* comment:Scan and build the parameter part of the macro def
                   */
    {
        while (true) {

            gettoken();
            if (curtok < RIGHTBRACELIMIT)
                goto labscantoks31done1;
            if (curcmd == MACPARAM) /* comment:If the next character is a
                                              parameter number, make  */
            {
                s = MATCHTOKEN + curchr;
                gettoken();
                if (curcmd == LEFTBRACE) {
                    hashbrace = curtok;
                    {
                        q = getavail();
                        mem[p].hh.v.RH = q;
                        mem[q].hh.v.LH = curtok;
                        p = q;
                    }
                    {
                        q = getavail();
                        mem[p].hh.v.RH = q;
                        mem[q].hh.v.LH = ENDMATCHTOKEN;
                        p = q;
                    }
                    goto labscantoks30done;
                }
                if (t == /* @d5681@ */ 3129) {
                    {
                        if (interaction == ERRORSTOPMODE)
                            ;
                        if (filelineerrorstylep)
                            printfileline();
                        else
                            printnl(/* str '! ' */ 264);
                        print(/* str 'You already have nine parameters' */ 898);
                    }
                    {
                        helpptr = 1;
                        helpline[0] = /* str 'I'm going to ignore the # sign you
                                         just used.' */
                            899;
                    }
                    error();
                } else {

                    incr(t);
                    if (curtok != t) {
                        {
                            if (interaction == ERRORSTOPMODE)
                                ;
                            if (filelineerrorstylep)
                                printfileline();
                            else
                                printnl(/* str '! ' */ 264);
                            print(/* str 'Parameters must be numbered
                                     consecutively' */
                                  900);
                        }
                        {
                            helpptr = 2;
                            helpline[1] = /* str 'I've inserted the digit you
                                             should have used afte' */
                                901;
                            helpline[0] =
                                /* str 'Type `1' to delete what you did use.' */
                                902;
                        }
                        backerror();
                    }
                    curtok = s;
                }
            }
            {
                q = getavail();
                mem[p].hh.v.RH = q;
                mem[q].hh.v.LH = curtok;
                p = q;
            }
        }
    labscantoks31done1 : {

        q = getavail();
        mem[p].hh.v.RH = q;
        mem[q].hh.v.LH = ENDMATCHTOKEN;
        p = q;
    }
        if (curcmd == RIGHTBRACE) /* comment:Express shock at the missing
                                          left brace; |goto fou */
        {
            {
                if (interaction == ERRORSTOPMODE)
                    ;
                if (filelineerrorstylep)
                    printfileline();
                else
                    printnl(/* str '! ' */ 264);
                print(/* str 'Missing { inserted' */ 744);
            }
            incr(alignstate);
            {
                helpptr = 2;
                helpline[1] = /* str 'Where was the left brace? You said
                                 something like' */
                    896;
                helpline[0] =
                    /* str 'which I'm going to interpret as `\def\a{}'.' */ 897;
            }
            error();
            goto labscantoks40found;
        }
    labscantoks30done:;
    } else
        scanleftbrace();
    /* comment:Scan and build the body of the token list; |goto f */ unbalance =
        1;
    while (true) {

        if (xpand) /* comment:Expand the next part of the input */
        {
            while (true) {

                getnext();
                if (curcmd >= CALL) {

                    if (mem[mem[curchr].hh.v.RH].hh.v.LH == PROTECTEDTOKEN) {
                        curcmd = RELAX;
                        curchr = NOEXPANDFLAG;
                    }
                }
                if (curcmd <= MAXCOMMAND)
                    goto labscantoks32done2;
                if (curcmd != THE)
                    expand();
                else {

                    q = thetoks();
                    if (mem[memtop - 3].hh.v.RH != TEXNULL) {
                        mem[p].hh.v.RH = mem[memtop - 3].hh.v.RH;
                        p = q;
                    }
                }
            }
        labscantoks32done2:
            xtoken();
        } else
            gettoken();
        if (curtok < RIGHTBRACELIMIT) {

            if (curcmd < RIGHTBRACE)
                incr(unbalance);
            else {

                decr(unbalance);
                if (unbalance == 0)
                    goto labscantoks40found;
            }
        } else if (curcmd == MACPARAM) {

            if (macrodef) /* comment:Look for parameter number or \.{\#\#} */
            {
                s = curtok;
                if (xpand)
                    getxtoken();
                else
                    gettoken();
                if (curcmd != MACPARAM) {

                    if ((curtok <= ZEROTOKEN) || (curtok > t)) {
                        {
                            if (interaction == ERRORSTOPMODE)
                                ;
                            if (filelineerrorstylep)
                                printfileline();
                            else
                                printnl(/* str '! ' */ 264);
                            print(/* str 'Illegal parameter number in definition
                                     of ' */
                                  903);
                        }
                        sprintcs(warningindex);
                        {
                            helpptr = 3;
                            helpline[2] = /* str 'You meant to type ## instead
                                             of #, right?' */
                                904;
                            helpline[1] = /* str 'Or maybe a } was forgotten
                                             somewhere earlier, and' */
                                905;
                            helpline[0] = /* str 'are all screwed up? I'm going
                                             to assume that you ' */
                                906;
                        }
                        backerror();
                        curtok = s;
                    } else
                        curtok = /* @d5725@ */ /* str '0' */ 1232 + curchr;
                }
            }
        }
        {
            q = getavail();
            mem[p].hh.v.RH = q;
            mem[q].hh.v.LH = curtok;
            p = q;
        }
    }
labscantoks40found:
    scannerstatus = NORMAL;
    if (hashbrace != 0) {
        q = getavail();
        mem[p].hh.v.RH = q;
        mem[q].hh.v.LH = hashbrace;
        p = q;
    }
    Result = p;
    return Result;
}
void zreadtoks(integer n, halfword r, halfword j) {
    readtoks_regmem halfword p;
    halfword q;
    integer s;
    smallnumber m;
    scannerstatus = DEFINING;
    warningindex = r;
    defref = getavail();
    mem[defref].hh.v.LH = TEXNULL;
    p = defref;
    {
        q = getavail();
        mem[p].hh.v.RH = q;
        mem[q].hh.v.LH = ENDMATCHTOKEN;
        p = q;
    }
    if ((n < 0) || (n > 15))
        m = 16;
    else
        m = n;
    s = alignstate;
    alignstate = 1000000L;
    do {
        /* comment:Input and store tokens from the next line of the f */
        beginfilereading();
        curinput.namefield = m + 1;
        if (readopen[m] == /* @d5733@ */
            2) /* comment:Input for \.{\\read} from the terminal */ {

            if (interaction > NONSTOPMODE) {

                if (n < 0) {
                    ;
                    print(/* str '' */ 345);
                    terminput();
                } else {

                    ;
                    println();
                    sprintcs(r);
                    {
                        ;
                        print(/* str '=' */ 61);
                        terminput();
                    }
                    n = -1;
                }
            } else
                fatalerror(
                    /* str ' (cannot \read from terminal in nonstop modes)' */
                    907);
        } else if (readopen[m] == /* @d5739@ */
                   1) /* comment:Input the first line of |read_file[m]| */ {

            if (inputln(readfile[m], false))
                readopen[m] = NORMAL;
            else {

                aclose(readfile[m]);
                readopen[m] = CLOSED;
            }
        } else /* comment:Input the next line of |read_file[m]| */ {

            if (!inputln(readfile[m], true)) {
                aclose(readfile[m]);
                readopen[m] = CLOSED;
                if (alignstate != 1000000L) {
                    runaway();
                    {
                        if (interaction == ERRORSTOPMODE)
                            ;
                        if (filelineerrorstylep)
                            printfileline();
                        else
                            printnl(/* str '! ' */ 264);
                        print(/* str 'File ended within ' */ 908);
                    }
                    printesc(/* str 'read' */ 614);
                    {
                        helpptr = 1;
                        helpline[0] =
                            /* str 'This \read has unbalanced braces.' */ 909;
                    }
                    alignstate = 1000000L;
                    error();
                }
            }
        }
        curinput.limitfield = last;
        if ((eqtb[INTBASE + ENDLINECHARCODE].cint < 0) ||
            (eqtb[INTBASE + ENDLINECHARCODE].cint > 255))
            decr(curinput.limitfield);
        else
            buffer[curinput.limitfield] = eqtb[INTBASE + ENDLINECHARCODE].cint;
        first = curinput.limitfield + 1;
        curinput.locfield = curinput.startfield;
        curinput.statefield = NEWLINE;
        /* comment:Handle \.{\\readline} and |goto done| */ if (j == 1) {
            while (curinput.locfield <= curinput.limitfield) {

                curchr = buffer[curinput.locfield];
                incr(curinput.locfield);
                if (curchr == /* str ' ' */ 32)
                    curtok = SPACETOKEN;
                else
                    curtok = curchr + OTHERTOKEN;
                {
                    q = getavail();
                    mem[p].hh.v.RH = q;
                    mem[q].hh.v.LH = curtok;
                    p = q;
                }
            }
            goto labreadtoks30done;
        }
        while (true) {

            gettoken();
            if (curtok == 0)
                goto labreadtoks30done;
            if (alignstate < 1000000L) {
                do {
                    gettoken();
                } while (!(curtok == 0));
                alignstate = 1000000L;
                goto labreadtoks30done;
            }
            {
                q = getavail();
                mem[p].hh.v.RH = q;
                mem[q].hh.v.LH = curtok;
                p = q;
            }
        }
    labreadtoks30done:
        endfilereading();
    } while (!(alignstate == 1000000L));
    curval = defref;
    scannerstatus = NORMAL;
    alignstate = s;
}
void passtext(void) {
    passtext_regmem integer l;
    smallnumber savescannerstatus;
    savescannerstatus = scannerstatus;
    scannerstatus = SKIPPING;
    l = 0;
    skipline = line;
    while (true) {

        getnext();
        if (curcmd == FIORELSE) {
            if (l == 0)
                goto labpasstext30done;
            if (curchr == FICODE)
                decr(l);
        } else if (curcmd == IFTEST)
            incr(l);
    }
labpasstext30done:
    scannerstatus = savescannerstatus;
    if (eqtb[INTBASE + TRACINGIFSCODE].cint > 0)
        showcurcmdchr();
}
void zchangeiflimit(smallnumber l, halfword p) {
    changeiflimit_regmem halfword q;
    if (p == condptr)
        iflimit = l;
    else {

        q = condptr;
        while (true) {

            if (q == TEXNULL)
                confusion(/* str 'if' */ 910);
            if (mem[q].hh.v.RH == p) {
                mem[q].hh.b0 = l;
                return;
            }
            q = mem[q].hh.v.RH;
        }
    }
}
void conditional(void) {
    conditional_regmem boolean b;
    boolean e;
    /* str '<' */ /* str '>' */ unsigned char r;
    integer m, n;
    halfword p, q;
    smallnumber savescannerstatus;
    halfword savecondptr;
    smallnumber thisif;
    boolean isunless;
    if (eqtb[INTBASE + TRACINGIFSCODE].cint > 0) {

        if (eqtb[INTBASE + TRACINGCOMMANDSCODE].cint <= 1)
            showcurcmdchr();
    }
    /* comment:Push the condition stack */ {

        p = getnode(IFNODESIZE);
        mem[p].hh.v.RH = condptr;
        mem[p].hh.b0 = iflimit;
        mem[p].hh.b1 = curif;
        mem[p + 1].cint = ifline;
        condptr = p;
        curif = curchr;
        iflimit = IFCODE;
        ifline = line;
    }
    savecondptr = condptr;
    isunless = (curchr >= UNLESSCODE);
    thisif = curchr % /* @d5791@ */ 32;
    /* comment:Either process \.{\\ifcase} or set |b| to the valu */ switch (
        thisif) {
    case IFCHARCODE:
    case IFCATCODE:
        /* comment:Test if two characters match */ {

            {
                getxtoken();
                if (curcmd == RELAX) {

                    if (curchr == NOEXPANDFLAG) {
                        curcmd = ACTIVECHAR;
                        curchr = /* @d5799@ */ curtok - 4096;
                    }
                }
            }
            if ((curcmd > ACTIVECHAR) || (curchr > 255)) {
                m = RELAX;
                n = 256;
            } else {

                m = curcmd;
                n = curchr;
            }
            {
                getxtoken();
                if (curcmd == RELAX) {

                    if (curchr == NOEXPANDFLAG) {
                        curcmd = ACTIVECHAR;
                        curchr = /* @d5805@ */ curtok - 4096;
                    }
                }
            }
            if ((curcmd > ACTIVECHAR) || (curchr > 255)) {
                curcmd = RELAX;
                curchr = 256;
            }
            if (thisif == IFCHARCODE)
                b = (n == curchr);
            else
                b = (m == curcmd);
        }
        break;
    case IFINTCODE:
    case IFDIMCODE:
        /* comment:Test relation between integers or dimensions */ {

            if (thisif == IFINTCODE)
                scanint();
            else
                scandimen(false, false, false);
            n = curval;
            /* comment:Get the next non-blank non-call token */ do {
                getxtoken();
            } while (!(curcmd != SPACER));
            if ((curtok >= /* @d5815@ */ /* str '<' */ 3132) &&
                (curtok <= /* @d5817@ */ /* str '>' */ 3134))
                r = curtok - OTHERTOKEN;
            else {

                {
                    if (interaction == ERRORSTOPMODE)
                        ;
                    if (filelineerrorstylep)
                        printfileline();
                    else
                        printnl(/* str '! ' */ 264);
                    print(/* str 'Missing = inserted for ' */ 936);
                }
                printcmdchr(IFTEST, thisif);
                {
                    helpptr = 1;
                    helpline[0] = /* str 'I was expecting to see `<', `=', or
                                     `>'. Didn't.' */
                        937;
                }
                backerror();
                r = /* str '=' */ 61;
            }
            if (thisif == IFINTCODE)
                scanint();
            else
                scandimen(false, false, false);
            switch (r) { /* str '<' */
            case 60:
                b = (n < curval);
                break;
            /* str '=' */ case 61:
                b = (n == curval);
                break;
            /* str '>' */ case 62:
                b = (n > curval);
                break;
            }
        }
        break;
    case IFODDCODE:
        /* comment:Test if an integer is odd */ {

            scanint();
            b = odd(curval);
        }
        break;
    case IFVMODECODE:
        b = (abs(curlist.modefield) == VMODE);
        break;
    case IFHMODECODE:
        b = (abs(curlist.modefield) == HMODE);
        break;
    case IFMMODECODE:
        b = (abs(curlist.modefield) == MMODE);
        break;
    case IFINNERCODE:
        b = (curlist.modefield < 0);
        break;
    case IFVOIDCODE:
    case IFHBOXCODE:
    case IFVBOXCODE:
        /* comment:Test box register status */ {

            scanregisternum();
            if (curval < 256)
                p = eqtb[BOXBASE + curval].hh.v.RH;
            else {

                findsaelement(4, curval, false);
                if (curptr == TEXNULL)
                    p = TEXNULL;
                else
                    p = mem[curptr + 1].hh.v.RH;
            }
            if (thisif == IFVOIDCODE)
                b = (p == TEXNULL);
            else if (p == TEXNULL)
                b = false;
            else if (thisif == IFHBOXCODE)
                b = (mem[p].hh.b0 == HLISTNODE);
            else
                b = (mem[p].hh.b0 == VLISTNODE);
        }
        break;
    case IFXCODE:
        /* comment:Test if two tokens match */ {

            savescannerstatus = scannerstatus;
            scannerstatus = NORMAL;
            getnext();
            n = curcs;
            p = curcmd;
            q = curchr;
            getnext();
            if (curcmd != p)
                b = false;
            else if (curcmd < CALL)
                b = (curchr == q);
            else /* comment:Test if two macro texts match */ {

                p = mem[curchr].hh.v.RH;
                q = mem[eqtb[n].hh.v.RH].hh.v.RH;
                if (p == q)
                    b = true;
                else {

                    while ((p != TEXNULL) && (q != TEXNULL))
                        if (mem[p].hh.v.LH != mem[q].hh.v.LH)
                            p = TEXNULL;
                        else {

                            p = mem[p].hh.v.RH;
                            q = mem[q].hh.v.RH;
                        }
                    b = ((p == TEXNULL) && (q == TEXNULL));
                }
            }
            scannerstatus = savescannerstatus;
        }
        break;
    case IFEOFCODE: {
        scanfourbitintor18();
        if (curval == 18)
            b = !shellenabledp;
        else
            b = (readopen[curval] == CLOSED);
    } break;
    case IFTRUECODE:
        b = true;
        break;
    case IFFALSECODE:
        b = false;
        break;
    /* comment:Cases for |conditional| */ case IFDEFCODE : {
        savescannerstatus = scannerstatus;
        scannerstatus = NORMAL;
        getnext();
        b = (curcmd != UNDEFINEDCS);
        scannerstatus = savescannerstatus;
    } break;
    case IFCSCODE: {
        n = getavail();
        p = n;
        e = isincsname;
        isincsname = true;
        do {
            getxtoken();
            if (curcs == 0) {
                q = getavail();
                mem[p].hh.v.RH = q;
                mem[q].hh.v.LH = curtok;
                p = q;
            }
        } while (!(curcs != 0));
        if (curcmd != ENDCSNAME) /* comment:Complain about missing
                                           \.{\\endcsname} */
        {
            {
                if (interaction == ERRORSTOPMODE)
                    ;
                if (filelineerrorstylep)
                    printfileline();
                else
                    printnl(/* str '! ' */ 264);
                print(/* str 'Missing ' */ 712);
            }
            printesc(/* str 'endcsname' */ 581);
            print(/* str ' inserted' */ 713);
            {
                helpptr = 2;
                helpline[1] = /* str 'The control sequence marked <to be read
                                 again> sh' */
                    714;
                helpline[0] =
                    /* str 'not appear between \csname and \endcsname.' */ 715;
            }
            backerror();
        }
        /* comment:Look up the characters of list |n| in the hash tab */ m =
            first;
        p = mem[n].hh.v.RH;
        while (p != TEXNULL) {

            if (m >= maxbufstack) {
                maxbufstack = m + 1;
                if (maxbufstack == bufsize)
                    overflow(/* str 'buffer size' */ 258, bufsize);
            }
            buffer[m] = mem[p].hh.v.LH % 256;
            incr(m);
            p = mem[p].hh.v.RH;
        }
        if (m > first + 1)
            curcs = idlookup(first, m - first);
        else if (m == first)
            curcs = NULLCS;
        else
            curcs = SINGLEBASE + buffer[first];
        flushlist(n);
        b = (eqtb[curcs].hh.b0 != UNDEFINEDCS);
        isincsname = e;
    } break;
    case IFINCSNAMECODE:
        b = isincsname;
        break;
    case IFPDFABSDIMCODE:
    case IFPDFABSNUMCODE: {
        if (thisif == IFPDFABSNUMCODE)
            scanint();
        else
            scandimen(false, false, false);
        n = curval;
        if (n < 0)
            n = -(integer)n;
        /* comment:Get the next non-blank non-call token */ do {
            getxtoken();
        } while (!(curcmd != SPACER));
        if ((curtok >= /* @d5882@ */ /* str '<' */ 3132) &&
            (curtok <= /* @d5884@ */ /* str '>' */ 3134))
            r = curtok - OTHERTOKEN;
        else {

            {
                if (interaction == ERRORSTOPMODE)
                    ;
                if (filelineerrorstylep)
                    printfileline();
                else
                    printnl(/* str '! ' */ 264);
                print(/* str 'Missing = inserted for ' */ 936);
            }
            printcmdchr(IFTEST, thisif);
            {
                helpptr = 1;
                helpline[0] =
                    /* str 'I was expecting to see `<', `=', or `>'. Didn't.' */
                    937;
            }
            backerror();
            r = /* str '=' */ 61;
        }
        if (thisif == IFPDFABSNUMCODE)
            scanint();
        else
            scandimen(false, false, false);
        if (curval < 0)
            curval = -(integer)curval;
        switch (r) { /* str '<' */
        case 60:
            b = (n < curval);
            break;
        /* str '=' */ case 61:
            b = (n == curval);
            break;
        /* str '>' */ case 62:
            b = (n > curval);
            break;
        }
    } break;
    case IFFONTCHARCODE: {
        scanfontident();
        n = curval;
        scancharnum();
        if ((fontbc[n] <= curval) && (fontec[n] >= curval))
            b = (fontinfo[charbase[n] + effectivechar(true, n, curval)]
                     .qqqq.b0 > MINQUARTERWORD);
        else
            b = false;
    } break;
    case IFCASECODE:
        /* comment:Select the appropriate case and |return| or |goto  */ {

            scanint();
            n = curval;
            if (eqtb[INTBASE + TRACINGCOMMANDSCODE].cint > 1) {
                begindiagnostic();
                print(/* str '{case ' */ 938);
                printint(n);
                printchar(/* str '}' */ 125);
                enddiagnostic(false);
            }
            while (n != 0) {

                passtext();
                if (condptr == savecondptr) {

                    if (curchr == ORCODE)
                        decr(n);
                    else
                        goto labconditional50common_ending;
                } else if (curchr == FICODE) /* comment:Pop the
                                                         condition stack */
                {
                    if (ifstack[inopen] == condptr)
                        ifwarning();
                    p = condptr;
                    ifline = mem[p + 1].cint;
                    curif = mem[p].hh.b1;
                    iflimit = mem[p].hh.b0;
                    condptr = mem[p].hh.v.RH;
                    freenode(p, IFNODESIZE);
                }
            }
            changeiflimit(ORCODE, savecondptr);
            return;
        }
        break;
    case IFPDFPRIMITIVECODE: {
        savescannerstatus = scannerstatus;
        scannerstatus = NORMAL;
        getnext();
        scannerstatus = savescannerstatus;
        if (curcs < HASHBASE)
            m = primlookup(curcs - SINGLEBASE);
        else
            m = primlookup(hash[curcs].v.RH);
        b = ((curcmd != UNDEFINEDCS) && (m != UNDEFINEDPRIMITIVE) &&
             (curcmd == eqtb[PRIMEQTBBASE + m].hh.b0) &&
             (curchr == eqtb[PRIMEQTBBASE + m].hh.v.RH));
    } break;
    }
    if (isunless)
        b = !b;
    if (eqtb[INTBASE + TRACINGCOMMANDSCODE].cint >
        1) /* comment:Display the value of |b| */
    {
        begindiagnostic();
        if (b)
            print(/* str '{true}' */ 934);
        else
            print(/* str '{false}' */ 935);
        enddiagnostic(false);
    }
    if (b) {
        changeiflimit(ELSECODE, savecondptr);
        return;
    }
    /* comment:Skip to \.{\\else} or \.{\\fi}, then |goto common_ */ while (
        true) {

        passtext();
        if (condptr == savecondptr) {
            if (curchr != ORCODE)
                goto labconditional50common_ending;
            {
                if (interaction == ERRORSTOPMODE)
                    ;
                if (filelineerrorstylep)
                    printfileline();
                else
                    printnl(/* str '! ' */ 264);
                print(/* str 'Extra ' */ 932);
            }
            printesc(/* str 'or' */ 930);
            {
                helpptr = 1;
                helpline[0] =
                    /* str 'I'm ignoring this; it doesn't match any \if.' */
                    933;
            }
            error();
        } else if (curchr == FICODE) /* comment:Pop the condition stack */
        {
            if (ifstack[inopen] == condptr)
                ifwarning();
            p = condptr;
            ifline = mem[p + 1].cint;
            curif = mem[p].hh.b1;
            iflimit = mem[p].hh.b0;
            condptr = mem[p].hh.v.RH;
            freenode(p, IFNODESIZE);
        }
    }
labconditional50common_ending:
    if (curchr == FICODE) /* comment:Pop the condition stack */
    {
        if (ifstack[inopen] == condptr)
            ifwarning();
        p = condptr;
        ifline = mem[p + 1].cint;
        curif = mem[p].hh.b1;
        iflimit = mem[p].hh.b0;
        condptr = mem[p].hh.v.RH;
        freenode(p, IFNODESIZE);
    } else
        iflimit = FICODE;
}
void beginname(void) {
    beginname_regmem areadelimiter = 0;
    extdelimiter = 0;
    quotedfilename = false;
}
boolean zmorename(ASCIIcode c) {
    register boolean Result;
    morename_regmem if ((c == /* str ' ' */ 32) && stopatspace &&
                        (!quotedfilename)) Result = false;
    else if (c == /* str '""' */ 34) {
        quotedfilename = !quotedfilename;
        Result = true;
    }
    else {

        {
            if (poolptr + 1 > poolsize)
                overflow(/* str 'pool size' */ 259, poolsize - initpoolptr);
        }
        {
            strpool[poolptr] = c;
            incr(poolptr);
        }
        if (ISDIRSEP(c)) {
            areadelimiter = (poolptr - strstart[strptr]);
            extdelimiter = 0;
        } else if (c == /* str '.' */ 46)
            extdelimiter = (poolptr - strstart[strptr]);
        Result = true;
    }
    return Result;
}
void endname(void) {
    endname_regmem strnumber tempstr;
    poolpointer j, s, t;
    boolean mustquote;
    if (strptr + 3 > maxstrings)
        overflow(/* str 'number of strings' */ 260, maxstrings - initstrptr);
    {
        if (poolptr + 6 > poolsize)
            overflow(/* str 'pool size' */ 259, poolsize - initpoolptr);
    }
    if (areadelimiter != 0) {
        mustquote = false;
        s = strstart[strptr];
        t = strstart[strptr] + areadelimiter;
        j = s;
        while ((!mustquote) && (j < t)) {

            mustquote = strpool[j] == /* str ' ' */ 32;
            incr(j);
        }
        if (mustquote) {
            {
                register integer for_end;
                j = poolptr - 1;
                for_end = t;
                if (j >= for_end)
                    do
                        strpool[j + 2] = strpool[j];
                    while (j-- > for_end);
            }
            strpool[t + 1] = /* str '""' */ 34;
            {
                register integer for_end;
                j = t - 1;
                for_end = s;
                if (j >= for_end)
                    do
                        strpool[j + 1] = strpool[j];
                    while (j-- > for_end);
            }
            strpool[s] = /* str '""' */ 34;
            if (extdelimiter != 0)
                extdelimiter = extdelimiter + 2;
            areadelimiter = areadelimiter + 2;
            poolptr = poolptr + 2;
        }
    }
    s = strstart[strptr] + areadelimiter;
    if (extdelimiter == 0)
        t = poolptr;
    else
        t = strstart[strptr] + extdelimiter - 1;
    mustquote = false;
    j = s;
    while ((!mustquote) && (j < t)) {

        mustquote = strpool[j] == /* str ' ' */ 32;
        incr(j);
    }
    if (mustquote) {
        {
            register integer for_end;
            j = poolptr - 1;
            for_end = t;
            if (j >= for_end)
                do
                    strpool[j + 2] = strpool[j];
                while (j-- > for_end);
        }
        strpool[t + 1] = /* str '""' */ 34;
        {
            register integer for_end;
            j = t - 1;
            for_end = s;
            if (j >= for_end)
                do
                    strpool[j + 1] = strpool[j];
                while (j-- > for_end);
        }
        strpool[s] = /* str '""' */ 34;
        if (extdelimiter != 0)
            extdelimiter = extdelimiter + 2;
        poolptr = poolptr + 2;
    }
    if (extdelimiter != 0) {
        s = strstart[strptr] + extdelimiter - 1;
        t = poolptr;
        mustquote = false;
        j = s;
        while ((!mustquote) && (j < t)) {

            mustquote = strpool[j] == /* str ' ' */ 32;
            incr(j);
        }
        if (mustquote) {
            strpool[t + 1] = /* str '""' */ 34;
            {
                register integer for_end;
                j = t - 1;
                for_end = s;
                if (j >= for_end)
                    do
                        strpool[j + 1] = strpool[j];
                    while (j-- > for_end);
            }
            strpool[s] = /* str '""' */ 34;
            poolptr = poolptr + 2;
        }
    }
    if (areadelimiter == 0)
        curarea = /* str '' */ 345;
    else {

        curarea = strptr;
        strstart[strptr + 1] = strstart[strptr] + areadelimiter;
        incr(strptr);
        tempstr = searchstring(curarea);
        if (tempstr > 0) {
            curarea = tempstr;
            decr(strptr);
            {
                register integer for_end;
                j = strstart[strptr + 1];
                for_end = poolptr - 1;
                if (j <= for_end)
                    do {
                        strpool[j - areadelimiter] = strpool[j];
                    } while (j++ < for_end);
            }
            poolptr = poolptr - areadelimiter;
        }
    }
    if (extdelimiter == 0) {
        curext = /* str '' */ 345;
        curname = slowmakestring();
    } else {

        curname = strptr;
        strstart[strptr + 1] =
            strstart[strptr] + extdelimiter - areadelimiter - 1;
        incr(strptr);
        curext = makestring();
        decr(strptr);
        tempstr = searchstring(curname);
        if (tempstr > 0) {
            curname = tempstr;
            decr(strptr);
            {
                register integer for_end;
                j = strstart[strptr + 1];
                for_end = poolptr - 1;
                if (j <= for_end)
                    do {
                        strpool[j - extdelimiter + areadelimiter + 1] =
                            strpool[j];
                    } while (j++ < for_end);
            }
            poolptr = poolptr - extdelimiter + areadelimiter + 1;
        }
        curext = slowmakestring();
    }
}
void zpackfilename(strnumber n, strnumber a, strnumber e) {
    packfilename_regmem integer k;
    ASCIIcode c;
    poolpointer j;
    k = 0;
    if (nameoffile)
        libcfree(nameoffile);
    nameoffile =
        xmallocarray(ASCIIcode, (strstart[a + 1] - strstart[a]) +
                                    (strstart[n + 1] - strstart[n]) +
                                    (strstart[e + 1] - strstart[e]) + 1);
    {
        register integer for_end;
        j = strstart[a];
        for_end = strstart[a + 1] - 1;
        if (j <= for_end)
            do {
                c = strpool[j];
                if (!(c == /* str '""' */ 34)) {
                    incr(k);
                    if (k <= maxint)
                        nameoffile[k] = xchr[c];
                }
            } while (j++ < for_end);
    }
    {
        register integer for_end;
        j = strstart[n];
        for_end = strstart[n + 1] - 1;
        if (j <= for_end)
            do {
                c = strpool[j];
                if (!(c == /* str '""' */ 34)) {
                    incr(k);
                    if (k <= maxint)
                        nameoffile[k] = xchr[c];
                }
            } while (j++ < for_end);
    }
    {
        register integer for_end;
        j = strstart[e];
        for_end = strstart[e + 1] - 1;
        if (j <= for_end)
            do {
                c = strpool[j];
                if (!(c == /* str '""' */ 34)) {
                    incr(k);
                    if (k <= maxint)
                        nameoffile[k] = xchr[c];
                }
            } while (j++ < for_end);
    }
    if (k <= maxint)
        namelength = k;
    else
        namelength = maxint;
    nameoffile[namelength + 1] = 0;
}
void zpackbufferedname(smallnumber n, integer a, integer b) {
    packbufferedname_regmem integer k;
    ASCIIcode c;
    integer j;
    if (n + b - /* @d5964@ */ a + 5 > maxint)
        b = a + maxint - /* @d5965@ */ n - 5;
    k = 0;
    if (nameoffile)
        libcfree(nameoffile);
    nameoffile = xmallocarray(ASCIIcode, n + (b - a + 1) /* @d5966@ */ + 5);
    {
        register integer for_end;
        j = 1;
        for_end = n;
        if (j <= for_end)
            do {
                c = xord[ucharcast(TEXformatdefault[j])];
                if (!(c == /* str '""' */ 34)) {
                    incr(k);
                    if (k <= maxint)
                        nameoffile[k] = xchr[c];
                }
            } while (j++ < for_end);
    }
    {
        register integer for_end;
        j = a;
        for_end = b;
        if (j <= for_end)
            do {
                c = buffer[j];
                if (!(c == /* str '""' */ 34)) {
                    incr(k);
                    if (k <= maxint)
                        nameoffile[k] = xchr[c];
                }
            } while (j++ < for_end);
    }
    {
        register integer for_end;
        j = /* @d5969@ */ formatdefaultlength - 3;
        for_end = formatdefaultlength;
        if (j <= for_end)
            do {
                c = xord[ucharcast(TEXformatdefault[j])];
                if (!(c == /* str '""' */ 34)) {
                    incr(k);
                    if (k <= maxint)
                        nameoffile[k] = xchr[c];
                }
            } while (j++ < for_end);
    }
    if (k <= maxint)
        namelength = k;
    else
        namelength = maxint;
    nameoffile[namelength + 1] = 0;
}
strnumber makenamestring(void) {
    register strnumber Result;
    makenamestring_regmem integer k;
    poolpointer saveareadelimiter, saveextdelimiter;
    boolean savenameinprogress, savestopatspace;
    if ((poolptr + namelength > poolsize) || (strptr == maxstrings) ||
        ((poolptr - strstart[strptr]) > 0))
        Result = /* str '?' */ 63;
    else {

        {
            register integer for_end;
            k = 1;
            for_end = namelength;
            if (k <= for_end)
                do {
                    strpool[poolptr] = xord[nameoffile[k]];
                    incr(poolptr);
                } while (k++ < for_end);
        }
        Result = makestring();
        saveareadelimiter = areadelimiter;
        saveextdelimiter = extdelimiter;
        savenameinprogress = nameinprogress;
        savestopatspace = stopatspace;
        nameinprogress = true;
        beginname();
        stopatspace = false;
        k = 1;
        while ((k <= namelength) && (morename(nameoffile[k])))
            incr(k);
        stopatspace = savestopatspace;
        endname();
        nameinprogress = savenameinprogress;
        areadelimiter = saveareadelimiter;
        extdelimiter = saveextdelimiter;
    }
    return Result;
}
strnumber zamakenamestring(alphafile f) {
    register strnumber Result;
    amakenamestring_regmem Result = makenamestring();
    return Result;
}
strnumber zbmakenamestring(bytefile f) {
    register strnumber Result;
    bmakenamestring_regmem Result = makenamestring();
    return Result;
}
strnumber zwmakenamestring(wordfile f) {
    register strnumber Result;
    wmakenamestring_regmem Result = makenamestring();
    return Result;
}
void scanfilename(void) {
    scanfilename_regmem nameinprogress = true;
    beginname();
    /* comment:Get the next non-blank non-call token */ do {
        getxtoken();
    } while (!(curcmd != SPACER));
    while (true) {

        if ((curcmd > OTHERCHAR) || (curchr > 255)) {
            backinput();
            goto labscanfilename30done;
        }
        if ((curchr == /* str ' ' */ 32) &&
            (curinput.statefield != TOKENLIST) &&
            (curinput.locfield > curinput.limitfield))
            goto labscanfilename30done;
        if (!morename(curchr))
            goto labscanfilename30done;
        getxtoken();
    }
labscanfilename30done:
    endname();
    nameinprogress = false;
}
void zpackjobname(strnumber s) {
    packjobname_regmem curarea = /* str '' */ 345;
    curext = s;
    curname = jobname;
    packfilename(curname, curarea, curext);
}
void zpromptfilename(strnumber s, strnumber e) {
    promptfilename_regmem integer k;
    strnumber savedcurname;
    strnumber savedcurext;
    strnumber savedcurarea;
    if (interaction == SCROLLMODE)
        ;
    if (s == /* str 'input file name' */ 940) {
        if (interaction == ERRORSTOPMODE)
            ;
        if (filelineerrorstylep)
            printfileline();
        else
            printnl(/* str '! ' */ 264);
        print(/* str 'I can't find file `' */ 941);
    } else {

        if (interaction == ERRORSTOPMODE)
            ;
        if (filelineerrorstylep)
            printfileline();
        else
            printnl(/* str '! ' */ 264);
        print(/* str 'I can't write on file `' */ 942);
    }
    printfilename(curname, curarea, curext);
    print(/* str ''.' */ 943);
    if ((e == /* str '.tex' */ 944) || (e == /* str '' */ 345))
        showcontext();
    println();
    printcstring(promptfilenamehelpmsg);
    if ((e != /* str '' */ 345)) {
        print(/* str '; default file extension is `' */ 945);
        print(e);
        print(/* str ''' */ 39);
    }
    print(/* str ')' */ 41);
    println();
    printnl(/* str 'Please type another ' */ 946);
    print(s);
    if (interaction < SCROLLMODE)
        fatalerror(/* str ' (job aborted, file error in nonstop mode)' */ 947);
    savedcurname = curname;
    savedcurext = curext;
    savedcurarea = curarea;
    {
        ;
        print(/* str '' */ 651);
        terminput();
    }
    /* comment:Scan file name in the buffer */ {

        beginname();
        k = first;
        while ((buffer[k] == /* str ' ' */ 32) && (k < last))
            incr(k);
        while (true) {

            if (k == last)
                goto labpromptfilename30done;
            if (!morename(buffer[k]))
                goto labpromptfilename30done;
            incr(k);
        }
    labpromptfilename30done:
        endname();
    }
    if (((strstart[curname + 1] - strstart[curname]) == 0) &&
        (curext == /* str '' */ 345) && (curarea == /* str '' */ 345)) {
        curname = savedcurname;
        curext = savedcurext;
        curarea = savedcurarea;
    } else if (curext == /* str '' */ 345)
        curext = e;
    packfilename(curname, curarea, curext);
}
void openlogfile(void) {
    openlogfile_regmem
     unsigned char oldsetting;
    integer k;
    integer l;
    constcstring months;
    oldsetting = selector;
    if (jobname == 0)
        jobname = getjobname(/* str 'texput' */ 950);
    packjobname(/* str '.fls' */ 951);
    recorderchangefilename(stringcast(nameoffile + 1));
    packjobname(/* str '.log' */ 952);
    while (
        !aopenout(logfile)) /* comment:Try to get a different log file name */ {

        selector = TERMONLY;
        promptfilename(/* str 'transcript file name' */ 954,
                       /* str '.log' */ 952);
    }
    texmflogname = amakenamestring(logfile);
    selector = LOGONLY;
    logopened = true;
    /* comment:Print the banner line, including the date and time */ {

        if (srcspecialsp || filelineerrorstylep || parsefirstlinep)
            fprintf(logfile, "%s%s%s", "This is pdfTeX, Version 3.14159265",
                    "-2.6", "-1.40.20");
        else
            fprintf(logfile, "%s%s%s", "This is pdfTeX, Version 3.14159265",
                    "-2.6", "-1.40.20");
        Fputs(logfile, versionstring);
        slowprint(formatident);
        print(/* str '  ' */ 955);
        printint(eqtb[INTBASE + DAYCODE].cint);
        printchar(/* str ' ' */ 32);
        months = " JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC";
        {
            register integer for_end;
            k = 3 * eqtb[INTBASE + MONTHCODE].cint - 2;
            for_end = 3 * eqtb[INTBASE + MONTHCODE].cint;
            if (k <= for_end)
                do
                    putc(months[k], logfile);
                while (k++ < for_end);
        }
        printchar(/* str ' ' */ 32);
        printint(eqtb[INTBASE + YEARCODE].cint);
        printchar(/* str ' ' */ 32);
        printtwo(eqtb[INTBASE + TIMECODE].cint / 60);
        printchar(/* str '' */ 58);
        printtwo(eqtb[INTBASE + TIMECODE].cint % 60);
        if ((eTeXmode == 1)) {
            ;
            putc('\n', logfile);
            Fputs(logfile, "entering extended mode");
        }
        if (shellenabledp) {
            putc('\n', logfile);
            putc(' ', logfile);
            if (restrictedshell) {
                Fputs(logfile, "restricted ");
            }
            Fputs(logfile, "\\write18 enabled.");
        }
        if (srcspecialsp) {
            putc('\n', logfile);
            Fputs(logfile, " Source specials enabled.");
        }
        if (filelineerrorstylep) {
            putc('\n', logfile);
            Fputs(logfile, " file:line:error style messages enabled.");
        }
        if (parsefirstlinep) {
            putc('\n', logfile);
            Fputs(logfile, " %&-line parsing enabled.");
        }
        if (translatefilename) {
            putc('\n', logfile);
            Fputs(logfile, " (");
            fputs(translatefilename, logfile);
            putc(')', logfile);
        }
    }
    if (mltexenabledp) {
        putc('\n', logfile);
        Fputs(logfile, "MLTeX v2.2 enabled");
    }
    if (enctexenabledp) {
        putc('\n', logfile);
        Fputs(logfile, " encTeX v. Jun. 2004");
        Fputs(logfile, ", reencoding enabled");
        if (translatefilename) {
            putc('\n', logfile);
            Fputs(logfile,
                  " (\\xordcode, \\xchrcode, \\xprncode overridden by TCX)");
        }
    }
    inputstack[inputptr] = curinput;
    printnl(/* str '' */ 953);
    l = inputstack[0].limitfield;
    if (buffer[l] == eqtb[INTBASE + ENDLINECHARCODE].cint)
        decr(l);
    {
        register integer for_end;
        k = 1;
        for_end = l;
        if (k <= for_end)
            do
                print(buffer[k]);
            while (k++ < for_end);
    }
    println();
    selector = oldsetting + 2;
}
void startinput(void) {
    startinput_regmem strnumber tempstr;
    scanfilename();
    packfilename(curname, curarea, curext);
    while (true) {

        beginfilereading();
        texinputtype = 1;
        if (kpseinnameok(stringcast(nameoffile + 1)) &&
            aopenin(inputfile[curinput.indexfield], kpsetexformat))
            goto labstartinput30done;
        endfilereading();
        promptfilename(/* str 'input file name' */ 940, /* str '' */ 345);
    }
labstartinput30done:
    curinput.namefield = amakenamestring(inputfile[curinput.indexfield]);
    sourcefilenamestack[inopen] = curinput.namefield;
    fullsourcefilenamestack[inopen] = makefullnamestring();
    if (curinput.namefield == strptr - 1) {
        tempstr = searchstring(curinput.namefield);
        if (tempstr > 0) {
            curinput.namefield = tempstr;
            {
                decr(strptr);
                poolptr = strstart[strptr];
            }
        }
    }
    if (jobname == 0) {
        jobname = getjobname(curname);
        openlogfile();
    }
    if (termoffset + (strstart[fullsourcefilenamestack[inopen] + 1] -
                      strstart[fullsourcefilenamestack[inopen]]) >
        maxprintline - 2)
        println();
    else if ((termoffset > 0) || (fileoffset > 0))
        printchar(/* str ' ' */ 32);
    printchar(/* str '(' */ 40);
    incr(openparens);
    slowprint(fullsourcefilenamestack[inopen]);
    fflush(stdout);
    curinput.statefield = NEWLINE;
    /* comment:Read the first line of the new file */ {

        line = 1;
        if (inputln(inputfile[curinput.indexfield], false))
            ;
        firmuptheline();
        if ((eqtb[INTBASE + ENDLINECHARCODE].cint < 0) ||
            (eqtb[INTBASE + ENDLINECHARCODE].cint > 255))
            decr(curinput.limitfield);
        else
            buffer[curinput.limitfield] = eqtb[INTBASE + ENDLINECHARCODE].cint;
        first = curinput.limitfield + 1;
        curinput.locfield = curinput.startfield;
    }
}
/* comment:Declare additional functions for ML\TeX */ fourquarters
zeffectivecharinfo(internalfontnumber f, quarterword c) {
    register fourquarters Result;
    effectivecharinfo_regmem fourquarters ci;
    integer basec;
    if (!mltexenabledp) {
        Result = fontinfo[charbase[f] + c].qqqq;
        return Result;
    }
    if (fontec[f] >= c) {

        if (fontbc[f] <= c) {
            ci = fontinfo[charbase[f] + c].qqqq;
            if ((ci.b0 > MINQUARTERWORD)) {
                Result = ci;
                return Result;
            }
        }
    }
    if (c >= eqtb[INTBASE + CHARSUBDEFMINCODE].cint) {

        if (c <= eqtb[INTBASE + CHARSUBDEFMAXCODE].cint) {

            if ((eqtb[CHARSUBCODEBASE + c].hh.v.RH > 0)) {
                basec = (eqtb[CHARSUBCODEBASE + c].hh.v.RH % 256);
                if (fontec[f] >= basec) {

                    if (fontbc[f] <= basec) {
                        ci = fontinfo[charbase[f] + basec].qqqq;
                        if ((ci.b0 > MINQUARTERWORD)) {
                            Result = ci;
                            return Result;
                        }
                    }
                }
            }
        }
    }
    Result = nullcharacter;
    return Result;
}
internalfontnumber zreadfontinfo(halfword u, strnumber nom, strnumber aire,
                                 scaled s) {
    register internalfontnumber
        Result;
    readfontinfo_regmem fontindex k;
    boolean nametoolong;
    boolean fileopened;
    halfword lf, lh, bc, ec, nw, nh, nd, ni, nl, nk, ne, np;
    internalfontnumber f;
    internalfontnumber g;
    eightbits a, b, c, d;
    fourquarters qw;
    scaled sw;
    integer bchlabel;
    short bchar;
    scaled z;
    integer alpha;
    unsigned char beta;
    g = FONTBASE;
    /* comment:Read and check the font data; |abort| if the \.{TF */
    /* comment:Open |tfm_file| for input */ fileopened = false;
    nametoolong = ((strstart[nom + 1] - strstart[nom]) > 255) ||
                  ((strstart[aire + 1] - strstart[aire]) > 255);
    if (nametoolong)
        goto labreadfontinfo11bad_tfm;
    packfilename(nom, aire, /* str '' */ 345);
    if (!bopenin(tfmfile))
        goto labreadfontinfo11bad_tfm;
    fileopened = true;
    /* comment:Read the {\.{TFM}} size fields */ {

        {
            lf = tfmtemp;
            if (lf > 127)
                goto labreadfontinfo11bad_tfm;
            tfmtemp = getc(tfmfile);
            lf = lf * 256 + tfmtemp;
        }
        tfmtemp = getc(tfmfile);
        {
            lh = tfmtemp;
            if (lh > 127)
                goto labreadfontinfo11bad_tfm;
            tfmtemp = getc(tfmfile);
            lh = lh * 256 + tfmtemp;
        }
        tfmtemp = getc(tfmfile);
        {
            bc = tfmtemp;
            if (bc > 127)
                goto labreadfontinfo11bad_tfm;
            tfmtemp = getc(tfmfile);
            bc = bc * 256 + tfmtemp;
        }
        tfmtemp = getc(tfmfile);
        {
            ec = tfmtemp;
            if (ec > 127)
                goto labreadfontinfo11bad_tfm;
            tfmtemp = getc(tfmfile);
            ec = ec * 256 + tfmtemp;
        }
        if ((bc > ec + 1) || (ec > 255))
            goto labreadfontinfo11bad_tfm;
        if (bc > 255) {
            bc = 1;
            ec = 0;
        }
        tfmtemp = getc(tfmfile);
        {
            nw = tfmtemp;
            if (nw > 127)
                goto labreadfontinfo11bad_tfm;
            tfmtemp = getc(tfmfile);
            nw = nw * 256 + tfmtemp;
        }
        tfmtemp = getc(tfmfile);
        {
            nh = tfmtemp;
            if (nh > 127)
                goto labreadfontinfo11bad_tfm;
            tfmtemp = getc(tfmfile);
            nh = nh * 256 + tfmtemp;
        }
        tfmtemp = getc(tfmfile);
        {
            nd = tfmtemp;
            if (nd > 127)
                goto labreadfontinfo11bad_tfm;
            tfmtemp = getc(tfmfile);
            nd = nd * 256 + tfmtemp;
        }
        tfmtemp = getc(tfmfile);
        {
            ni = tfmtemp;
            if (ni > 127)
                goto labreadfontinfo11bad_tfm;
            tfmtemp = getc(tfmfile);
            ni = ni * 256 + tfmtemp;
        }
        tfmtemp = getc(tfmfile);
        {
            nl = tfmtemp;
            if (nl > 127)
                goto labreadfontinfo11bad_tfm;
            tfmtemp = getc(tfmfile);
            nl = nl * 256 + tfmtemp;
        }
        tfmtemp = getc(tfmfile);
        {
            nk = tfmtemp;
            if (nk > 127)
                goto labreadfontinfo11bad_tfm;
            tfmtemp = getc(tfmfile);
            nk = nk * 256 + tfmtemp;
        }
        tfmtemp = getc(tfmfile);
        {
            ne = tfmtemp;
            if (ne > 127)
                goto labreadfontinfo11bad_tfm;
            tfmtemp = getc(tfmfile);
            ne = ne * 256 + tfmtemp;
        }
        tfmtemp = getc(tfmfile);
        {
            np = tfmtemp;
            if (np > 127)
                goto labreadfontinfo11bad_tfm;
            tfmtemp = getc(tfmfile);
            np = np * 256 + tfmtemp;
        }
        if (lf !=
            6 + lh + (ec - bc + 1) + nw + nh + nd + ni + nl + nk + ne + np)
            goto labreadfontinfo11bad_tfm;
        if ((nw == 0) || (nh == 0) || (nd == 0) || (ni == 0))
            goto labreadfontinfo11bad_tfm;
    }
    /* comment:Use size fields to allocate font information */ lf = lf - 6 - lh;
    if (np < 7)
        lf = lf + 7 - np;
    if ((fontptr == fontmax) ||
        (fmemptr + lf > fontmemsize)) /* comment:Apologize for not loading the
                                         font, |goto done| */
    {
        {
            if (interaction == ERRORSTOPMODE)
                ;
            if (filelineerrorstylep)
                printfileline();
            else
                printnl(/* str '! ' */ 264);
            print(/* str 'Font ' */ 957);
        }
        sprintcs(u);
        printchar(/* str '=' */ 61);
        printfilename(nom, aire, /* str '' */ 345);
        if (s >= 0) {
            print(/* str ' at ' */ 895);
            printscaled(s);
            print(/* str 'pt' */ 312);
        } else if (s != -1000) {
            print(/* str ' scaled ' */ 958);
            printint(-(integer)s);
        }
        print(/* str ' not loaded' */ 967);
        {
            helpptr = 4;
            helpline[3] =
                /* str 'I'm afraid I won't be able to make use of this fo' */
                968;
            helpline[2] =
                /* str 'because my memory for character-size data is too ' */
                969;
            helpline[1] =
                /* str 'If you're really stuck, ask a wizard to enlarge m' */
                970;
            helpline[0] =
                /* str 'Or maybe try `I\font<same font id>=<name of loade' */
                971;
        }
        error();
        goto labreadfontinfo30done;
    }
    f = fontptr + 1;
    charbase[f] = fmemptr - bc;
    widthbase[f] = charbase[f] + ec + 1;
    heightbase[f] = widthbase[f] + nw;
    depthbase[f] = heightbase[f] + nh;
    italicbase[f] = depthbase[f] + nd;
    ligkernbase[f] = italicbase[f] + ni;
    kernbase[f] = ligkernbase[f] + nl - 256 * (/* @d6111@ */ 128);
    extenbase[f] = kernbase[f] + 256 * (/* @d6112@ */ 128) + nk;
    parambase[f] = extenbase[f] + ne;
    /* comment:Read the {\.{TFM}} header */ {

        if (lh < 2)
            goto labreadfontinfo11bad_tfm;
        {
            tfmtemp = getc(tfmfile);
            a = tfmtemp;
            qw.b0 = a;
            tfmtemp = getc(tfmfile);
            b = tfmtemp;
            qw.b1 = b;
            tfmtemp = getc(tfmfile);
            c = tfmtemp;
            qw.b2 = c;
            tfmtemp = getc(tfmfile);
            d = tfmtemp;
            qw.b3 = d;
            fontcheck[f] = qw;
        }
        tfmtemp = getc(tfmfile);
        {
            z = tfmtemp;
            if (z > 127)
                goto labreadfontinfo11bad_tfm;
            tfmtemp = getc(tfmfile);
            z = z * 256 + tfmtemp;
        }
        tfmtemp = getc(tfmfile);
        z = z * 256 + tfmtemp;
        tfmtemp = getc(tfmfile);
        z = (z * 16) + (tfmtemp / 16);
        if (z < 65536L)
            goto labreadfontinfo11bad_tfm;
        while (lh > 2) {

            tfmtemp = getc(tfmfile);
            tfmtemp = getc(tfmfile);
            tfmtemp = getc(tfmfile);
            tfmtemp = getc(tfmfile);
            decr(lh);
        }
        fontdsize[f] = z;
        if (s != -1000) {

            if (s >= 0)
                z = s;
            else
                z = xnoverd(z, -(integer)s, 1000);
        }
        fontsize[f] = z;
    }
    /* comment:Read character data */ {
        register integer for_end;
        k = fmemptr;
        for_end = widthbase[f] - 1;
        if (k <= for_end)
            do {
                {
                    tfmtemp = getc(tfmfile);
                    a = tfmtemp;
                    qw.b0 = a;
                    tfmtemp = getc(tfmfile);
                    b = tfmtemp;
                    qw.b1 = b;
                    tfmtemp = getc(tfmfile);
                    c = tfmtemp;
                    qw.b2 = c;
                    tfmtemp = getc(tfmfile);
                    d = tfmtemp;
                    qw.b3 = d;
                    fontinfo[k].qqqq = qw;
                }
                if ((a >= nw) || (b / 16 >= nh) || (b % 16 >= nd) ||
                    (c / 4 >= ni))
                    goto labreadfontinfo11bad_tfm;
                switch (c % 4) {
                case LIGTAG:
                    if (d >= nl)
                        goto labreadfontinfo11bad_tfm;
                    break;
                case EXTTAG:
                    if (d >= ne)
                        goto labreadfontinfo11bad_tfm;
                    break;
                case LISTTAG:
                    /* comment:Check for charlist cycle */ {

                        {
                            if ((d < bc) || (d > ec))
                                goto labreadfontinfo11bad_tfm;
                        }
                        while (d < k + bc - fmemptr) {

                            qw = fontinfo[charbase[f] + d].qqqq;
                            if (((qw.b2) % 4) != LISTTAG)
                                goto labreadfontinfo45not_found;
                            d = qw.b3;
                        }
                        if (d == k + bc - fmemptr)
                            goto labreadfontinfo11bad_tfm;
                    labreadfontinfo45not_found:;
                    }
                    break;
                default:;
                    break;
                }
            } while (k++ < for_end);
    }
    /* comment:Read box dimensions */ {

        /* comment:Replace |z| by $|z|^\prime$ and compute $\alpha,\b */ {

            alpha = 16;
            if (z >= 134217728L)
                pdferror(/* str 'font' */ 595,
                         /* str 'size is too large' */ 972);
            while (z >= 8388608L) {

                z = z / 2;
                alpha = alpha + alpha;
            }
            beta = 256 / alpha;
            alpha = alpha * z;
        }
        {
            register integer for_end;
            k = widthbase[f];
            for_end = ligkernbase[f] - 1;
            if (k <= for_end)
                do {
                    tfmtemp = getc(tfmfile);
                    a = tfmtemp;
                    tfmtemp = getc(tfmfile);
                    b = tfmtemp;
                    tfmtemp = getc(tfmfile);
                    c = tfmtemp;
                    tfmtemp = getc(tfmfile);
                    d = tfmtemp;
                    sw = (((((d * z) / 256) + (c * z)) / 256) + (b * z)) / beta;
                    if (a == 0)
                        fontinfo[k].cint = sw;
                    else if (a == 255)
                        fontinfo[k].cint = sw - alpha;
                    else
                        goto labreadfontinfo11bad_tfm;
                } while (k++ < for_end);
        }
        if (fontinfo[widthbase[f]].cint != 0)
            goto labreadfontinfo11bad_tfm;
        if (fontinfo[heightbase[f]].cint != 0)
            goto labreadfontinfo11bad_tfm;
        if (fontinfo[depthbase[f]].cint != 0)
            goto labreadfontinfo11bad_tfm;
        if (fontinfo[italicbase[f]].cint != 0)
            goto labreadfontinfo11bad_tfm;
    }
    /* comment:Read ligaturekern program */ bchlabel = 32767;
    bchar = 256;
    if (nl > 0) {
        {
            register integer for_end;
            k = ligkernbase[f];
            for_end = kernbase[f] + 256 * (/* @d6140@ */ 128) - 1;
            if (k <= for_end)
                do {
                    {
                        tfmtemp = getc(tfmfile);
                        a = tfmtemp;
                        qw.b0 = a;
                        tfmtemp = getc(tfmfile);
                        b = tfmtemp;
                        qw.b1 = b;
                        tfmtemp = getc(tfmfile);
                        c = tfmtemp;
                        qw.b2 = c;
                        tfmtemp = getc(tfmfile);
                        d = tfmtemp;
                        qw.b3 = d;
                        fontinfo[k].qqqq = qw;
                    }
                    if (a > 128) {
                        if (256 * c + d >= nl)
                            goto labreadfontinfo11bad_tfm;
                        if (a == 255) {

                            if (k == ligkernbase[f])
                                bchar = b;
                        }
                    } else {

                        if (b != bchar) {
                            {
                                if ((b < bc) || (b > ec))
                                    goto labreadfontinfo11bad_tfm;
                            }
                            qw = fontinfo[charbase[f] + b].qqqq;
                            if (!(qw.b0 > MINQUARTERWORD))
                                goto labreadfontinfo11bad_tfm;
                        }
                        if (c < 128) {
                            {
                                if ((d < bc) || (d > ec))
                                    goto labreadfontinfo11bad_tfm;
                            }
                            qw = fontinfo[charbase[f] + d].qqqq;
                            if (!(qw.b0 > MINQUARTERWORD))
                                goto labreadfontinfo11bad_tfm;
                        } else if (256 * (c - 128) + d >= nk)
                            goto labreadfontinfo11bad_tfm;
                        if (a < 128) {

                            if (k - ligkernbase[f] + a + 1 >= nl)
                                goto labreadfontinfo11bad_tfm;
                        }
                    }
                } while (k++ < for_end);
        }
        if (a == 255)
            bchlabel = 256 * c + d;
    }
    {
        register integer for_end;
        k = kernbase[f] + 256 * (/* @d6150@ */ 128);
        for_end = extenbase[f] - 1;
        if (k <= for_end)
            do {
                tfmtemp = getc(tfmfile);
                a = tfmtemp;
                tfmtemp = getc(tfmfile);
                b = tfmtemp;
                tfmtemp = getc(tfmfile);
                c = tfmtemp;
                tfmtemp = getc(tfmfile);
                d = tfmtemp;
                sw = (((((d * z) / 256) + (c * z)) / 256) + (b * z)) / beta;
                if (a == 0)
                    fontinfo[k].cint = sw;
                else if (a == 255)
                    fontinfo[k].cint = sw - alpha;
                else
                    goto labreadfontinfo11bad_tfm;
            } while (k++ < for_end);
    }
    /* comment:Read extensible character recipes */ {
        register integer for_end;
        k = extenbase[f];
        for_end = parambase[f] - 1;
        if (k <= for_end)
            do {
                {
                    tfmtemp = getc(tfmfile);
                    a = tfmtemp;
                    qw.b0 = a;
                    tfmtemp = getc(tfmfile);
                    b = tfmtemp;
                    qw.b1 = b;
                    tfmtemp = getc(tfmfile);
                    c = tfmtemp;
                    qw.b2 = c;
                    tfmtemp = getc(tfmfile);
                    d = tfmtemp;
                    qw.b3 = d;
                    fontinfo[k].qqqq = qw;
                }
                if (a != 0) {
                    {
                        if ((a < bc) || (a > ec))
                            goto labreadfontinfo11bad_tfm;
                    }
                    qw = fontinfo[charbase[f] + a].qqqq;
                    if (!(qw.b0 > MINQUARTERWORD))
                        goto labreadfontinfo11bad_tfm;
                }
                if (b != 0) {
                    {
                        if ((b < bc) || (b > ec))
                            goto labreadfontinfo11bad_tfm;
                    }
                    qw = fontinfo[charbase[f] + b].qqqq;
                    if (!(qw.b0 > MINQUARTERWORD))
                        goto labreadfontinfo11bad_tfm;
                }
                if (c != 0) {
                    {
                        if ((c < bc) || (c > ec))
                            goto labreadfontinfo11bad_tfm;
                    }
                    qw = fontinfo[charbase[f] + c].qqqq;
                    if (!(qw.b0 > MINQUARTERWORD))
                        goto labreadfontinfo11bad_tfm;
                }
                {
                    {
                        if ((d < bc) || (d > ec))
                            goto labreadfontinfo11bad_tfm;
                    }
                    qw = fontinfo[charbase[f] + d].qqqq;
                    if (!(qw.b0 > MINQUARTERWORD))
                        goto labreadfontinfo11bad_tfm;
                }
            } while (k++ < for_end);
    }
    /* comment:Read font parameters */ {

        {
            register integer for_end;
            k = 1;
            for_end = np;
            if (k <= for_end)
                do
                    if (k == 1) {
                        tfmtemp = getc(tfmfile);
                        sw = tfmtemp;
                        if (sw > 127)
                            sw = sw - 256;
                        tfmtemp = getc(tfmfile);
                        sw = sw * 256 + tfmtemp;
                        tfmtemp = getc(tfmfile);
                        sw = sw * 256 + tfmtemp;
                        tfmtemp = getc(tfmfile);
                        fontinfo[parambase[f]].cint =
                            (sw * 16) + (tfmtemp / 16);
                    } else {

                        tfmtemp = getc(tfmfile);
                        a = tfmtemp;
                        tfmtemp = getc(tfmfile);
                        b = tfmtemp;
                        tfmtemp = getc(tfmfile);
                        c = tfmtemp;
                        tfmtemp = getc(tfmfile);
                        d = tfmtemp;
                        sw = (((((d * z) / 256) + (c * z)) / 256) + (b * z)) /
                             beta;
                        if (a == 0)
                            fontinfo[parambase[f] + k - 1].cint = sw;
                        else if (a == 255)
                            fontinfo[parambase[f] + k - 1].cint = sw - alpha;
                        else
                            goto labreadfontinfo11bad_tfm;
                    }
                while (k++ < for_end);
        }
        if (feof(tfmfile))
            goto labreadfontinfo11bad_tfm;
        {
            register integer for_end;
            k = np + 1;
            for_end = 7;
            if (k <= for_end)
                do
                    fontinfo[parambase[f] + k - 1].cint = 0;
                while (k++ < for_end);
        }
    }
    /* comment:Make final adjustments and |goto done| */ if (np >= 7)
        fontparams[f] = np;
    else
        fontparams[f] = 7;
    hyphenchar[f] = eqtb[INTBASE + DEFAULTHYPHENCHARCODE].cint;
    skewchar[f] = eqtb[INTBASE + DEFAULTSKEWCHARCODE].cint;
    if (bchlabel < nl)
        bcharlabel[f] = bchlabel + ligkernbase[f];
    else
        bcharlabel[f] = NONADDRESS;
    fontbchar[f] = bchar;
    fontfalsebchar[f] = bchar;
    if (bchar <= ec) {

        if (bchar >= bc) {
            qw = fontinfo[charbase[f] + bchar].qqqq;
            if ((qw.b0 > MINQUARTERWORD))
                fontfalsebchar[f] = 256;
        }
    }
    fontname[f] = nom;
    fontarea[f] = aire;
    fontbc[f] = bc;
    fontec[f] = ec;
    fontglue[f] = TEXNULL;
    charbase[f] = charbase[f];
    widthbase[f] = widthbase[f];
    ligkernbase[f] = ligkernbase[f];
    kernbase[f] = kernbase[f];
    extenbase[f] = extenbase[f];
    decr(parambase[f]);
    fmemptr = fmemptr + lf;
    fontptr = f;
    g = f;
    goto labreadfontinfo30done;
labreadfontinfo11bad_tfm : /* comment:Report that the font won't be loaded */ {

    if (interaction == ERRORSTOPMODE)
        ;
    if (filelineerrorstylep)
        printfileline();
    else
        printnl(/* str '! ' */ 264);
    print(/* str 'Font ' */ 957);
}
    sprintcs(u);
    printchar(/* str '=' */ 61);
    printfilename(nom, aire, /* str '' */ 345);
    if (s >= 0) {
        print(/* str ' at ' */ 895);
        printscaled(s);
        print(/* str 'pt' */ 312);
    } else if (s != -1000) {
        print(/* str ' scaled ' */ 958);
        printint(-(integer)s);
    }
    if (fileopened)
        print(/* str ' not loadable' */ 959);
    else if (nametoolong)
        print(/* str ' not loadable' */ 960);
    else
        print(/* str ' not loadable' */ 961);
    {
        helpptr = 5;
        helpline[4] =
            /* str 'I wasn't able to read the size data for this font' */ 962;
        helpline[3] = /* str 'so I will ignore the font specification.' */ 963;
        helpline[2] =
            /* str '[Wizards can fix TFM files using TFtoPLPLtoTF.]' */ 964;
        helpline[1] =
            /* str 'You might try inserting a different font spec;' */ 965;
        helpline[0] =
            /* str 'e.g., type `I\font<same font id>=<substitute font' */ 966;
    }
    error();
labreadfontinfo30done:
    if (fileopened)
        bclose(tfmfile);
    Result = g;
    return Result;
}
scaled zstorescaledf(scaled sq, scaled z) {
    register scaled Result;
    storescaledf_regmem eightbits a, b, c, d;
    scaled sw;
    integer alpha;
    unsigned char beta;
    alpha = 16;
    if (z >= 134217728L)
        pdferror(/* str 'font' */ 595, /* str 'size is too large' */ 972);
    while (z >= 8388608L) {

        z = z / 2;
        alpha = alpha + alpha;
    }
    beta = 256 / alpha;
    alpha = alpha * z;
    if (sq >= 0) {
        d = sq % 256;
        sq = sq / 256;
        c = sq % 256;
        sq = sq / 256;
        b = sq % 256;
        sq = sq / 256;
        a = sq % 256;
    } else {

        sq = (sq + 1073741824L) + 1073741824L;
        d = sq % 256;
        sq = sq / 256;
        c = sq % 256;
        sq = sq / 256;
        b = sq % 256;
        sq = sq / 256;
        a = (sq + 128) % 256;
    }
    sw = (((((d * z) / 256) + (c * z)) / 256) + (b * z)) / beta;
    if (a == 0)
        Result = sw;
    else if (a == 255)
        Result = sw - alpha;
    else
        pdferror(/* str 'store_scaled_f' */ 973, /* str 'vf scaling' */ 974);
    return Result;
}
void zcharwarning(internalfontnumber f, eightbits c) {
    charwarning_regmem integer oldsetting;
    if (eqtb[INTBASE + TRACINGLOSTCHARSCODE].cint > 0) {
        oldsetting = eqtb[INTBASE + TRACINGONLINECODE].cint;
        if ((eTeXmode == 1) && (eqtb[INTBASE + TRACINGLOSTCHARSCODE].cint > 1))
            eqtb[INTBASE + TRACINGONLINECODE].cint = 1;
        {
            begindiagnostic();
            printnl(/* str 'Missing character' */ 983);
            print(c);
            print(/* str ' in font ' */ 984);
            slowprint(fontname[f]);
            printchar(/* str '!' */ 33);
            enddiagnostic(false);
        }
        eqtb[INTBASE + TRACINGONLINECODE].cint = oldsetting;
    }
}
halfword znewcharacter(internalfontnumber f, eightbits c) {
    register halfword Result;
    newcharacter_regmem halfword p;
    quarterword ec;
    ec = effectivechar(false, f, c);
    if (fontbc[f] <= ec) {

        if (fontec[f] >= ec) {

            if ((fontinfo[charbase[f] + ec].qqqq.b0 > MINQUARTERWORD)) {
                p = getavail();
                mem[p].hh.b0 = f;
                mem[p].hh.b1 = c;
                Result = p;
                return Result;
            }
        }
    }
    charwarning(f, c);
    Result = TEXNULL;
    return Result;
}
void dviswap(void) {
    dviswap_regmem if (dviptr > (2147483647L - dvioffset)) {
        curs = -2;
        fatalerror(/* str 'dvi length exceeds ""7FFFFFFF' */ 985);
    }
    if (dvilimit == dvibufsize) {
        writedvi(0, halfbuf - 1);
        dvilimit = halfbuf;
        dvioffset = dvioffset + dvibufsize;
        dviptr = 0;
    } else {

        writedvi(halfbuf, dvibufsize - 1);
        dvilimit = dvibufsize;
    }
    dvigone = dvigone + halfbuf;
}
void zdvifour(integer x) {
    dvifour_regmem if (x >= 0) {
        dvibuf[dviptr] = x / 16777216L;
        incr(dviptr);
        if (dviptr == dvilimit)
            dviswap();
    }
    else {

        x = x + 1073741824L;
        x = x + 1073741824L;
        {
            dvibuf[dviptr] = (x / 16777216L) + 128;
            incr(dviptr);
            if (dviptr == dvilimit)
                dviswap();
        }
    }
    x = x % 16777216L;
    {
        dvibuf[dviptr] = x / 65536L;
        incr(dviptr);
        if (dviptr == dvilimit)
            dviswap();
    }
    x = x % 65536L;
    {
        dvibuf[dviptr] = x / 256;
        incr(dviptr);
        if (dviptr == dvilimit)
            dviswap();
    }
    {
        dvibuf[dviptr] = x % 256;
        incr(dviptr);
        if (dviptr == dvilimit)
            dviswap();
    }
}
void zdvipop(integer l) {
    dvipop_regmem if ((l == dvioffset + dviptr) && (dviptr > 0)) decr(dviptr);
    else {

        dvibuf[dviptr] = POP;
        incr(dviptr);
        if (dviptr == dvilimit)
            dviswap();
    }
}
void zdvifontdef(internalfontnumber f) {
    dvifontdef_regmem poolpointer k;
    if (f <= /* @d6218@ */ 256) {
        {
            dvibuf[dviptr] = FNTDEF1;
            incr(dviptr);
            if (dviptr == dvilimit)
                dviswap();
        }
        {
            dvibuf[dviptr] = /* @d6220@ */ f - 1;
            incr(dviptr);
            if (dviptr == dvilimit)
                dviswap();
        }
    } else {

        {
            dvibuf[dviptr] = /* @d6221@ */ 244;
            incr(dviptr);
            if (dviptr == dvilimit)
                dviswap();
        }
        {
            dvibuf[dviptr] = (/* @d6222@ */ f - 1) / 256;
            incr(dviptr);
            if (dviptr == dvilimit)
                dviswap();
        }
        {
            dvibuf[dviptr] = (/* @d6223@ */ f - 1) % 256;
            incr(dviptr);
            if (dviptr == dvilimit)
                dviswap();
        }
    }
    {
        dvibuf[dviptr] = fontcheck[f].b0;
        incr(dviptr);
        if (dviptr == dvilimit)
            dviswap();
    }
    {
        dvibuf[dviptr] = fontcheck[f].b1;
        incr(dviptr);
        if (dviptr == dvilimit)
            dviswap();
    }
    {
        dvibuf[dviptr] = fontcheck[f].b2;
        incr(dviptr);
        if (dviptr == dvilimit)
            dviswap();
    }
    {
        dvibuf[dviptr] = fontcheck[f].b3;
        incr(dviptr);
        if (dviptr == dvilimit)
            dviswap();
    }
    dvifour(fontsize[f]);
    dvifour(fontdsize[f]);
    {
        dvibuf[dviptr] = (strstart[fontarea[f] + 1] - strstart[fontarea[f]]);
        incr(dviptr);
        if (dviptr == dvilimit)
            dviswap();
    }
    {
        dvibuf[dviptr] = (strstart[fontname[f] + 1] - strstart[fontname[f]]);
        incr(dviptr);
        if (dviptr == dvilimit)
            dviswap();
    }
    /* comment:Output the font name whose internal number is |f| */ {
        register integer for_end;
        k = strstart[fontarea[f]];
        for_end = strstart[fontarea[f] + 1] - 1;
        if (k <= for_end)
            do {
                dvibuf[dviptr] = strpool[k];
                incr(dviptr);
                if (dviptr == dvilimit)
                    dviswap();
            } while (k++ < for_end);
    }
    {
        register integer for_end;
        k = strstart[fontname[f]];
        for_end = strstart[fontname[f] + 1] - 1;
        if (k <= for_end)
            do {
                dvibuf[dviptr] = strpool[k];
                incr(dviptr);
                if (dviptr == dvilimit)
                    dviswap();
            } while (k++ < for_end);
    }
}
void zmovement(scaled w, eightbits o) {
    movement_regmem smallnumber mstate;
    halfword p, q;
    integer k;
    q = getnode(MOVEMENTNODESIZE);
    mem[q + WIDTHOFFSET].cint = w;
    mem[q + 2].cint = dvioffset + dviptr;
    if (o == DOWN1) {
        mem[q].hh.v.RH = downptr;
        downptr = q;
    } else {

        mem[q].hh.v.RH = rightptr;
        rightptr = q;
    }
    /* comment:Look at the other stack entries until deciding wha */ p =
        mem[q].hh.v.RH;
    mstate = NONESEEN;
    while (p != TEXNULL) {

        if (mem[p + WIDTHOFFSET].cint ==
            w) /* comment:Consider a node with matching width; |goto found|  */
            switch (mstate + mem[p].hh.v.LH) {
            case NONESEEN + YZOK:
            case NONESEEN + YOK:
            case ZSEEN + YZOK:
            case ZSEEN + YOK:
                if (mem[p + 2].cint < dvigone)
                    goto labmovement45not_found;
                else /* comment:Change buffered instruction to |y| or |w| and
                        |got */
                {

                    k = mem[p + 2].cint - dvioffset;
                    if (k < 0)
                        k = k + dvibufsize;
                    dvibuf[k] = dvibuf[k] /* @d6245@ */ /* @d6246@ */ + 5;
                    mem[p].hh.v.LH = YHERE;
                    goto labmovement40found;
                }
                break;
            case NONESEEN + ZOK:
            case YSEEN + YZOK:
            case YSEEN + ZOK:
                if (mem[p + 2].cint < dvigone)
                    goto labmovement45not_found;
                else /* comment:Change buffered instruction to |z| or |x| and
                        |got */
                {

                    k = mem[p + 2].cint - dvioffset;
                    if (k < 0)
                        k = k + dvibufsize;
                    dvibuf[k] = dvibuf[k] /* @d6257@ */ /* @d6258@ */ + 10;
                    mem[p].hh.v.LH = ZHERE;
                    goto labmovement40found;
                }
                break;
            case NONESEEN + YHERE:
            case NONESEEN + ZHERE:
            case YSEEN + ZHERE:
            case ZSEEN + YHERE:
                goto labmovement40found;
                break;
            default:;
                break;
            }
        else
            switch (mstate + mem[p].hh.v.LH) {
            case NONESEEN + YHERE:
                mstate = YSEEN;
                break;
            case NONESEEN + ZHERE:
                mstate = ZSEEN;
                break;
            case YSEEN + ZHERE:
            case ZSEEN + YHERE:
                goto labmovement45not_found;
                break;
            default:;
                break;
            }
        p = mem[p].hh.v.RH;
    }
labmovement45not_found:;
    /* comment:Generate a |down| or |right| command for |w| and | */ mem[q]
        .hh.v.LH = YZOK;
    if (abs(w) >= 8388608L) {
        {
            dvibuf[dviptr] = o + 3;
            incr(dviptr);
            if (dviptr == dvilimit)
                dviswap();
        }
        dvifour(w);
        return;
    }
    if (abs(w) >= 32768L) {
        {
            dvibuf[dviptr] = o + 2;
            incr(dviptr);
            if (dviptr == dvilimit)
                dviswap();
        }
        if (w < 0)
            w = w + 16777216L;
        {
            dvibuf[dviptr] = w / 65536L;
            incr(dviptr);
            if (dviptr == dvilimit)
                dviswap();
        }
        w = w % 65536L;
        goto labmovement2;
    }
    if (abs(w) >= 128) {
        {
            dvibuf[dviptr] = o + 1;
            incr(dviptr);
            if (dviptr == dvilimit)
                dviswap();
        }
        if (w < 0)
            w = w + 65536L;
        goto labmovement2;
    }
    {
        dvibuf[dviptr] = o;
        incr(dviptr);
        if (dviptr == dvilimit)
            dviswap();
    }
    if (w < 0)
        w = w + 256;
    goto labmovement1;
labmovement2 : {

    dvibuf[dviptr] = w / 256;
    incr(dviptr);
    if (dviptr == dvilimit)
        dviswap();
}
labmovement1 : {

    dvibuf[dviptr] = w % 256;
    incr(dviptr);
    if (dviptr == dvilimit)
        dviswap();
}
    return;
labmovement40found
    : /* comment:Generate a |y0| or |z0| command in order to reuse  */
    mem[q].hh.v.LH = mem[p].hh.v.LH;
    if (mem[q].hh.v.LH == YHERE) {
        {
            dvibuf[dviptr] = /* @d6289@ */ /* @d6290@ */ o + 4;
            incr(dviptr);
            if (dviptr == dvilimit)
                dviswap();
        }
        while (mem[q].hh.v.RH != p) {

            q = mem[q].hh.v.RH;
            switch (mem[q].hh.v.LH) {
            case YZOK:
                mem[q].hh.v.LH = ZOK;
                break;
            case YOK:
                mem[q].hh.v.LH = DFIXED;
                break;
            default:;
                break;
            }
        }
    } else {

        {
            dvibuf[dviptr] = /* @d6295@ */ /* @d6296@ */ o + 9;
            incr(dviptr);
            if (dviptr == dvilimit)
                dviswap();
        }
        while (mem[q].hh.v.RH != p) {

            q = mem[q].hh.v.RH;
            switch (mem[q].hh.v.LH) {
            case YZOK:
                mem[q].hh.v.LH = YOK;
                break;
            case ZOK:
                mem[q].hh.v.LH = DFIXED;
                break;
            default:;
                break;
            }
        }
    }
}
void zprunemovements(integer l) {
    prunemovements_regmem halfword p;
    while (downptr != TEXNULL) {

        if (mem[downptr + 2].cint < l)
            goto labprunemovements30done;
        p = downptr;
        downptr = mem[p].hh.v.RH;
        freenode(p, MOVEMENTNODESIZE);
    }
labprunemovements30done:
    while (rightptr != TEXNULL) {

        if (mem[rightptr + 2].cint < l)
            return;
        p = rightptr;
        rightptr = mem[p].hh.v.RH;
        freenode(p, MOVEMENTNODESIZE);
    }
}
/* comment:Declare procedures needed in |hlist_out|, |vlist_o */ void
zspecialout(halfword p) {
    specialout_regmem
        unsigned char oldsetting;
    poolpointer k;
    if (curh != dvih) {
        movement(curh - dvih, RIGHT1);
        dvih = curh;
    }
    if (curv != dviv) {
        movement(curv - dviv, DOWN1);
        dviv = curv;
    }
    oldsetting = selector;
    selector = NEWSTRING;
    specsout = eqtb[INTBASE + SPECOUTCODE].cint;
    eqtb[INTBASE + SPECOUTCODE].cint = mem[p + 1].hh.b0 - 64;
    mubytesout = eqtb[INTBASE + MUBYTEOUTCODE].cint;
    eqtb[INTBASE + MUBYTEOUTCODE].cint = mem[p + 1].hh.b1 - 64;
    activenoconvert = true;
    mubyteslog = eqtb[INTBASE + MUBYTELOGCODE].cint;
    eqtb[INTBASE + MUBYTELOGCODE].cint = 0;
    if ((eqtb[INTBASE + MUBYTEOUTCODE].cint > 0) ||
        (eqtb[INTBASE + MUBYTEOUTCODE].cint == -1))
        eqtb[INTBASE + MUBYTELOGCODE].cint = 1;
    if ((eqtb[INTBASE + SPECOUTCODE].cint == 2) ||
        (eqtb[INTBASE + SPECOUTCODE].cint == 3)) {
        if ((eqtb[INTBASE + MUBYTEOUTCODE].cint > 0) ||
            (eqtb[INTBASE + MUBYTEOUTCODE].cint == -1)) {
            specialprinting = true;
            eqtb[INTBASE + MUBYTELOGCODE].cint = 1;
        }
        if (eqtb[INTBASE + MUBYTEOUTCODE].cint > 1)
            csconverting = true;
    }
    showtokenlist(mem[mem[p + 1].hh.v.RH].hh.v.RH, TEXNULL, poolsize - poolptr);
    selector = oldsetting;
    {
        if (poolptr + 1 > poolsize)
            overflow(/* str 'pool size' */ 259, poolsize - initpoolptr);
    }
    if ((poolptr - strstart[strptr]) < 256) {
        {
            dvibuf[dviptr] = XXX1;
            incr(dviptr);
            if (dviptr == dvilimit)
                dviswap();
        }
        {
            dvibuf[dviptr] = (poolptr - strstart[strptr]);
            incr(dviptr);
            if (dviptr == dvilimit)
                dviswap();
        }
    } else {

        {
            dvibuf[dviptr] = XXX4;
            incr(dviptr);
            if (dviptr == dvilimit)
                dviswap();
        }
        dvifour((poolptr - strstart[strptr]));
    }
    if ((eqtb[INTBASE + SPECOUTCODE].cint == 1) ||
        (eqtb[INTBASE + SPECOUTCODE].cint == 3)) {
        register integer for_end;
        k = strstart[strptr];
        for_end = poolptr - 1;
        if (k <= for_end)
            do
                strpool[k] = xchr[strpool[k]];
            while (k++ < for_end);
    }
    {
        register integer for_end;
        k = strstart[strptr];
        for_end = poolptr - 1;
        if (k <= for_end)
            do {
                dvibuf[dviptr] = strpool[k];
                incr(dviptr);
                if (dviptr == dvilimit)
                    dviswap();
            } while (k++ < for_end);
    }
    eqtb[INTBASE + SPECOUTCODE].cint = specsout;
    eqtb[INTBASE + MUBYTEOUTCODE].cint = mubytesout;
    eqtb[INTBASE + MUBYTELOGCODE].cint = mubyteslog;
    specialprinting = false;
    csconverting = false;
    activenoconvert = false;
    poolptr = strstart[strptr];
}
void zwriteout(halfword p) {
    writeout_regmem
        unsigned char oldsetting;
    integer oldmode;
    smallnumber j;
    halfword q, r;
    integer d;
    boolean clobbered;
    integer runsystemret;
    mubytesout = eqtb[INTBASE + MUBYTEOUTCODE].cint;
    eqtb[INTBASE + MUBYTEOUTCODE].cint = mem[p + 1].hh.b1 - 64;
    if ((eqtb[INTBASE + MUBYTEOUTCODE].cint > 2) ||
        (eqtb[INTBASE + MUBYTEOUTCODE].cint == -1) ||
        (eqtb[INTBASE + MUBYTEOUTCODE].cint == -2))
        writenoexpanding = true;
    /* comment:Expand macros in the token list and make |link(def */ q =
        getavail();
    mem[q].hh.v.LH = /* @d6370@ */ /* str '}' */ 637;
    r = getavail();
    mem[q].hh.v.RH = r;
    mem[r].hh.v.LH = /* @d6372@ */ 19617;
    begintokenlist(q, INSERTED);
    begintokenlist(mem[p + 1].hh.v.RH, WRITETEXT);
    q = getavail();
    mem[q].hh.v.LH = /* @d6375@ */ /* str '{' */ 379;
    begintokenlist(q, INSERTED);
    oldmode = curlist.modefield;
    curlist.modefield = 0;
    curcs = writeloc;
    q = scantoks(false, true);
    gettoken();
    if (curtok != /* @d6378@ */ 19617) /* comment:Recover from an unbalanced
                                          write command */
    {
        {
            if (interaction == ERRORSTOPMODE)
                ;
            if (filelineerrorstylep)
                printfileline();
            else
                printnl(/* str '! ' */ 264);
            print(/* str 'Unbalanced write command' */ 1919);
        }
        {
            helpptr = 2;
            helpline[1] =
                /* str 'On this page there's a \write with fewer real {'s' */
                1920;
            helpline[0] =
                /* str 'I can't handle that very well; good luck.' */ 1427;
        }
        error();
        do {
            gettoken();
        } while (!(curtok == /* @d6385@ */ 19617));
    }
    curlist.modefield = oldmode;
    endtokenlist();
    oldsetting = selector;
    j = mem[p + 1].hh.b0;
    if (j == 18)
        selector = NEWSTRING;
    else if (writeopen[j])
        selector = j;
    else {

        if ((j == 17) && (selector == TERMANDLOG))
            selector = LOGONLY;
        printnl(/* str '' */ 345);
    }
    activenoconvert = true;
    if (eqtb[INTBASE + MUBYTEOUTCODE].cint > 1)
        csconverting = true;
    mubyteslog = eqtb[INTBASE + MUBYTELOGCODE].cint;
    if ((eqtb[INTBASE + MUBYTEOUTCODE].cint > 0) ||
        (eqtb[INTBASE + MUBYTEOUTCODE].cint == -1))
        eqtb[INTBASE + MUBYTELOGCODE].cint = 1;
    else
        eqtb[INTBASE + MUBYTELOGCODE].cint = 0;
    tokenshow(defref);
    println();
    csconverting = false;
    writenoexpanding = false;
    activenoconvert = false;
    eqtb[INTBASE + MUBYTEOUTCODE].cint = mubytesout;
    eqtb[INTBASE + MUBYTELOGCODE].cint = mubyteslog;
    flushlist(defref);
    if (j == 18) {
        if ((eqtb[INTBASE + TRACINGONLINECODE].cint <= 0))
            selector = LOGONLY;
        else
            selector = TERMANDLOG;
        if (!logopened)
            selector = TERMONLY;
        printnl(/* str 'runsystem(' */ 1911);
        {
            register integer for_end;
            d = 0;
            for_end = (poolptr - strstart[strptr]) - 1;
            if (d <= for_end)
                do {
                    print(strpool[strstart[strptr] + d]);
                } while (d++ < for_end);
        }
        print(/* str ')...' */ 1912);
        if (shellenabledp) {
            {
                if (poolptr + 1 > poolsize)
                    overflow(/* str 'pool size' */ 259, poolsize - initpoolptr);
            }
            {
                strpool[poolptr] = 0;
                incr(poolptr);
            }
            clobbered = false;
            {
                register integer for_end;
                d = 0;
                for_end = (poolptr - strstart[strptr]) - 1;
                if (d <= for_end)
                    do {
                        strpool[strstart[strptr] + d] =
                            xchr[strpool[strstart[strptr] + d]];
                        if ((strpool[strstart[strptr] + d] == NULLCODE) &&
                            (d < (poolptr - strstart[strptr]) - 1))
                            clobbered = true;
                    } while (d++ < for_end);
            }
            if (clobbered)
                print(/* str 'clobbered' */ 1913);
            else {

                runsystemret = runsystem(
                    conststringcast(addressof(strpool[strstart[strptr]])));
                if (runsystemret == -1)
                    print(/* str 'quotation error in system command' */ 1914);
                else if (runsystemret == 0)
                    print(/* str 'disabled (restricted)' */ 1915);
                else if (runsystemret == 1)
                    print(/* str 'executed' */ 1916);
                else if (runsystemret == 2)
                    print(/* str 'executed safely (allowed)' */ 1917);
            }
        } else {

            print(/* str 'disabled' */ 1918);
        }
        printchar(/* str '.' */ 46);
        printnl(/* str '' */ 345);
        println();
        poolptr = strstart[strptr];
    }
    selector = oldsetting;
}
void zoutwhat(halfword p) {
    outwhat_regmem smallnumber j;
    unsigned char oldsetting;
    switch (mem[p].hh.b1) {
    case OPENNODE:
    case WRITENODE:
    case CLOSENODE:
        /* comment:Do some work that has been queued up for \.{\\writ */
        if (!doingleaders) {
            j = mem[p + 1].hh.b0;
            if (mem[p].hh.b1 == WRITENODE)
                writeout(p);
            else {

                if (writeopen[j])
                    aclose(writefile[j]);
                if (mem[p].hh.b1 == CLOSENODE)
                    writeopen[j] = false;
                else if (j < 16) {
                    curname = mem[p + 1].hh.v.RH;
                    curarea = mem[p + 2].hh.v.LH;
                    curext = mem[p + 2].hh.v.RH;
                    if (curext == /* str '' */ 345)
                        curext = /* str '.tex' */ 944;
                    packfilename(curname, curarea, curext);
                    while (!kpseoutnameok(stringcast(nameoffile + 1)) ||
                           !aopenout(writefile[j]))
                        promptfilename(/* str 'output file name' */ 1922,
                                       /* str '.tex' */ 944);
                    writeopen[j] = true;
                    if (logopened) {
                        oldsetting = selector;
                        if ((eqtb[INTBASE + TRACINGONLINECODE].cint <= 0))
                            selector = LOGONLY;
                        else
                            selector = TERMANDLOG;
                        printnl(/* str '\openout' */ 1923);
                        printint(j);
                        print(/* str ' = `' */ 1924);
                        printfilename(curname, curarea, curext);
                        print(/* str ''.' */ 943);
                        printnl(/* str '' */ 345);
                        println();
                        selector = oldsetting;
                    }
                }
            }
        }
        break;
    case SPECIALNODE:
        specialout(p);
        break;
    case LANGUAGENODE:;
        break;
    case PDFTEXFIRSTEXTENSIONCODE + 15:
        /* comment:Save current position in DVI mode */ {

            pdflastxpos = curh + 4736286L;
            pdflastypos = curpageheight - curv - 4736286L;
        }
        break;
    default: {
        if ((PDFTEXFIRSTEXTENSIONCODE <= mem[p].hh.b1) &&
            (mem[p].hh.b1 <= /* @d6447@ */ 45))
            pdferror(/* str 'ext4' */ 1857,
                     /* str 'pdf node ended up in DVI mode' */ 1921);
        else
            confusion(/* str 'ext4' */ 1857);
    } break;
    }
}
halfword znewedge(smallnumber s, scaled w) {
    register halfword Result;
    newedge_regmem halfword p;
    p = getnode(EDGENODESIZE);
    mem[p].hh.b0 = EDGENODE;
    mem[p].hh.b1 = s;
    mem[p + WIDTHOFFSET].cint = w;
    mem[p + DEPTHOFFSET].cint = 0;
    Result = p;
    return Result;
}
halfword zzreverse(halfword thisbox, halfword t, scaled *curg, real *curglue) {
    register halfword Result;
    reverse_regmem halfword l;
    halfword p;
    halfword q;
    glueord gorder;
    unsigned char gsign;
    real gluetemp;
    halfword m, n;
    gorder = mem[thisbox + LISTOFFSET].hh.b1;
    gsign = mem[thisbox + LISTOFFSET].hh.b0;
    l = t;
    p = tempptr;
    m = TEXNULL;
    n = TEXNULL;
    while (true) {

        while (p != TEXNULL) /* comment:Move node |p| to the new list and go to
                                the next n */
        labreverse21reswitch:
            if ((p >= himemmin))
                do {
                    f = mem[p].hh.b0;
                    c = mem[p].hh.b1;
                    curh = curh + fontinfo[widthbase[f] +
                                           fontinfo[charbase[f] +
                                                    effectivechar(true, f, c)]
                                               .qqqq.b0]
                                      .cint;
                    q = mem[p].hh.v.RH;
                    mem[p].hh.v.RH = l;
                    l = p;
                    p = q;
                } while (!(!(p >= himemmin)));
            else /* comment:Move the non-|char_node| |p| to the new list */ {

                q = mem[p].hh.v.RH;
                switch (mem[p].hh.b0) {
                case HLISTNODE:
                case VLISTNODE:
                case RULENODE:
                case KERNNODE:
                    rulewd = mem[p + WIDTHOFFSET].cint;
                    break;
                /* comment:Cases of |reverse| that need special treatment */
                case GLUENODE: {
                    g = mem[p + 1].hh.v.LH;
                    rulewd = mem[g + WIDTHOFFSET].cint - *curg;
                    if (gsign != NORMAL) {
                        if (gsign == STRETCHING) {
                            if (mem[g].hh.b0 == gorder) {
                                *curglue = *curglue + mem[g + 2].cint;
                                gluetemp =
                                    mem[thisbox + GLUEOFFSET].gr * *curglue;
                                if (gluetemp > 1000000000.0)
                                    gluetemp = 1000000000.0;
                                else if (gluetemp < -1000000000.0)
                                    gluetemp = -1000000000.0;
                                *curg = round(gluetemp);
                            }
                        } else if (mem[g].hh.b1 == gorder) {
                            *curglue = *curglue - mem[g + 3].cint;
                            gluetemp = mem[thisbox + GLUEOFFSET].gr * *curglue;
                            if (gluetemp > 1000000000.0)
                                gluetemp = 1000000000.0;
                            else if (gluetemp < -1000000000.0)
                                gluetemp = -1000000000.0;
                            *curg = round(gluetemp);
                        }
                    }
                    rulewd = rulewd + *curg;
                    /* comment:Handle a glue node for mixed direction
                     * typesetting */
                    if ((((gsign == STRETCHING) && (mem[g].hh.b0 == gorder)) ||
                         ((gsign == SHRINKING) && (mem[g].hh.b1 == gorder)))) {
                        {
                            if (mem[g].hh.v.RH == TEXNULL)
                                freenode(g, GLUESPECSIZE);
                            else
                                decr(mem[g].hh.v.RH);
                        }
                        if (mem[p].hh.b1 < ALEADERS) {
                            mem[p].hh.b0 = KERNNODE;
                            mem[p + WIDTHOFFSET].cint = rulewd;
                        } else {

                            g = getnode(GLUESPECSIZE);
                            mem[g].hh.b0 = /* @d6485@ */ 4;
                            mem[g].hh.b1 = /* @d6486@ */ 4;
                            mem[g + WIDTHOFFSET].cint = rulewd;
                            mem[g + 2].cint = 0;
                            mem[g + 3].cint = 0;
                            mem[p + 1].hh.v.LH = g;
                        }
                    }
                } break;
                case LIGATURENODE: {
                    flushnodelist(mem[p + 1].hh.v.RH);
                    tempptr = p;
                    p = getavail();
                    mem[p] = mem[tempptr + 1];
                    mem[p].hh.v.RH = q;
                    freenode(tempptr, SMALLNODESIZE);
                    goto labreverse21reswitch;
                } break;
                case MATHNODE: {
                    rulewd = mem[p + WIDTHOFFSET].cint;
                    if (odd(mem[p].hh.b1)) {

                        if (mem[LRptr].hh.v.LH !=
                            (LCODE * (mem[p].hh.b1 / LCODE) /* @d6495@ */
                             + 3)) {
                            mem[p].hh.b0 = KERNNODE;
                            incr(LRproblems);
                        } else {

                            {
                                tempptr = LRptr;
                                LRptr = mem[tempptr].hh.v.RH;
                                {
                                    mem[tempptr].hh.v.RH = avail;
                                    avail = tempptr;
                                    mem[tempptr].hh.me = 0;
                                    ;
#ifdef STAT
                                    decr(dynused);
#endif /* STAT */
                                }
                            }
                            if (n > TEXNULL) {
                                decr(n);
                                decr(mem[p].hh.b1);
                            } else {

                                mem[p].hh.b0 = KERNNODE;
                                if (m > TEXNULL)
                                    decr(m);
                                else /* comment:Finish the reversed hlist
                                        segment and |goto done| */
                                {

                                    freenode(p, SMALLNODESIZE);
                                    mem[t].hh.v.RH = q;
                                    mem[t + WIDTHOFFSET].cint = rulewd;
                                    mem[t + DEPTHOFFSET].cint =
                                        -(integer)curh - rulewd;
                                    goto labreverse30done;
                                }
                            }
                        }
                    } else {

                        {
                            tempptr = getavail();
                            mem[tempptr].hh.v.LH =
                                (LCODE * (mem[p].hh.b1 / LCODE) /* @d6505@ */
                                 + 3);
                            mem[tempptr].hh.v.RH = LRptr;
                            LRptr = tempptr;
                        }
                        if ((n > TEXNULL) ||
                            ((mem[p].hh.b1 / RCODE) != curdir)) {
                            incr(n);
                            incr(mem[p].hh.b1);
                        } else {

                            mem[p].hh.b0 = KERNNODE;
                            incr(m);
                        }
                    }
                } break;
                case EDGENODE:
                    confusion(/* str 'LR2' */ 2030);
                    break;
                default:
                    goto labreverse15next_p;
                    break;
                }
                curh = curh + rulewd;
            labreverse15next_p:
                mem[p].hh.v.RH = l;
                if (mem[p].hh.b0 == KERNNODE) {

                    if ((rulewd == 0) || (l == TEXNULL)) {
                        freenode(p, SMALLNODESIZE);
                        p = l;
                    }
                }
                l = p;
                p = q;
            }
        if ((t == TEXNULL) && (m == TEXNULL) && (n == TEXNULL))
            goto labreverse30done;
        p = newmath(0, mem[LRptr].hh.v.LH);
        LRproblems = LRproblems + 10000;
    }
labreverse30done:
    Result = l;
    return Result;
}
void hlistout(void) {
    /* @d6516@ */ /* @d6517@ */ /* @d6518@ */ /* @d6519@ */ /* @d6520@ */
    hlistout_regmem scaled baseline;
    scaled leftedge;
    scaled saveh, savev;
    halfword thisbox;
    glueord gorder;
    unsigned char gsign;
    halfword p;
    integer saveloc;
    halfword leaderbox;
    scaled leaderwd;
    scaled lx;
    boolean outerdoingleaders;
    scaled edge;
    halfword prevp;
    real gluetemp;
    real curglue;
    scaled curg;
    curg = 0;
    curglue = 0.0;
    thisbox = tempptr;
    gorder = mem[thisbox + LISTOFFSET].hh.b1;
    gsign = mem[thisbox + LISTOFFSET].hh.b0;
    p = mem[thisbox + LISTOFFSET].hh.v.RH;
    incr(curs);
    if (curs > 0) {
        dvibuf[dviptr] = PUSH;
        incr(dviptr);
        if (dviptr == dvilimit)
            dviswap();
    }
    if (curs > maxpush)
        maxpush = curs;
    saveloc = dvioffset + dviptr;
    baseline = curv;
    prevp = thisbox + LISTOFFSET;
    /* comment:Initialize |hlist_out| for mixed direction typeset */
    if ((eTeXmode == 1)) {
        /* comment:Initialize the LR stack */ {

            tempptr = getavail();
            mem[tempptr].hh.v.LH = BEFORE;
            mem[tempptr].hh.v.RH = LRptr;
            LRptr = tempptr;
        }
        if ((mem[thisbox].hh.b1) == DLIST) {

            if (curdir == RIGHTTOLEFT) {
                curdir = LEFTTORIGHT;
                curh = curh - mem[thisbox + WIDTHOFFSET].cint;
            } else
                mem[thisbox].hh.b1 = 0;
        }
        if ((curdir == RIGHTTOLEFT) &&
            ((mem[thisbox].hh.b1) !=
             REVERSED)) /* comment:Reverse the complete hlist and set the
                                  subtype to  */
        {
            saveh = curh;
            tempptr = p;
            p = newkern(0);
            mem[prevp].hh.v.RH = p;
            curh = 0;
            mem[p].hh.v.RH = reverse(thisbox, TEXNULL, curg, curglue);
            mem[p + WIDTHOFFSET].cint = -(integer)curh;
            curh = saveh;
            mem[thisbox].hh.b1 = REVERSED;
        }
    }
    leftedge = curh;
    while (p != TEXNULL) /* comment:Output node |p| for |hlist_out| and move to
                            the ne */
    labhlistout21reswitch:
        if ((p >= himemmin)) {
            if (curh != dvih) {
                movement(curh - dvih, RIGHT1);
                dvih = curh;
            }
            if (curv != dviv) {
                movement(curv - dviv, DOWN1);
                dviv = curv;
            }
            do {
                f = mem[p].hh.b0;
                c = mem[p].hh.b1;
                if (f != dvif) /* comment:Change font |dvi_f| to |f| */
                {
                    if (!fontused[f]) {
                        dvifontdef(f);
                        fontused[f] = true;
                    }
                    if (f <= /* @d6546@ */ 64) {
                        dvibuf[dviptr] = /* @d6547@ */ /* @d6548@ */ f + 170;
                        incr(dviptr);
                        if (dviptr == dvilimit)
                            dviswap();
                    } else if (f <= /* @d6549@ */ 256) {
                        {
                            dvibuf[dviptr] = FNT1;
                            incr(dviptr);
                            if (dviptr == dvilimit)
                                dviswap();
                        }
                        {
                            dvibuf[dviptr] = /* @d6551@ */ f - 1;
                            incr(dviptr);
                            if (dviptr == dvilimit)
                                dviswap();
                        }
                    } else {

                        {
                            dvibuf[dviptr] = /* @d6552@ */ 236;
                            incr(dviptr);
                            if (dviptr == dvilimit)
                                dviswap();
                        }
                        {
                            dvibuf[dviptr] = (/* @d6553@ */ f - 1) / 256;
                            incr(dviptr);
                            if (dviptr == dvilimit)
                                dviswap();
                        }
                        {
                            dvibuf[dviptr] = (/* @d6554@ */ f - 1) % 256;
                            incr(dviptr);
                            if (dviptr == dvilimit)
                                dviswap();
                        }
                    }
                    dvif = f;
                }
                if (fontec[f] >= c) {

                    if (fontbc[f] <= c) {

                        if ((fontinfo[charbase[f] + c].qqqq.b0 >
                             MINQUARTERWORD)) {
                            if (c >= 128) {
                                dvibuf[dviptr] = SET1;
                                incr(dviptr);
                                if (dviptr == dvilimit)
                                    dviswap();
                            }
                            {
                                dvibuf[dviptr] = c;
                                incr(dviptr);
                                if (dviptr == dvilimit)
                                    dviswap();
                            }
                            curh = curh +
                                   fontinfo[widthbase[f] +
                                            fontinfo[charbase[f] + c].qqqq.b0]
                                       .cint;
                            goto labhlistout22continue;
                        }
                    }
                }
                if (mltexenabledp) /* comment:Output a substitution, |goto
                                      continue| if not poss */
                {
                    /* comment:Get substitution information, check it, goto
                     * |foun */
                    if (c >= eqtb[INTBASE + CHARSUBDEFMINCODE].cint) {

                        if (c <= eqtb[INTBASE + CHARSUBDEFMAXCODE].cint) {

                            if ((eqtb[CHARSUBCODEBASE + c].hh.v.RH > 0)) {
                                basec =
                                    (eqtb[CHARSUBCODEBASE + c].hh.v.RH % 256);
                                accentc =
                                    (eqtb[CHARSUBCODEBASE + c].hh.v.RH / 256);
                                if ((fontec[f] >= basec)) {

                                    if ((fontbc[f] <= basec)) {

                                        if ((fontec[f] >= accentc)) {

                                            if ((fontbc[f] <= accentc)) {
                                                iac = fontinfo[charbase[f] +
                                                               effectivechar(
                                                                   true, f,
                                                                   accentc)]
                                                          .qqqq;
                                                ibc = fontinfo[charbase[f] +
                                                               effectivechar(
                                                                   true, f,
                                                                   basec)]
                                                          .qqqq;
                                                if ((ibc.b0 > MINQUARTERWORD)) {

                                                    if ((iac.b0 >
                                                         MINQUARTERWORD))
                                                        goto labhlistout40found;
                                                }
                                            }
                                        }
                                    }
                                }
                                begindiagnostic();
                                printnl(/* str 'Missing character' */ 2076);
                                print(c);
                                print(/* str ' = ' */ 1630);
                                print(accentc);
                                print(/* str ' ' */ 32);
                                print(basec);
                                print(/* str ' in font ' */ 984);
                                slowprint(fontname[f]);
                                printchar(/* str '!' */ 33);
                                enddiagnostic(false);
                                goto labhlistout22continue;
                            }
                        }
                    }
                    begindiagnostic();
                    printnl(/* str 'Missing character' */ 983);
                    print(/* str 'substitution for ' */ 2075);
                    print(c);
                    print(/* str ' in font ' */ 984);
                    slowprint(fontname[f]);
                    printchar(/* str '!' */ 33);
                    enddiagnostic(false);
                    goto labhlistout22continue;
                labhlistout40found
                    : /* comment:Print character substition tracing log */
                    if (eqtb[INTBASE + TRACINGLOSTCHARSCODE].cint > 99) {
                        begindiagnostic();
                        printnl(/* str 'Using character substitution' */ 2077);
                        print(c);
                        print(/* str ' = ' */ 1630);
                        print(accentc);
                        print(/* str ' ' */ 32);
                        print(basec);
                        print(/* str ' in font ' */ 984);
                        slowprint(fontname[f]);
                        printchar(/* str '.' */ 46);
                        enddiagnostic(false);
                    }
                    /* comment:Rebuild character using substitution information
                     */
                    basexheight = fontinfo[XHEIGHTCODE + parambase[f]].cint;
                    baseslant = fontinfo[SLANTCODE + parambase[f]].cint /
                                ((double)65536.0);
                    accentslant = baseslant;
                    basewidth = fontinfo[widthbase[f] + ibc.b0].cint;
                    baseheight = fontinfo[heightbase[f] + (ibc.b1) / 16].cint;
                    accentwidth = fontinfo[widthbase[f] + iac.b0].cint;
                    accentheight = fontinfo[heightbase[f] + (iac.b1) / 16].cint;
                    delta = round((basewidth - accentwidth) / ((double)2.0) +
                                  baseheight * baseslant -
                                  basexheight * accentslant);
                    dvih = curh;
                    curh = curh + delta;
                    if (curh != dvih) {
                        movement(curh - dvih, RIGHT1);
                        dvih = curh;
                    }
                    if (((baseheight != basexheight) && (accentheight > 0))) {
                        curv = baseline + (basexheight - baseheight);
                        if (curv != dviv) {
                            movement(curv - dviv, DOWN1);
                            dviv = curv;
                        }
                        if (accentc >= 128) {
                            dvibuf[dviptr] = SET1;
                            incr(dviptr);
                            if (dviptr == dvilimit)
                                dviswap();
                        }
                        {
                            dvibuf[dviptr] = accentc;
                            incr(dviptr);
                            if (dviptr == dvilimit)
                                dviswap();
                        }
                        curv = baseline;
                    } else {

                        if (curv != dviv) {
                            movement(curv - dviv, DOWN1);
                            dviv = curv;
                        }
                        if (accentc >= 128) {
                            dvibuf[dviptr] = SET1;
                            incr(dviptr);
                            if (dviptr == dvilimit)
                                dviswap();
                        }
                        {
                            dvibuf[dviptr] = accentc;
                            incr(dviptr);
                            if (dviptr == dvilimit)
                                dviswap();
                        }
                    }
                    curh = curh + accentwidth;
                    dvih = curh;
                    curh = curh + (-(integer)accentwidth - delta);
                    if (curh != dvih) {
                        movement(curh - dvih, RIGHT1);
                        dvih = curh;
                    }
                    if (curv != dviv) {
                        movement(curv - dviv, DOWN1);
                        dviv = curv;
                    }
                    if (basec >= 128) {
                        dvibuf[dviptr] = SET1;
                        incr(dviptr);
                        if (dviptr == dvilimit)
                            dviswap();
                    }
                    {
                        dvibuf[dviptr] = basec;
                        incr(dviptr);
                        if (dviptr == dvilimit)
                            dviswap();
                    }
                    curh = curh + basewidth;
                    dvih = curh;
                }
            labhlistout22continue:
                prevp = mem[prevp].hh.v.RH;
                p = mem[p].hh.v.RH;
            } while (!(!(p >= himemmin)));
            dvih = curh;
        } else /* comment:Output the non-|char_node| |p| for |hlist_out| and */
        {

            switch (mem[p].hh.b0) {
            case HLISTNODE:
            case VLISTNODE:
                /* comment:Output a box in an hlist */ if (mem[/* @d6606@ */ p +
                                                               5]
                                                               .hh.v.RH ==
                                                           TEXNULL)
                    curh = curh + mem[p + WIDTHOFFSET].cint;
                else {

                    saveh = dvih;
                    savev = dviv;
                    curv = baseline + mem[p + 4].cint;
                    tempptr = p;
                    edge = curh + mem[p + WIDTHOFFSET].cint;
                    if (curdir == RIGHTTOLEFT)
                        curh = edge;
                    if (mem[p].hh.b0 == VLISTNODE)
                        vlistout();
                    else
                        hlistout();
                    dvih = saveh;
                    dviv = savev;
                    curh = edge;
                    curv = baseline;
                }
                break;
            case RULENODE: {
                ruleht = mem[p + HEIGHTOFFSET].cint;
                ruledp = mem[p + DEPTHOFFSET].cint;
                rulewd = mem[p + WIDTHOFFSET].cint;
                goto labhlistout14fin_rule;
            } break;
            case WHATSITNODE:
                /* comment:Output the whatsit node |p| in an hlist */ outwhat(
                    p);
                break;
            case GLUENODE:
                /* comment:Move right or output leaders */ {

                    g = mem[p + 1].hh.v.LH;
                    rulewd = mem[g + WIDTHOFFSET].cint - curg;
                    if (gsign != NORMAL) {
                        if (gsign == STRETCHING) {
                            if (mem[g].hh.b0 == gorder) {
                                curglue = curglue + mem[g + 2].cint;
                                gluetemp =
                                    mem[thisbox + GLUEOFFSET].gr * curglue;
                                if (gluetemp > 1000000000.0)
                                    gluetemp = 1000000000.0;
                                else if (gluetemp < -1000000000.0)
                                    gluetemp = -1000000000.0;
                                curg = round(gluetemp);
                            }
                        } else if (mem[g].hh.b1 == gorder) {
                            curglue = curglue - mem[g + 3].cint;
                            gluetemp = mem[thisbox + GLUEOFFSET].gr * curglue;
                            if (gluetemp > 1000000000.0)
                                gluetemp = 1000000000.0;
                            else if (gluetemp < -1000000000.0)
                                gluetemp = -1000000000.0;
                            curg = round(gluetemp);
                        }
                    }
                    rulewd = rulewd + curg;
                    if ((eTeXmode == 1)) /* comment:Handle a glue node for mixed
                                            direction typesetting */
                    {

                        if ((((gsign == STRETCHING) &&
                              (mem[g].hh.b0 == gorder)) ||
                             ((gsign == SHRINKING) &&
                              (mem[g].hh.b1 == gorder)))) {
                            {
                                if (mem[g].hh.v.RH == TEXNULL)
                                    freenode(g, GLUESPECSIZE);
                                else
                                    decr(mem[g].hh.v.RH);
                            }
                            if (mem[p].hh.b1 < ALEADERS) {
                                mem[p].hh.b0 = KERNNODE;
                                mem[p + WIDTHOFFSET].cint = rulewd;
                            } else {

                                g = getnode(GLUESPECSIZE);
                                mem[g].hh.b0 = /* @d6633@ */ 4;
                                mem[g].hh.b1 = /* @d6634@ */ 4;
                                mem[g + WIDTHOFFSET].cint = rulewd;
                                mem[g + 2].cint = 0;
                                mem[g + 3].cint = 0;
                                mem[p + 1].hh.v.LH = g;
                            }
                        }
                    }
                    if (mem[p].hh.b1 >=
                        ALEADERS) /* comment:Output leaders in an
                                              hlist, |goto fin_rule| if a r */
                    {
                        leaderbox = mem[p + 1].hh.v.RH;
                        if (mem[leaderbox].hh.b0 == RULENODE) {
                            ruleht = mem[leaderbox + HEIGHTOFFSET].cint;
                            ruledp = mem[leaderbox + DEPTHOFFSET].cint;
                            goto labhlistout14fin_rule;
                        }
                        leaderwd = mem[leaderbox + WIDTHOFFSET].cint;
                        if ((leaderwd > 0) && (rulewd > 0)) {
                            rulewd = rulewd + 10;
                            if (curdir == RIGHTTOLEFT)
                                curh = curh - 10;
                            edge = curh + rulewd;
                            lx = 0;
                            /* comment:Let |cur_h| be the position of the first
                             * box, and  */
                            if (mem[p].hh.b1 == ALEADERS) {
                                saveh = curh;
                                curh =
                                    leftedge +
                                    leaderwd * ((curh - leftedge) / leaderwd);
                                if (curh < saveh)
                                    curh = curh + leaderwd;
                            } else {

                                lq = rulewd / leaderwd;
                                lr = rulewd % leaderwd;
                                if (mem[p].hh.b1 == CLEADERS)
                                    curh = curh + (lr / 2);
                                else {

                                    lx = lr / (lq + 1);
                                    curh = curh + ((lr - (lq - 1) * lx) / 2);
                                }
                            }
                            while (curh + leaderwd <=
                                   edge) /* comment:Output a leader box at
                                            |cur_h|, then advance |cur_ */
                            {

                                curv = baseline + mem[leaderbox + 4].cint;
                                if (curv != dviv) {
                                    movement(curv - dviv, DOWN1);
                                    dviv = curv;
                                }
                                savev = dviv;
                                if (curh != dvih) {
                                    movement(curh - dvih, RIGHT1);
                                    dvih = curh;
                                }
                                saveh = dvih;
                                tempptr = leaderbox;
                                if (curdir == RIGHTTOLEFT)
                                    curh = curh + leaderwd;
                                outerdoingleaders = doingleaders;
                                doingleaders = true;
                                if (mem[leaderbox].hh.b0 == VLISTNODE)
                                    vlistout();
                                else
                                    hlistout();
                                doingleaders = outerdoingleaders;
                                dviv = savev;
                                dvih = saveh;
                                curv = baseline;
                                curh = saveh + leaderwd + lx;
                            }
                            if (curdir == RIGHTTOLEFT)
                                curh = edge;
                            else
                                curh = edge - 10;
                            goto labhlistout15next_p;
                        }
                    }
                    goto labhlistout13move_past;
                }
                break;
            case MARGINKERNNODE:
            case KERNNODE:
                curh = curh + mem[p + WIDTHOFFSET].cint;
                break;
            case MATHNODE:
                /* comment:Handle a math node in |hlist_out| */ {

                    if ((eTeXmode == 1)) /* comment:Adjust \(t)the LR stack for
                                            the |hlist_out| routin */
                    {
                        if (odd(mem[p].hh.b1)) {

                            if (mem[LRptr].hh.v.LH ==
                                (LCODE * (mem[p].hh.b1 / LCODE) /* @d6663@ */
                                 + 3)) {
                                tempptr = LRptr;
                                LRptr = mem[tempptr].hh.v.RH;
                                {
                                    mem[tempptr].hh.v.RH = avail;
                                    avail = tempptr;
                                    mem[tempptr].hh.me = 0;
                                    ;
#ifdef STAT
                                    decr(dynused);
#endif /* STAT */
                                }
                            } else {

                                if (mem[p].hh.b1 > LCODE)
                                    incr(LRproblems);
                            }
                        } else {

                            {
                                tempptr = getavail();
                                mem[tempptr].hh.v.LH =
                                    (LCODE *
                                         (mem[p].hh.b1 / LCODE) /* @d6667@ */
                                     + 3);
                                mem[tempptr].hh.v.RH = LRptr;
                                LRptr = tempptr;
                            }
                            if ((mem[p].hh.b1 / RCODE) !=
                                curdir) /* comment:Reverse an hlist segment and
                                           |goto reswitch| */
                            {
                                saveh = curh;
                                tempptr = mem[p].hh.v.RH;
                                rulewd = mem[p + WIDTHOFFSET].cint;
                                freenode(p, SMALLNODESIZE);
                                curdir = 1 - curdir;
                                p = newedge(curdir, rulewd);
                                mem[prevp].hh.v.RH = p;
                                curh = curh - leftedge + rulewd;
                                mem[p].hh.v.RH =
                                    reverse(thisbox, newedge(1 - curdir, 0),
                                            curg, curglue);
                                mem[p + DEPTHOFFSET].cint = curh;
                                curdir = 1 - curdir;
                                curh = saveh;
                                goto labhlistout21reswitch;
                            }
                        }
                        mem[p].hh.b0 = KERNNODE;
                    }
                    curh = curh + mem[p + WIDTHOFFSET].cint;
                }
                break;
            case LIGATURENODE:
                /* comment:Make node |p| look like a |char_node| and |goto re */
                {

                    mem[memtop - 12] = mem[p + 1];
                    mem[memtop - 12].hh.v.RH = mem[p].hh.v.RH;
                    mem[memtop - 12].hh.me = mem[p].hh.me;
                    p = memtop - 12;
                    goto labhlistout21reswitch;
                }
                break;
            /* comment:Cases of |hlist_out| that arise in mixed direction */
            case EDGENODE: {
                curh = curh + mem[p + WIDTHOFFSET].cint;
                leftedge = curh + mem[p + DEPTHOFFSET].cint;
                curdir = mem[p].hh.b1;
            } break;
            default:;
                break;
            }
            goto labhlistout15next_p;
        labhlistout14fin_rule: /* comment:Output a rule in an hlist */
            if ((ruleht == -1073741824L))
                ruleht = mem[thisbox + HEIGHTOFFSET].cint;
            if ((ruledp == -1073741824L))
                ruledp = mem[thisbox + DEPTHOFFSET].cint;
            ruleht = ruleht + ruledp;
            if ((ruleht > 0) && (rulewd > 0)) {
                if (curh != dvih) {
                    movement(curh - dvih, RIGHT1);
                    dvih = curh;
                }
                curv = baseline + ruledp;
                if (curv != dviv) {
                    movement(curv - dviv, DOWN1);
                    dviv = curv;
                }
                {
                    dvibuf[dviptr] = SETRULE;
                    incr(dviptr);
                    if (dviptr == dvilimit)
                        dviswap();
                }
                dvifour(ruleht);
                dvifour(rulewd);
                curv = baseline;
                dvih = dvih + rulewd;
            }
        labhlistout13move_past:
            curh = curh + rulewd;
        labhlistout15next_p:
            prevp = p;
            p = mem[p].hh.v.RH;
        }
    /* comment:Finish |hlist_out| for mixed direction typesetting */
    if ((eTeXmode == 1)) {
        /* comment:Check for LR anomalies at the end of |hlist_out| */ {

            while (mem[LRptr].hh.v.LH != BEFORE) {

                if (mem[LRptr].hh.v.LH > LCODE)
                    LRproblems = LRproblems + 10000;
                {
                    tempptr = LRptr;
                    LRptr = mem[tempptr].hh.v.RH;
                    {
                        mem[tempptr].hh.v.RH = avail;
                        avail = tempptr;
                        mem[tempptr].hh.me = 0;
                        ;
#ifdef STAT
                        decr(dynused);
#endif /* STAT */
                    }
                }
            }
            {
                tempptr = LRptr;
                LRptr = mem[tempptr].hh.v.RH;
                {
                    mem[tempptr].hh.v.RH = avail;
                    avail = tempptr;
                    mem[tempptr].hh.me = 0;
                    ;
#ifdef STAT
                    decr(dynused);
#endif /* STAT */
                }
            }
        }
        if ((mem[thisbox].hh.b1) == DLIST)
            curdir = RIGHTTOLEFT;
    }
    prunemovements(saveloc);
    if (curs > 0)
        dvipop(saveloc);
    decr(curs);
}
void vlistout(void) {
    vlistout_regmem scaled leftedge;
    scaled topedge;
    scaled saveh, savev;
    halfword thisbox;
    glueord gorder;
    unsigned char gsign;
    halfword p;
    integer saveloc;
    halfword leaderbox;
    scaled leaderht;
    scaled lx;
    boolean outerdoingleaders;
    scaled edge;
    real gluetemp;
    real curglue;
    scaled curg;
    curg = 0;
    curglue = 0.0;
    thisbox = tempptr;
    gorder = mem[thisbox + LISTOFFSET].hh.b1;
    gsign = mem[thisbox + LISTOFFSET].hh.b0;
    p = mem[thisbox + LISTOFFSET].hh.v.RH;
    incr(curs);
    if (curs > 0) {
        dvibuf[dviptr] = PUSH;
        incr(dviptr);
        if (dviptr == dvilimit)
            dviswap();
    }
    if (curs > maxpush)
        maxpush = curs;
    saveloc = dvioffset + dviptr;
    leftedge = curh;
    curv = curv - mem[thisbox + HEIGHTOFFSET].cint;
    topedge = curv;
    while (p != TEXNULL) /* comment:Output node |p| for |vlist_out| and
                                 move to the ne */
    {

        if ((p >= himemmin))
            confusion(/* str 'vlistout' */ 987);
        else /* comment:Output the non-|char_node| |p| for |vlist_out| */ {

            switch (mem[p].hh.b0) {
            case HLISTNODE:
            case VLISTNODE:
                /* comment:Output a box in a vlist */ if (mem[/* @d6715@ */ p +
                                                              5]
                                                              .hh.v.RH ==
                                                          TEXNULL)
                    curv = curv + mem[p + HEIGHTOFFSET].cint +
                           mem[p + DEPTHOFFSET].cint;
                else {

                    curv = curv + mem[p + HEIGHTOFFSET].cint;
                    if (curv != dviv) {
                        movement(curv - dviv, DOWN1);
                        dviv = curv;
                    }
                    saveh = dvih;
                    savev = dviv;
                    if (curdir == RIGHTTOLEFT)
                        curh = leftedge - mem[p + 4].cint;
                    else
                        curh = leftedge + mem[p + 4].cint;
                    tempptr = p;
                    if (mem[p].hh.b0 == VLISTNODE)
                        vlistout();
                    else
                        hlistout();
                    dvih = saveh;
                    dviv = savev;
                    curv = savev + mem[p + DEPTHOFFSET].cint;
                    curh = leftedge;
                }
                break;
            case RULENODE: {
                ruleht = mem[p + HEIGHTOFFSET].cint;
                ruledp = mem[p + DEPTHOFFSET].cint;
                rulewd = mem[p + WIDTHOFFSET].cint;
                goto labvlistout14fin_rule;
            } break;
            case WHATSITNODE:
                /* comment:Output the whatsit node |p| in a vlist */ outwhat(p);
                break;
            case GLUENODE:
                /* comment:Move down or output leaders */ {

                    g = mem[p + 1].hh.v.LH;
                    ruleht = mem[g + WIDTHOFFSET].cint - curg;
                    if (gsign != NORMAL) {
                        if (gsign == STRETCHING) {
                            if (mem[g].hh.b0 == gorder) {
                                curglue = curglue + mem[g + 2].cint;
                                gluetemp =
                                    mem[thisbox + GLUEOFFSET].gr * curglue;
                                if (gluetemp > 1000000000.0)
                                    gluetemp = 1000000000.0;
                                else if (gluetemp < -1000000000.0)
                                    gluetemp = -1000000000.0;
                                curg = round(gluetemp);
                            }
                        } else if (mem[g].hh.b1 == gorder) {
                            curglue = curglue - mem[g + 3].cint;
                            gluetemp = mem[thisbox + GLUEOFFSET].gr * curglue;
                            if (gluetemp > 1000000000.0)
                                gluetemp = 1000000000.0;
                            else if (gluetemp < -1000000000.0)
                                gluetemp = -1000000000.0;
                            curg = round(gluetemp);
                        }
                    }
                    ruleht = ruleht + curg;
                    if (mem[p].hh.b1 >=
                        ALEADERS) /* comment:Output leaders in a vlist,
                                              |goto fin_rule| if a ru */
                    {
                        leaderbox = mem[p + 1].hh.v.RH;
                        if (mem[leaderbox].hh.b0 == RULENODE) {
                            rulewd = mem[leaderbox + WIDTHOFFSET].cint;
                            ruledp = 0;
                            goto labvlistout14fin_rule;
                        }
                        leaderht = mem[leaderbox + HEIGHTOFFSET].cint +
                                   mem[leaderbox + DEPTHOFFSET].cint;
                        if ((leaderht > 0) && (ruleht > 0)) {
                            ruleht = ruleht + 10;
                            edge = curv + ruleht;
                            lx = 0;
                            /* comment:Let |cur_v| be the position of the first
                             * box, and  */
                            if (mem[p].hh.b1 == ALEADERS) {
                                savev = curv;
                                curv = topedge +
                                       leaderht * ((curv - topedge) / leaderht);
                                if (curv < savev)
                                    curv = curv + leaderht;
                            } else {

                                lq = ruleht / leaderht;
                                lr = ruleht % leaderht;
                                if (mem[p].hh.b1 == CLEADERS)
                                    curv = curv + (lr / 2);
                                else {

                                    lx = lr / (lq + 1);
                                    curv = curv + ((lr - (lq - 1) * lx) / 2);
                                }
                            }
                            while (curv + leaderht <=
                                   edge) /* comment:Output a leader box at
                                            |cur_v|, then advance |cur_ */
                            {

                                if (curdir == RIGHTTOLEFT)
                                    curh = leftedge - mem[leaderbox + 4].cint;
                                else
                                    curh = leftedge + mem[leaderbox + 4].cint;
                                if (curh != dvih) {
                                    movement(curh - dvih, RIGHT1);
                                    dvih = curh;
                                }
                                saveh = dvih;
                                curv =
                                    curv + mem[leaderbox + HEIGHTOFFSET].cint;
                                if (curv != dviv) {
                                    movement(curv - dviv, DOWN1);
                                    dviv = curv;
                                }
                                savev = dviv;
                                tempptr = leaderbox;
                                outerdoingleaders = doingleaders;
                                doingleaders = true;
                                if (mem[leaderbox].hh.b0 == VLISTNODE)
                                    vlistout();
                                else
                                    hlistout();
                                doingleaders = outerdoingleaders;
                                dviv = savev;
                                dvih = saveh;
                                curh = leftedge;
                                curv = savev -
                                       mem[leaderbox + HEIGHTOFFSET].cint +
                                       leaderht + lx;
                            }
                            curv = edge - 10;
                            goto labvlistout15next_p;
                        }
                    }
                    goto labvlistout13move_past;
                }
                break;
            case KERNNODE:
                curv = curv + mem[p + WIDTHOFFSET].cint;
                break;
            default:;
                break;
            }
            goto labvlistout15next_p;
        labvlistout14fin_rule
            : /* comment:Output a rule in a vlist, |goto next_p| */
            if ((rulewd == -1073741824L))
                rulewd = mem[thisbox + WIDTHOFFSET].cint;
            ruleht = ruleht + ruledp;
            curv = curv + ruleht;
            if ((ruleht > 0) && (rulewd > 0)) {
                if (curdir == RIGHTTOLEFT)
                    curh = curh - rulewd;
                if (curh != dvih) {
                    movement(curh - dvih, RIGHT1);
                    dvih = curh;
                }
                if (curv != dviv) {
                    movement(curv - dviv, DOWN1);
                    dviv = curv;
                }
                {
                    dvibuf[dviptr] = PUTRULE;
                    incr(dviptr);
                    if (dviptr == dvilimit)
                        dviswap();
                }
                dvifour(ruleht);
                dvifour(rulewd);
                curh = leftedge;
            }
            goto labvlistout15next_p;
        labvlistout13move_past:
            curv = curv + ruleht;
        }
    labvlistout15next_p:
        p = mem[p].hh.v.RH;
    }
    prunemovements(saveloc);
    if (curs > 0)
        dvipop(saveloc);
    decr(curs);
}
void zdvishipout(halfword p) {
    dvishipout_regmem integer pageloc;
    unsigned char j, k;
    poolpointer s;
    unsigned char oldsetting;
    if (eqtb[INTBASE + TRACINGOUTPUTCODE].cint > 0) {
        printnl(/* str '' */ 345);
        println();
        print(/* str 'Completed box being shipped out' */ 988);
    }
    if (termoffset > maxprintline - 9)
        println();
    else if ((termoffset > 0) || (fileoffset > 0))
        printchar(/* str ' ' */ 32);
    printchar(/* str '[' */ 91);
    j = 9;
    while ((eqtb[COUNTBASE + j].cint == 0) && (j > 0))
        decr(j);
    {
        register integer for_end;
        k = 0;
        for_end = j;
        if (k <= for_end)
            do {
                printint(eqtb[COUNTBASE + k].cint);
                if (k < j)
                    printchar(/* str '.' */ 46);
            } while (k++ < for_end);
    }
    fflush(stdout);
    if (eqtb[INTBASE + TRACINGOUTPUTCODE].cint > 0) {
        printchar(/* str ']' */ 93);
        begindiagnostic();
        showbox(p);
        enddiagnostic(true);
    }
    /* comment:Ship box |p| out */ /* comment:Update the values of |max_h| and
                                      |max_v|; but if t */
    if ((mem[p + HEIGHTOFFSET].cint > 1073741823L) ||
        (mem[p + DEPTHOFFSET].cint > 1073741823L) ||
        (mem[p + HEIGHTOFFSET].cint + mem[p + DEPTHOFFSET].cint +
             eqtb[DIMENBASE + VOFFSETCODE].cint >
         1073741823L) ||
        (mem[p + WIDTHOFFSET].cint + eqtb[DIMENBASE + HOFFSETCODE].cint >
         1073741823L)) {
        {
            if (interaction == ERRORSTOPMODE)
                ;
            if (filelineerrorstylep)
                printfileline();
            else
                printnl(/* str '! ' */ 264);
            print(/* str 'Huge page cannot be shipped out' */ 992);
        }
        {
            helpptr = 2;
            helpline[1] =
                /* str 'The page just created is more than 18 feet tall o' */
                993;
            helpline[0] =
                /* str 'more than 18 feet wide, so I suspect something we' */
                994;
        }
        error();
        if (eqtb[INTBASE + TRACINGOUTPUTCODE].cint <= 0) {
            begindiagnostic();
            printnl(/* str 'The following box has been deleted' */ 995);
            showbox(p);
            enddiagnostic(true);
        }
        goto labdvishipout30done;
    }
    if (mem[p + HEIGHTOFFSET].cint + mem[p + DEPTHOFFSET].cint +
            eqtb[DIMENBASE + VOFFSETCODE].cint >
        maxv)
        maxv = mem[p + HEIGHTOFFSET].cint + mem[p + DEPTHOFFSET].cint +
               eqtb[DIMENBASE + VOFFSETCODE].cint;
    if (mem[p + WIDTHOFFSET].cint + eqtb[DIMENBASE + HOFFSETCODE].cint > maxh)
        maxh = mem[p + WIDTHOFFSET].cint + eqtb[DIMENBASE + HOFFSETCODE].cint;
    /* comment:Initialize variables as |ship_out| begins */ dvih = 0;
    dviv = 0;
    curh = eqtb[DIMENBASE + HOFFSETCODE].cint;
    dvif = FONTBASE;
    /* comment:Calculate DVI page dimensions and margins */ curhoffset =
        eqtb[DIMENBASE + HOFFSETCODE].cint;
    curvoffset = eqtb[DIMENBASE + VOFFSETCODE].cint;
    if (eqtb[DIMENBASE + PDFPAGEWIDTHCODE].cint != 0)
        curpagewidth = eqtb[DIMENBASE + PDFPAGEWIDTHCODE].cint;
    else
        curpagewidth =
            mem[p + WIDTHOFFSET].cint + 2 * curhoffset + 2 * 4736286L;
    if (eqtb[DIMENBASE + PDFPAGEHEIGHTCODE].cint != 0)
        curpageheight = eqtb[DIMENBASE + PDFPAGEHEIGHTCODE].cint;
    else
        curpageheight = mem[p + HEIGHTOFFSET].cint + mem[p + DEPTHOFFSET].cint +
                        2 * curvoffset + 2 * 4736286L;
    if (outputfilename == 0) {
        if (jobname == 0)
            openlogfile();
        packjobname(/* str '.dvi' */ 948);
        while (!bopenout(dvifile))
            promptfilename(/* str 'file name for output' */ 949,
                           /* str '.dvi' */ 948);
        outputfilename = bmakenamestring(dvifile);
    }
    if (totalpages == 0) {
        {
            dvibuf[dviptr] = PRE;
            incr(dviptr);
            if (dviptr == dvilimit)
                dviswap();
        }
        {
            dvibuf[dviptr] = IDBYTE;
            incr(dviptr);
            if (dviptr == dvilimit)
                dviswap();
        }
        dvifour(25400000L);
        dvifour(473628672L);
        preparemag();
        dvifour(eqtb[INTBASE + MAGCODE].cint);
        if (outputcomment) {
            l = strlen(outputcomment);
            {
                dvibuf[dviptr] = l;
                incr(dviptr);
                if (dviptr == dvilimit)
                    dviswap();
            }
            {
                register integer for_end;
                s = 0;
                for_end = l - 1;
                if (s <= for_end)
                    do {
                        dvibuf[dviptr] = outputcomment[s];
                        incr(dviptr);
                        if (dviptr == dvilimit)
                            dviswap();
                    } while (s++ < for_end);
            }
        } else {

            oldsetting = selector;
            selector = NEWSTRING;
            print(/* str ' TeX output ' */ 986);
            printint(eqtb[INTBASE + YEARCODE].cint);
            printchar(/* str '.' */ 46);
            printtwo(eqtb[INTBASE + MONTHCODE].cint);
            printchar(/* str '.' */ 46);
            printtwo(eqtb[INTBASE + DAYCODE].cint);
            printchar(/* str '' */ 58);
            printtwo(eqtb[INTBASE + TIMECODE].cint / 60);
            printtwo(eqtb[INTBASE + TIMECODE].cint % 60);
            selector = oldsetting;
            {
                dvibuf[dviptr] = (poolptr - strstart[strptr]);
                incr(dviptr);
                if (dviptr == dvilimit)
                    dviswap();
            }
            {
                register integer for_end;
                s = strstart[strptr];
                for_end = poolptr - 1;
                if (s <= for_end)
                    do {
                        dvibuf[dviptr] = strpool[s];
                        incr(dviptr);
                        if (dviptr == dvilimit)
                            dviswap();
                    } while (s++ < for_end);
            }
            poolptr = strstart[strptr];
        }
    }
    pageloc = dvioffset + dviptr;
    {
        dvibuf[dviptr] = BOP;
        incr(dviptr);
        if (dviptr == dvilimit)
            dviswap();
    }
    {
        register integer for_end;
        k = 0;
        for_end = 9;
        if (k <= for_end)
            do
                dvifour(eqtb[COUNTBASE + k].cint);
            while (k++ < for_end);
    }
    dvifour(lastbop);
    lastbop = pageloc;
    curv = mem[p + HEIGHTOFFSET].cint + eqtb[DIMENBASE + VOFFSETCODE].cint;
    tempptr = p;
    if (mem[p].hh.b0 == VLISTNODE)
        vlistout();
    else
        hlistout();
    {
        dvibuf[dviptr] = EOP;
        incr(dviptr);
        if (dviptr == dvilimit)
            dviswap();
    }
    incr(totalpages);
    curs = -1;
    ;
#ifdef IPC
    if (ipcon > 0) {
        if (dvilimit == halfbuf) {
            writedvi(halfbuf, dvibufsize - 1);
            flushdvi();
            dvigone = dvigone + halfbuf;
        }
        if (dviptr > (2147483647L - dvioffset)) {
            curs = -2;
            fatalerror(/* str 'dvi length exceeds ""7FFFFFFF' */ 985);
        }
        if (dviptr > 0) {
            writedvi(0, dviptr - 1);
            flushdvi();
            dvioffset = dvioffset + dviptr;
            dvigone = dvigone + dviptr;
        }
        dviptr = 0;
        dvilimit = dvibufsize;
        ipcpage(dvigone);
    }
#endif /* IPC */
labdvishipout30done:;
    if ((eTeXmode ==
         1)) /* comment:Check for LR anomalies at the end of |ship_out| */
    {
        if (LRproblems > 0) {
            /* comment:Report LR problems */ {

                println();
                printnl(/* str '\endL or \endR problem (' */ 2027);
                printint(LRproblems / 10000);
                print(/* str ' missing, ' */ 2028);
                printint(LRproblems % 10000);
                print(/* str ' extra' */ 2029);
                LRproblems = 0;
            }
            printchar(/* str ')' */ 41);
            println();
        }
        if ((LRptr != TEXNULL) || (curdir != LEFTTORIGHT))
            confusion(/* str 'LR3' */ 2031);
    }
    if (eqtb[INTBASE + TRACINGOUTPUTCODE].cint <= 0)
        printchar(/* str ']' */ 93);
    deadcycles = 0;
    fflush(stdout);
    /* comment:Flush the box from memory, showing statistics if r */;
#ifdef STAT
    if (eqtb[INTBASE + TRACINGSTATSCODE].cint > 1) {
        printnl(/* str 'Memory usage before' */ 989);
        printint(varused);
        printchar(/* str '&' */ 38);
        printint(dynused);
        printchar(/* str ';' */ 59);
    }
#endif /* STAT */
    flushnodelist(p);
    ;
#ifdef STAT
    if (eqtb[INTBASE + TRACINGSTATSCODE].cint > 1) {
        print(/* str ' after' */ 990);
        printint(varused);
        printchar(/* str '&' */ 38);
        printint(dynused);
        print(/* str '; still untouched' */ 991);
        printint(himemmin - lomemmax - 1);
        println();
    }
#endif /* STAT */
}
integer getpdfcompresslevel(void) {
    register integer Result;
    getpdfcompresslevel_regmem Result =
        eqtb[INTBASE + PDFCOMPRESSLEVELCODE].cint;
    return Result;
}
integer getpdfsuppresswarningdupmap(void) {
    register integer Result;
    getpdfsuppresswarningdupmap_regmem Result =
        eqtb[INTBASE + PDFSUPPRESSWARNINGDUPMAPCODE].cint;
    return Result;
}
integer getpdfsuppresswarningpagegroup(void) {
    register integer Result;
    getpdfsuppresswarningpagegroup_regmem Result =
        eqtb[INTBASE + PDFSUPPRESSWARNINGPAGEGROUPCODE].cint;
    return Result;
}
integer getpdfsuppressptexinfo(void) {
    register integer Result;
    getpdfsuppressptexinfo_regmem Result =
        eqtb[INTBASE + PDFSUPPRESSPTEXINFOCODE].cint;
    return Result;
}
integer getpdfomitcharset(void) {
    register integer Result;
    getpdfomitcharset_regmem Result = eqtb[INTBASE + PDFOMITCHARSETCODE].cint;
    return Result;
}
internalfontnumber getnullfont(void) {
    register internalfontnumber Result;
    getnullfont_regmem Result = FONTBASE;
    return Result;
}
internalfontnumber getfontbase(void) {
    register internalfontnumber Result;
    getfontbase_regmem Result = FONTBASE;
    return Result;
}
halfword getnullcs(void) {
    register halfword Result;
    getnullcs_regmem Result = NULLCS;
    return Result;
}
halfword getnullptr(void) {
    register halfword Result;
    getnullptr_regmem Result = TEXNULL;
    return Result;
}
integer zgettexint(integer code) {
    register integer Result;
    gettexint_regmem Result = eqtb[INTBASE + code].cint;
    return Result;
}
scaled zgettexdimen(integer code) {
    register scaled Result;
    gettexdimen_regmem Result = eqtb[DIMENBASE + code].cint;
    return Result;
}
scaled zgetxheight(internalfontnumber f) {
    register scaled Result;
    getxheight_regmem Result = fontinfo[XHEIGHTCODE + parambase[f]].cint;
    return Result;
}
scaled zgetcharwidth(internalfontnumber f, eightbits c) {
    register scaled Result;
    getcharwidth_regmem if (((fontbc[f] <= c) && (c <= fontec[f]) &&
                             (fontinfo[charbase[f] + c].qqqq.b0 >
                              MINQUARTERWORD))) Result =
        fontinfo[widthbase[f] + fontinfo[charbase[f] + c].qqqq.b0].cint;
    else Result = 0;
    return Result;
}
scaled zgetcharheight(internalfontnumber f, eightbits c) {
    register scaled Result;
    getcharheight_regmem if (((fontbc[f] <= c) && (c <= fontec[f]) &&
                              (fontinfo[charbase[f] + c].qqqq.b0 >
                               MINQUARTERWORD))) Result =
        fontinfo[heightbase[f] + (fontinfo[charbase[f] + c].qqqq.b1) / 16].cint;
    else Result = 0;
    return Result;
}
scaled zgetchardepth(internalfontnumber f, eightbits c) {
    register scaled Result;
    getchardepth_regmem if (((fontbc[f] <= c) && (c <= fontec[f]) &&
                             (fontinfo[charbase[f] + c].qqqq.b0 >
                              MINQUARTERWORD))) Result =
        fontinfo[depthbase[f] + (fontinfo[charbase[f] + c].qqqq.b1) % 16].cint;
    else Result = 0;
    return Result;
}
scaled zgetquad(internalfontnumber f) {
    register scaled Result;
    getquad_regmem Result = fontinfo[QUADCODE + parambase[f]].cint;
    return Result;
}
scaled zgetslant(internalfontnumber f) {
    register scaled Result;
    getslant_regmem Result = fontinfo[SLANTCODE + parambase[f]].cint;
    return Result;
}
internalfontnumber newdummyfont(void) {
    register internalfontnumber Result;
    newdummyfont_regmem Result =
        readfontinfo(NULLCS, /* str 'dummy' */ 1002, /* str '' */ 345, -1000);
    return Result;
}
void zshortdisplayn(integer p, integer m) {
    shortdisplayn_regmem integer n;
    integer i;
    i = 0;
    fontinshortdisplay = FONTBASE;
    if (p == TEXNULL)
        return;
    while (p > memmin) {

        if ((p >= himemmin)) {
            if (p <= memend) {
                if (mem[p].hh.b0 != fontinshortdisplay) {
                    if ((mem[p].hh.b0 < FONTBASE) || (mem[p].hh.b0 > fontmax))
                        printchar(/* str '' */ 42);
                    else
                        printfontidentifier(mem[p].hh.b0);
                    printchar(/* str ' ' */ 32);
                    fontinshortdisplay = mem[p].hh.b0;
                }
                print(mem[p].hh.b1);
            }
        } else {

            if ((mem[p].hh.b0 == GLUENODE) || (mem[p].hh.b0 == DISCNODE) ||
                (mem[p].hh.b0 == PENALTYNODE) ||
                ((mem[p].hh.b0 == KERNNODE) && (mem[p].hh.b1 == EXPLICIT)))
                incr(i);
            if (i >= m)
                return;
            if ((mem[p].hh.b0 == DISCNODE)) {
                print(/* str '|' */ 124);
                shortdisplay(mem[p + 1].hh.v.LH);
                print(/* str '|' */ 124);
                shortdisplay(mem[p + 1].hh.v.RH);
                print(/* str '|' */ 124);
                n = mem[p].hh.b1;
                while (n > 0) {

                    if (mem[p].hh.v.RH != TEXNULL)
                        p = mem[p].hh.v.RH;
                    decr(n);
                }
            } else /* comment:Print a short indication of the contents of node |
                    */
                switch (mem[p].hh.b0) {
                case HLISTNODE:
                case VLISTNODE:
                case INSNODE:
                case WHATSITNODE:
                case MARKNODE:
                case ADJUSTNODE:
                case UNSETNODE:
                    print(/* str '[]' */ 313);
                    break;
                case RULENODE:
                    printchar(/* str '|' */ 124);
                    break;
                case GLUENODE:
                    if (mem[p + 1].hh.v.LH != membot)
                        printchar(/* str ' ' */ 32);
                    break;
                case MATHNODE:
                    if (mem[p].hh.b1 >= LCODE)
                        print(/* str '[]' */ 313);
                    else
                        printchar(/* str '$' */ 36);
                    break;
                case LIGATURENODE:
                    shortdisplay(mem[p + 1].hh.v.RH);
                    break;
                case DISCNODE: {
                    shortdisplay(mem[p + 1].hh.v.LH);
                    shortdisplay(mem[p + 1].hh.v.RH);
                    n = mem[p].hh.b1;
                    while (n > 0) {

                        if (mem[p].hh.v.RH != TEXNULL)
                            p = mem[p].hh.v.RH;
                        decr(n);
                    }
                } break;
                default:;
                    break;
                }
        }
        p = mem[p].hh.v.RH;
        if (p == TEXNULL)
            return;
    }
    fflush(stdout);
}
integer zpdfgetmem(integer s) {
    register integer Result;
    pdfgetmem_regmem integer a;
    if (s > suppdfmemsize - pdfmemptr)
        overflow(/* str 'PDF memory size (pdf_mem_size)' */ 1003, pdfmemsize);
    if (pdfmemptr + s > pdfmemsize) {
        a = 0.2 * pdfmemsize;
        if (pdfmemptr + s > pdfmemsize + a)
            pdfmemsize = pdfmemptr + s;
        else if (pdfmemsize < suppdfmemsize - a)
            pdfmemsize = pdfmemsize + a;
        else
            pdfmemsize = suppdfmemsize;
        pdfmem = xreallocarray(pdfmem, integer, pdfmemsize);
    }
    Result = pdfmemptr;
    pdfmemptr = pdfmemptr + s;
    return Result;
}
integer zfixint(integer val, integer min, integer max) {
    register integer Result;
    fixint_regmem if (val < min) Result = min;
    else if (val > max) Result = max;
    else Result = val;
    return Result;
}
void checkpdfminorversion(void) {
    checkpdfminorversion_regmem if (!pdfminorversionwritten) {
        pdfminorversionwritten = true;
        if ((eqtb[INTBASE + PDFMINORVERSIONCODE].cint < 0) ||
            (eqtb[INTBASE + PDFMINORVERSIONCODE].cint > 9)) {
            {
                if (interaction == ERRORSTOPMODE)
                    ;
                if (filelineerrorstylep)
                    printfileline();
                else
                    printnl(/* str '! ' */ 264);
                print(/* str 'pdfTeX error (illegal pdfminorversion)' */ 1005);
            }
            println();
            {
                helpptr = 2;
                helpline[1] =
                    /* str 'The pdfminorversion must be between 0 and 9.' */
                    1006;
                helpline[0] = /* str 'I changed this to 4.' */ 1007;
            }
            interror(eqtb[INTBASE + PDFMINORVERSIONCODE].cint);
            eqtb[INTBASE + PDFMINORVERSIONCODE].cint = 4;
        }
        fixedpdfminorversion = eqtb[INTBASE + PDFMINORVERSIONCODE].cint;
        fixedgamma = fixint(eqtb[INTBASE + PDFGAMMACODE].cint, 0, 1000000L);
        fixedimagegamma =
            fixint(eqtb[INTBASE + PDFIMAGEGAMMACODE].cint, 0, 1000000L);
        fixedimagehicolor =
            fixint(eqtb[INTBASE + PDFIMAGEHICOLORCODE].cint, 0, 1);
        fixedimageapplygamma =
            fixint(eqtb[INTBASE + PDFIMAGEAPPLYGAMMACODE].cint, 0, 1);
        fixedpdfobjcompresslevel =
            fixint(eqtb[INTBASE + PDFOBJCOMPRESSLEVELCODE].cint, 0, 3);
        fixedpdfdraftmode = fixint(eqtb[INTBASE + PDFDRAFTMODECODE].cint, 0, 1);
        fixedinclusioncopyfont =
            fixint(eqtb[INTBASE + PDFINCLUSIONCOPYFONTCODE].cint, 0, 1);
        if ((fixedpdfminorversion >= 5) && (fixedpdfobjcompresslevel > 0))
            pdfosenable = true;
        else {

            if (fixedpdfobjcompresslevel > 0) {
                pdfwarning(/* str 'Object streams' */ 1008,
                           /* str '\pdfobjcompresslevel > 0 requires
                              \pdfminorversio' */
                           1009, true, true);
                fixedpdfobjcompresslevel = 0;
            }
            pdfosenable = false;
        }
        ensurepdfopen();
        fixpdfoutput();
        pdfprint(/* str '%PDF-1.' */ 1010);
        {
            pdfprintint(fixedpdfminorversion);
            {
                {
                    if (pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfosgetosbuf(1);
                    else if (!pdfosmode && (1 > pdfbufsize))
                        overflow(/* str 'PDF output buffer' */ 1004,
                                 pdfopbufsize);
                    else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfflush();
                }
                {
                    pdfbuf[pdfptr] = 10;
                    incr(pdfptr);
                }
            }
        }
        pdfprint(/* str '%' */ 37);
        {{if (pdfosmode && (1 + pdfptr > pdfbufsize)) pdfosgetosbuf(1);
        else if (!pdfosmode && (1 > pdfbufsize))
            overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
        else if (!pdfosmode && (1 + pdfptr > pdfbufsize)) pdfflush();
    }
    {
        pdfbuf[pdfptr] = 208;
        incr(pdfptr);
    }
}
{{if (pdfosmode && (1 + pdfptr > pdfbufsize)) pdfosgetosbuf(1);
else if (!pdfosmode && (1 > pdfbufsize))
    overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
else if (!pdfosmode && (1 + pdfptr > pdfbufsize)) pdfflush();
}
{
    pdfbuf[pdfptr] = 212;
    incr(pdfptr);
}
}
{{if (pdfosmode && (1 + pdfptr > pdfbufsize)) pdfosgetosbuf(1);
else if (!pdfosmode && (1 > pdfbufsize))
    overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
else if (!pdfosmode && (1 + pdfptr > pdfbufsize)) pdfflush();
}
{
    pdfbuf[pdfptr] = 197;
    incr(pdfptr);
}
}
{{if (pdfosmode && (1 + pdfptr > pdfbufsize)) pdfosgetosbuf(1);
else if (!pdfosmode && (1 > pdfbufsize))
    overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
else if (!pdfosmode && (1 + pdfptr > pdfbufsize)) pdfflush();
}
{
    pdfbuf[pdfptr] = 216;
    incr(pdfptr);
}
}
{
    {
        if (pdfosmode && (1 + pdfptr > pdfbufsize))
            pdfosgetosbuf(1);
        else if (!pdfosmode && (1 > pdfbufsize))
            overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
        else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
            pdfflush();
    }
    {
        pdfbuf[pdfptr] = 10;
        incr(pdfptr);
    }
}
}
else {

    if (fixedpdfminorversion != eqtb[INTBASE + PDFMINORVERSIONCODE].cint)
        pdferror(
            /* str 'setup' */ 1011,
            /* str '\pdfminorversion cannot be changed after data is ' */ 1012);
}
}
void ensurepdfopen(void) {
    ensurepdfopen_regmem if (outputfilename != 0) return;
    if (jobname == 0)
        openlogfile();
    packjobname(/* str '.pdf' */ 1013);
    if (fixedpdfdraftmode == 0)
        while (!bopenout(pdffile))
            promptfilename(/* str 'file name for output' */ 949,
                           /* str '.pdf' */ 1013);
    outputfilename = bmakenamestring(pdffile);
}
void pdfflush(void) {
    pdfflush_regmem longinteger savedpdfgone;
    if (!pdfosmode) {
        savedpdfgone = pdfgone;
        switch (zipwritestate) {
        case 0:
            if (pdfptr > 0) {
                if (fixedpdfdraftmode == 0)
                    writepdf(0, pdfptr - 1);
                pdfgone = pdfgone + pdfptr;
                pdflastbyte = pdfbuf[pdfptr - 1];
            }
            break;
        case 1:
            if (fixedpdfdraftmode == 0)
                writezip(false);
            break;
        case 2: {
            if (fixedpdfdraftmode == 0)
                writezip(true);
            zipwritestate = 0;
        } break;
        }
        pdfptr = 0;
        if (savedpdfgone > pdfgone)
            pdferror(
                /* str 'file size' */ 1014,
                /* str 'File size exceeds architectural limits (pdf_gone ' */
                1015);
    }
}
void pdfbeginstream(void) {
    pdfbeginstream_regmem {
        pdfprint(/* str 'Length           ' */ 1016);
        {
            {
                if (pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfosgetosbuf(1);
                else if (!pdfosmode && (1 > pdfbufsize))
                    overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
                else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfflush();
            }
            {
                pdfbuf[pdfptr] = 10;
                incr(pdfptr);
            }
        }
    }
    pdfseekwritelength = true;
    pdfstreamlengthoffset = (pdfgone + pdfptr) - 11;
    pdfstreamlength = 0;
    pdflastbyte = 0;
    eqtb[INTBASE + PDFCOMPRESSLEVELCODE].cint = 0;
    if (eqtb[INTBASE + PDFCOMPRESSLEVELCODE].cint > 0) {
        {
            pdfprint(/* str 'Filter FlateDecode' */ 1017);
            {
                {
                    if (pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfosgetosbuf(1);
                    else if (!pdfosmode && (1 > pdfbufsize))
                        overflow(/* str 'PDF output buffer' */ 1004,
                                 pdfopbufsize);
                    else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfflush();
                }
                {
                    pdfbuf[pdfptr] = 10;
                    incr(pdfptr);
                }
            }
        }
        {
            pdfprint(/* str '>>' */ 1018);
            {
                {
                    if (pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfosgetosbuf(1);
                    else if (!pdfosmode && (1 > pdfbufsize))
                        overflow(/* str 'PDF output buffer' */ 1004,
                                 pdfopbufsize);
                    else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfflush();
                }
                {
                    pdfbuf[pdfptr] = 10;
                    incr(pdfptr);
                }
            }
        }
        {
            pdfprint(/* str 'stream' */ 1019);
            {
                {
                    if (pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfosgetosbuf(1);
                    else if (!pdfosmode && (1 > pdfbufsize))
                        overflow(/* str 'PDF output buffer' */ 1004,
                                 pdfopbufsize);
                    else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfflush();
                }
                {
                    pdfbuf[pdfptr] = 10;
                    incr(pdfptr);
                }
            }
        }
        pdfflush();
        zipwritestate = 1;
    } else {

        {
            pdfprint(/* str '>>' */ 1018);
            {
                {
                    if (pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfosgetosbuf(1);
                    else if (!pdfosmode && (1 > pdfbufsize))
                        overflow(/* str 'PDF output buffer' */ 1004,
                                 pdfopbufsize);
                    else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfflush();
                }
                {
                    pdfbuf[pdfptr] = 10;
                    incr(pdfptr);
                }
            }
        }
        {
            pdfprint(/* str 'stream' */ 1019);
            {
                {
                    if (pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfosgetosbuf(1);
                    else if (!pdfosmode && (1 > pdfbufsize))
                        overflow(/* str 'PDF output buffer' */ 1004,
                                 pdfopbufsize);
                    else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfflush();
                }
                {
                    pdfbuf[pdfptr] = 10;
                    incr(pdfptr);
                }
            }
        }
        pdfsaveoffset = (pdfgone + pdfptr);
    }
}
void pdfendstream(void) {
    pdfendstream_regmem if (zipwritestate == 1) zipwritestate = 2;
    else pdfstreamlength = (pdfgone + pdfptr) - pdfsaveoffset;
    pdfflush();
    if (pdfseekwritelength)
        writestreamlength(pdfstreamlength, pdfstreamlengthoffset);
    pdfseekwritelength = false;
    {{if (pdfosmode && (1 + pdfptr > pdfbufsize)) pdfosgetosbuf(1);
    else if (!pdfosmode && (1 > pdfbufsize))
        overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
    else if (!pdfosmode && (1 + pdfptr > pdfbufsize)) pdfflush();
}
{
    pdfbuf[pdfptr] = 10;
    incr(pdfptr);
}
}
{
    pdfprint(/* str 'endstream' */ 1020);
    {
        {
            if (pdfosmode && (1 + pdfptr > pdfbufsize))
                pdfosgetosbuf(1);
            else if (!pdfosmode && (1 > pdfbufsize))
                overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
            else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                pdfflush();
        }
        {
            pdfbuf[pdfptr] = 10;
            incr(pdfptr);
        }
    }
}
pdfendobj();
}
void zadvcharwidth(internalfontnumber f, eightbits c) {
    advcharwidth_regmem scaled w, sout;
    integer s;
    w = fontinfo[widthbase[f] +
                 fontinfo[charbase[f] + effectivechar(true, f, c)].qqqq.b0]
            .cint;
    if (isscalable(f)) {
        if (pdfcurTma == 0) {
            {
                if (dividescaled(w, pdffontsize[f], 4) != 0)
                    ;
            }
            pdfdeltah = pdfdeltah + scaledout;
        } else {

            s = dividescaled(roundxnoverd(w, 1000, 1000 + pdfcurTma),
                             pdffontsize[f], 4);
            sout = roundxnoverd(roundxnoverd(pdffontsize[f], abs(s), 10000),
                                1000 + pdfcurTma, 1000);
            if (s < 0)
                sout = -(integer)sout;
            pdfdeltah = pdfdeltah + sout;
        }
    } else
        pdfdeltah = pdfdeltah + getpkcharwidth(f, w);
}
void zpdfprintreal(integer m, integer d) {
    pdfprintreal_regmem if (m < 0) {
        {
            {
                if (pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfosgetosbuf(1);
                else if (!pdfosmode && (1 > pdfbufsize))
                    overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
                else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfflush();
            }
            {
                pdfbuf[pdfptr] = /* str '-' */ 45;
                incr(pdfptr);
            }
        }
        m = -(integer)m;
    }
    pdfprintint(m / tenpow[d]);
    m = m % tenpow[d];
    if (m > 0) {
        {
            {
                if (pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfosgetosbuf(1);
                else if (!pdfosmode && (1 > pdfbufsize))
                    overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
                else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfflush();
            }
            {
                pdfbuf[pdfptr] = /* str '.' */ 46;
                incr(pdfptr);
            }
        }
        decr(d);
        while (m < tenpow[d]) {

            {
                {
                    if (pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfosgetosbuf(1);
                    else if (!pdfosmode && (1 > pdfbufsize))
                        overflow(/* str 'PDF output buffer' */ 1004,
                                 pdfopbufsize);
                    else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfflush();
                }
                {
                    pdfbuf[pdfptr] = /* str '0' */ 48;
                    incr(pdfptr);
                }
            }
            decr(d);
        }
        while (m % 10 == 0)
            m = m / 10;
        pdfprintint(m);
    }
}
void zpdfprintbp(scaled s) {
    pdfprintbp_regmem pdfprintreal(
        dividescaled(s, onehundredbp, fixeddecimaldigits + 2),
        fixeddecimaldigits);
}
void zpdfprintmagbp(scaled s) {
    pdfprintmagbp_regmem preparemag();
    if (eqtb[INTBASE + MAGCODE].cint != 1000)
        s = roundxnoverd(s, eqtb[INTBASE + MAGCODE].cint, 1000);
    pdfprintbp(s);
}
void zpdfsetorigin(scaled h, scaled v) {
    pdfsetorigin_regmem if ((abs(h - pdforiginh) >= minbpval) ||
                            (abs(v - pdforiginv) >= minbpval)) {
        pdfprint(/* str '1 0 0 1 ' */ 1029);
        pdfprintbp(h - pdforiginh);
        pdforiginh = pdforiginh + scaledout;
        {
            {
                if (pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfosgetosbuf(1);
                else if (!pdfosmode && (1 > pdfbufsize))
                    overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
                else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfflush();
            }
            {
                pdfbuf[pdfptr] = /* str ' ' */ 32;
                incr(pdfptr);
            }
        }
        pdfprintbp(pdforiginv - v);
        pdforiginv = pdforiginv - scaledout;
        {
            pdfprint(/* str ' cm' */ 1030);
            {
                {
                    if (pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfosgetosbuf(1);
                    else if (!pdfosmode && (1 > pdfbufsize))
                        overflow(/* str 'PDF output buffer' */ 1004,
                                 pdfopbufsize);
                    else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfflush();
                }
                {
                    pdfbuf[pdfptr] = 10;
                    incr(pdfptr);
                }
            }
        }
    }
    pdfh = pdforiginh;
    pdftjstarth = pdfh;
    pdfv = pdforiginv;
}
void zpdfsetorigintemp(scaled h, scaled v) {
    pdfsetorigintemp_regmem if ((abs(h - pdforiginh) >= minbpval) ||
                                (abs(v - pdforiginv) >= minbpval)) {
        pdfprint(/* str '1 0 0 1 ' */ 1029);
        pdfprintbp(h - pdforiginh);
        {
            {
                if (pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfosgetosbuf(1);
                else if (!pdfosmode && (1 > pdfbufsize))
                    overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
                else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfflush();
            }
            {
                pdfbuf[pdfptr] = /* str ' ' */ 32;
                incr(pdfptr);
            }
        }
        pdfprintbp(pdforiginv - v);
        {
            pdfprint(/* str ' cm' */ 1030);
            {
                {
                    if (pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfosgetosbuf(1);
                    else if (!pdfosmode && (1 > pdfbufsize))
                        overflow(/* str 'PDF output buffer' */ 1004,
                                 pdfopbufsize);
                    else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfflush();
                }
                {
                    pdfbuf[pdfptr] = 10;
                    incr(pdfptr);
                }
            }
        }
    }
}
void pdfendstring(void) {
    pdfendstring_regmem if (pdfdoingstring) {
        pdfprint(/* str ')]TJ' */ 1031);
        pdfdoingstring = false;
    }
}
void pdfendstringnl(void) {
    pdfendstringnl_regmem if (pdfdoingstring) {
        {
            pdfprint(/* str ')]TJ' */ 1031);
            {
                {
                    if (pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfosgetosbuf(1);
                    else if (!pdfosmode && (1 > pdfbufsize))
                        overflow(/* str 'PDF output buffer' */ 1004,
                                 pdfopbufsize);
                    else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfflush();
                }
                {
                    pdfbuf[pdfptr] = 10;
                    incr(pdfptr);
                }
            }
        }
        pdfdoingstring = false;
    }
}
void zpdfsettextmatrix(scaled v, scaled vout, internalfontnumber f) {
    pdfsettextmatrix_regmem integer pdfnewTma;
    {
        {
            if (pdfosmode && (1 + pdfptr > pdfbufsize))
                pdfosgetosbuf(1);
            else if (!pdfosmode && (1 > pdfbufsize))
                overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
            else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                pdfflush();
        }
        {
            pdfbuf[pdfptr] = /* str ' ' */ 32;
            incr(pdfptr);
        }
    }
    if (f == pdff)
        pdfnewTma = pdfcurTma;
    else if (!pdffontautoexpand[f])
        pdfnewTma = 0;
    else
        pdfnewTma = pdffontexpandratio[f];
    if ((pdfnewTma != 0) || ((pdfnewTma == 0) && (pdfcurTma != 0))) {
        pdfprintreal(1000 + pdfnewTma, 3);
        pdfprint(/* str ' 0 0 1 ' */ 1032);
        pdfprintbp(curh - pdforiginh);
        pdfh = pdforiginh + scaledout;
        {
            {
                if (pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfosgetosbuf(1);
                else if (!pdfosmode && (1 > pdfbufsize))
                    overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
                else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfflush();
            }
            {
                pdfbuf[pdfptr] = /* str ' ' */ 32;
                incr(pdfptr);
            }
        }
        pdfprintbp(pdforiginv - curv);
        pdfv = pdforiginv - scaledout;
        pdfprint(/* str ' Tm' */ 1033);
        pdfcurTma = pdfnewTma;
        pdfassert(pdfcurTma > -1000);
    } else {

        pdfprintbp(curh - pdftjstarth);
        pdfh = pdftjstarth + scaledout;
        {
            {
                if (pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfosgetosbuf(1);
                else if (!pdfosmode && (1 > pdfbufsize))
                    overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
                else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfflush();
            }
            {
                pdfbuf[pdfptr] = /* str ' ' */ 32;
                incr(pdfptr);
            }
        }
        pdfprintreal(v, fixeddecimaldigits);
        pdfv = pdfv - vout;
        pdfprint(/* str ' Td' */ 1034);
    }
    pdftjstarth = pdfh;
    pdfdeltah = 0;
}
void zpdfusefont(internalfontnumber f, integer fontnum) {
    pdfusefont_regmem {
        if (dividescaled(fontsize[f], onehundredbp, 6) != 0)
            ;
    }
    pdffontsize[f] = scaledout;
    fontused[f] = true;
    pdfassert((fontnum > 0) ||
              ((fontnum < 0) && (pdffontnum[-(integer)fontnum] > 0)));
    pdffontnum[f] = fontnum;
    if (eqtb[INTBASE + PDFMOVECHARSCODE].cint > 0) {
        pdfwarning(0, /* str 'Primitive \pdfmovechars is obsolete.' */ 1035,
                   true, true);
        eqtb[INTBASE + PDFMOVECHARSCODE].cint = 0;
    }
}
void zpdfinitfont(internalfontnumber f) {
    pdfinitfont_regmem internalfontnumber k, b;
    integer i;
    pdfassert(!fontused[f]);
    if (pdffontautoexpand[f] && (pdffontblink[f] != FONTBASE)) {
        b = pdffontblink[f];
        if (!isscalable(b))
            pdferror(
                /* str 'font expansion' */ 1036,
                /* str 'auto expansion is only possible with scalable fon' */
                1037);
        if (!fontused[b])
            pdfinitfont(b);
        pdffontmap[f] = pdffontmap[b];
    }
    if (isscalable(f)) {
        i = headtab[3];
        while (i != 0) {

            k = objtab[i].int0;
            if (isscalable(k) && (pdffontmap[k] == pdffontmap[f]) &&
                (streqstr(fontname[k], fontname[f]) ||
                 (pdffontautoexpand[f] && (pdffontblink[f] != FONTBASE) &&
                  streqstr(fontname[k], fontname[pdffontblink[f]])))) {
                pdfassert(pdffontnum[k] != 0);
                if (pdffontnum[k] < 0)
                    pdfusefont(f, pdffontnum[k]);
                else
                    pdfusefont(f, -(integer)k);
                return;
            }
            i = objtab[i].int1;
        }
    }
    pdfcreateobj(3, f);
    pdfusefont(f, objptr);
}
void pdfinitfontcurval(void) { pdfinitfontcurval_regmem pdfinitfont(curval); }
void zpdfsetfont(internalfontnumber f) {
    pdfsetfont_regmem halfword p;
    internalfontnumber k;
    if (!fontused[f])
        pdfinitfont(f);
    {
        if (pdffontnum[f] < 0)
            ff = -(integer)pdffontnum[f];
        else
            ff = f;
    }
    k = ff;
    p = pdffontlist;
    while (p != TEXNULL) {

        {
            if (pdffontnum[mem[p].hh.v.LH] < 0)
                ff = -(integer)pdffontnum[mem[p].hh.v.LH];
            else
                ff = mem[p].hh.v.LH;
        }
        if (ff == k)
            goto labpdfsetfont40found;
        p = mem[p].hh.v.RH;
    }
    {
        pdfappendlistarg = f;
        pdffontlist = appendptr(pdffontlist, pdfappendlistarg);
    }
labpdfsetfont40found:
    if ((k == pdflastf) && (fontsize[f] == pdflastfs))
        return;
    pdfprint(/* str 'F' */ 1038);
    pdfprintint(k);
    if (pdfresnameprefix != 0)
        pdfprint(pdfresnameprefix);
    {
        {
            if (pdfosmode && (1 + pdfptr > pdfbufsize))
                pdfosgetosbuf(1);
            else if (!pdfosmode && (1 > pdfbufsize))
                overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
            else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                pdfflush();
        }
        {
            pdfbuf[pdfptr] = /* str ' ' */ 32;
            incr(pdfptr);
        }
    }
    pdfprintreal(dividescaled(fontsize[f], onehundredbp, 6), 4);
    pdfprint(/* str ' Tf' */ 1039);
    pdflastf = k;
    pdflastfs = fontsize[f];
}
void pdfbegintext(void) {
    pdfbegintext_regmem pdfsetorigin(0, curpageheight);
    {
        pdfprint(/* str 'BT' */ 1040);
        {
            {
                if (pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfosgetosbuf(1);
                else if (!pdfosmode && (1 > pdfbufsize))
                    overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
                else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfflush();
            }
            {
                pdfbuf[pdfptr] = 10;
                incr(pdfptr);
            }
        }
    }
    pdfdoingtext = true;
    pdff = FONTBASE;
    pdflastf = FONTBASE;
    pdflastfs = 0;
    pdfdoingstring = false;
    pdfcurTma = 0;
}
void pdfreaddummyfont(void) {
    pdfreaddummyfont_regmem if (pdfdummyfont == FONTBASE) {
        pdfdummyfont = readfontinfo(NULLCS, /* str 'dummy-space' */ 1041,
                                    /* str '' */ 345, onebp);
        pdfmarkchar(pdfdummyfont, 32);
    }
}
void pdfinsertinterwordspace(void) {
    pdfinsertinterwordspace_regmem pdfreaddummyfont();
    pdfsetfont(pdfdummyfont);
    pdfprint(/* str '( )Tj' */ 1042);
}
void zpdfbeginstring(internalfontnumber f, halfword p) {
    pdfbeginstring_regmem scaled sout, v, vout;
    integer s;
    boolean mustendstring;
    boolean mustinsertspace;
    if (!pdfdoingtext)
        pdfbegintext();
    if (f != pdff) {
        pdfendstring();
        pdfsetfont(f);
    }
    if (pdfcurTma == 0) {
        s = dividescaled(curh - (pdftjstarth + pdfdeltah), pdffontsize[f], 3);
        sout = scaledout;
    } else {

        s = dividescaled(roundxnoverd(curh - (pdftjstarth + pdfdeltah), 1000,
                                      1000 + pdfcurTma),
                         pdffontsize[f], 3);
        if (abs(s) < 32768L) {
            sout = roundxnoverd(roundxnoverd(pdffontsize[f], abs(s), 1000),
                                1000 + pdfcurTma, 1000);
            if (s < 0)
                sout = -(integer)sout;
        }
    }
    if (abs(curv - pdfv) >= minbpval) {
        v = dividescaled(pdfv - curv, onehundredbp, fixeddecimaldigits + 2);
        vout = scaledout;
    } else {

        v = 0;
        vout = 0;
    }
    mustinsertspace = false;
    mustendstring = false;
    if (genfakedinterwordspace &&
        ((abs(vout) > 2 * fontinfo[XHEIGHTCODE + parambase[f]].cint) ||
         (sout > fontinfo[SPACECODE + parambase[f]].cint -
                     fontinfo[SPACESHRINKCODE + parambase[f]].cint) ||
         ((f != pdff) && (v == 0)))) {
        mustinsertspace = true;
    }
    if ((f != pdff) || (v != 0) || (abs(s) >= 32768L) || mustinsertspace) {
        mustendstring = true;
    }
    if (mustendstring) {
        pdfendstring();
        if (mustinsertspace) {
            pdfinsertinterwordspace();
            pdfsetfont(f);
        }
        pdfsettextmatrix(v, vout, f);
        pdff = f;
        s = 0;
    }
    if (!pdfdoingstring) {
        pdfprint(/* str ' ' */ 32);
        pdfprintint(obtaincharacterinfo(p, 0));
        pdfprint(/* str ' i ' */ 1049);
        pdfprintint(obtaincharacterinfo(p, 1));
        pdfprint(/* str ' J [' */ 1050);
        if (s == 0)
            pdfprint(/* str '(' */ 40);
    }
    if (s != 0) {
        if (pdfdoingstring) {
            {
                if (pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfosgetosbuf(1);
                else if (!pdfosmode && (1 > pdfbufsize))
                    overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
                else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfflush();
            }
            {
                pdfbuf[pdfptr] = /* str ')' */ 41;
                incr(pdfptr);
            }
        }
        pdfprintint(-(integer)s);
        pdfprint(/* str ']TJ ' */ 1051);
        pdfprintint(obtaincharacterinfo(p, 0));
        pdfprint(/* str ' i ' */ 1049);
        pdfprintint(obtaincharacterinfo(p, 1));
        pdfprint(/* str ' J [(' */ 1052);
        pdfdeltah = pdfdeltah + sout;
    } else {

        pdfprint(/* str ')' */ 41);
        pdfprintint(-1);
        pdfprint(/* str ']TJ ' */ 1051);
        pdfprintint(obtaincharacterinfo(p, 0));
        pdfprint(/* str ' i ' */ 1049);
        pdfprintint(obtaincharacterinfo(p, 1));
        pdfprint(/* str ' J [(' */ 1052);
    }
    pdfdoingstring = true;
}
void pdfinsertfakespace(void) {
    pdfinsertfakespace_regmem integer s;
    s = genfakedinterwordspace;
    genfakedinterwordspace = 0;
    pdfreaddummyfont();
    pdfbeginstring(pdfdummyfont, 0);
    pdfprint(/* str ' ' */ 32);
    pdfendstringnl();
    genfakedinterwordspace = s;
}
void pdfendtext(void) {
    pdfendtext_regmem if (pdfdoingtext) {
        pdfendstringnl();
        {
            pdfprint(/* str 'ET' */ 1053);
            {
                {
                    if (pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfosgetosbuf(1);
                    else if (!pdfosmode && (1 > pdfbufsize))
                        overflow(/* str 'PDF output buffer' */ 1004,
                                 pdfopbufsize);
                    else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfflush();
                }
                {
                    pdfbuf[pdfptr] = 10;
                    incr(pdfptr);
                }
            }
        }
        pdfdoingtext = false;
    }
}
void zpdfsetrule(scaled x, scaled y, scaled w, scaled h) {
    pdfsetrule_regmem pdfendtext();
    {
        pdfprint(/* str 'q' */ 113);
        {
            {
                if (pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfosgetosbuf(1);
                else if (!pdfosmode && (1 > pdfbufsize))
                    overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
                else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfflush();
            }
            {
                pdfbuf[pdfptr] = 10;
                incr(pdfptr);
            }
        }
    }
    if (h <= onebp) {
        pdfsetorigintemp(x, y - (h + 1) / ((double)2));
        pdfprint(/* str '[]0 d 0 J ' */ 1054);
        pdfprintbp(h);
        pdfprint(/* str ' w 0 0 m ' */ 1055);
        pdfprintbp(w);
        {
            pdfprint(/* str ' 0 l S' */ 1056);
            {
                {
                    if (pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfosgetosbuf(1);
                    else if (!pdfosmode && (1 > pdfbufsize))
                        overflow(/* str 'PDF output buffer' */ 1004,
                                 pdfopbufsize);
                    else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfflush();
                }
                {
                    pdfbuf[pdfptr] = 10;
                    incr(pdfptr);
                }
            }
        }
    } else if (w <= onebp) {
        pdfsetorigintemp(x + (w + 1) / ((double)2), y);
        pdfprint(/* str '[]0 d 0 J ' */ 1054);
        pdfprintbp(w);
        pdfprint(/* str ' w 0 0 m 0 ' */ 1057);
        pdfprintbp(h);
        {
            pdfprint(/* str ' l S' */ 1058);
            {
                {
                    if (pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfosgetosbuf(1);
                    else if (!pdfosmode && (1 > pdfbufsize))
                        overflow(/* str 'PDF output buffer' */ 1004,
                                 pdfopbufsize);
                    else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfflush();
                }
                {
                    pdfbuf[pdfptr] = 10;
                    incr(pdfptr);
                }
            }
        }
    } else {

        pdfsetorigintemp(x, y);
        pdfprint(/* str '0 0 ' */ 1059);
        pdfprintbp(w);
        {
            {
                if (pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfosgetosbuf(1);
                else if (!pdfosmode && (1 > pdfbufsize))
                    overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
                else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfflush();
            }
            {
                pdfbuf[pdfptr] = /* str ' ' */ 32;
                incr(pdfptr);
            }
        }
        pdfprintbp(h);
        {
            pdfprint(/* str ' re f' */ 1060);
            {
                {
                    if (pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfosgetosbuf(1);
                    else if (!pdfosmode && (1 > pdfbufsize))
                        overflow(/* str 'PDF output buffer' */ 1004,
                                 pdfopbufsize);
                    else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfflush();
                }
                {
                    pdfbuf[pdfptr] = 10;
                    incr(pdfptr);
                }
            }
        }
    }
    {
        pdfprint(/* str 'Q' */ 81);
        {
            {
                if (pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfosgetosbuf(1);
                else if (!pdfosmode && (1 > pdfbufsize))
                    overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
                else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfflush();
            }
            {
                pdfbuf[pdfptr] = 10;
                incr(pdfptr);
            }
        }
    }
}
void zpdfrectangle(scaled left, scaled top, scaled right, scaled bottom) {
    pdfrectangle_regmem preparemag();
    pdfprint(/* str 'Rect [' */ 1061);
    pdfprintmagbp(((left)-pdforiginh));
    {
        {
            if (pdfosmode && (1 + pdfptr > pdfbufsize))
                pdfosgetosbuf(1);
            else if (!pdfosmode && (1 > pdfbufsize))
                overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
            else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                pdfflush();
        }
        {
            pdfbuf[pdfptr] = /* str ' ' */ 32;
            incr(pdfptr);
        }
    }
    pdfprintmagbp((pdforiginv - (bottom)));
    {
        {
            if (pdfosmode && (1 + pdfptr > pdfbufsize))
                pdfosgetosbuf(1);
            else if (!pdfosmode && (1 > pdfbufsize))
                overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
            else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                pdfflush();
        }
        {
            pdfbuf[pdfptr] = /* str ' ' */ 32;
            incr(pdfptr);
        }
    }
    pdfprintmagbp(((right)-pdforiginh));
    {
        {
            if (pdfosmode && (1 + pdfptr > pdfbufsize))
                pdfosgetosbuf(1);
            else if (!pdfosmode && (1 > pdfbufsize))
                overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
            else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                pdfflush();
        }
        {
            pdfbuf[pdfptr] = /* str ' ' */ 32;
            incr(pdfptr);
        }
    }
    pdfprintmagbp((pdforiginv - (top)));
    {
        pdfprint(/* str ']' */ 93);
        {
            {
                if (pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfosgetosbuf(1);
                else if (!pdfosmode && (1 > pdfbufsize))
                    overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
                else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfflush();
            }
            {
                pdfbuf[pdfptr] = 10;
                incr(pdfptr);
            }
        }
    }
}
void zslowprintsubstr(integer s, integer maxlen) {
    slowprintsubstr_regmem poolpointer j;
    if ((s >= strptr) || (s < 256))
        print(s);
    else {

        j = strstart[s];
        while ((j < strstart[s + 1]) && (j <= strstart[s] + maxlen)) {

            print(strpool[j]);
            incr(j);
        }
    }
    if (j < strstart[s + 1])
        print(/* str '...' */ 277);
}
void zliteral(strnumber s, integer literalmode, boolean warn) {
    literal_regmem poolpointer j;
    j = strstart[s];
    if (literalmode == 3) {
        if (!(strinstr(s, /* str 'PDF' */ 1062, 0) ||
              strinstr(s, /* str 'pdf' */ 1063, 0))) {
            if (warn && !(strinstr(s, /* str 'SRC' */ 1064, 0) ||
                          strinstr(s, /* str 'src' */ 1065, 0) ||
                          ((strstart[s + 1] - strstart[s]) == 0))) {
                printnl(/* str 'Non-PDF special ignored!' */ 1066);
                printnl(/* str '<special> ' */ 1067);
                slowprintsubstr(s, 64);
                println();
            }
            return;
        }
        j = j +
            (strstart[/* str 'PDF' */ 1063] - strstart[/* str 'PDF' */ 1062]);
        if (strinstr(s, /* str 'direct' */ 1068,
                     (strstart[/* str 'PDF' */ 1063] -
                      strstart[/* str 'PDF' */ 1062]))) {
            j = j + (strstart[/* str 'direct' */ 1069] -
                     strstart[/* str 'direct' */ 1068]);
            literalmode = 2;
        } else if (strinstr(s, /* str 'page' */ 1069,
                            (strstart[/* str 'PDF' */ 1063] -
                             strstart[/* str 'PDF' */ 1062]))) {
            j = j + (strstart[/* str 'page' */ 1070] -
                     strstart[/* str 'page' */ 1069]);
            literalmode = 1;
        } else
            literalmode = 0;
    }
    switch (literalmode) {
    case 0: {
        pdfendtext();
        pdfsetorigin(curh, curv);
    } break;
    case 1:
        pdfendtext();
        break;
    case 2:
        pdfendstringnl();
        break;
    default:
        confusion(/* str 'literal1' */ 1070);
        break;
    }
    while (j < strstart[s + 1]) {

        {
            {
                if (pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfosgetosbuf(1);
                else if (!pdfosmode && (1 > pdfbufsize))
                    overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
                else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfflush();
            }
            {
                pdfbuf[pdfptr] = strpool[j];
                incr(pdfptr);
            }
        }
        incr(j);
    }
    {
        {
            if (pdfosmode && (1 + pdfptr > pdfbufsize))
                pdfosgetosbuf(1);
            else if (!pdfosmode && (1 > pdfbufsize))
                overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
            else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                pdfflush();
        }
        {
            pdfbuf[pdfptr] = 10;
            incr(pdfptr);
        }
    }
}
void zpdfprintfwint(longinteger n, integer w) {
    pdfprintfwint_regmem integer k;
    k = 0;
    do {
        dig[k] = n % 10;
        n = n / 10;
        incr(k);
    } while (!(k == w));
    {
        if (pdfosmode && (k + pdfptr > pdfbufsize))
            pdfosgetosbuf(k);
        else if (!pdfosmode && (k > pdfbufsize))
            overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
        else if (!pdfosmode && (k + pdfptr > pdfbufsize))
            pdfflush();
    }
    while (k > 0) {

        decr(k);
        {
            pdfbuf[pdfptr] = /* str '0' */ 48 + dig[k];
            incr(pdfptr);
        }
    }
}
void zpdfoutbytes(longinteger n, integer w) {
    pdfoutbytes_regmem integer k;
    integer byte[8];
    k = 0;
    do {
        byte[k] = n % 256;
        n = n / 256;
        incr(k);
    } while (!(k == w));
    {
        if (pdfosmode && (k + pdfptr > pdfbufsize))
            pdfosgetosbuf(k);
        else if (!pdfosmode && (k > pdfbufsize))
            overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
        else if (!pdfosmode && (k + pdfptr > pdfbufsize))
            pdfflush();
    }
    while (k > 0) {

        decr(k);
        {
            pdfbuf[pdfptr] = byte[k];
            incr(pdfptr);
        }
    }
}
void zpdfintentry(strnumber s, integer v) {
    pdfintentry_regmem {
        {
            if (pdfosmode && (1 + pdfptr > pdfbufsize))
                pdfosgetosbuf(1);
            else if (!pdfosmode && (1 > pdfbufsize))
                overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
            else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                pdfflush();
        }
        {
            pdfbuf[pdfptr] = /* str '' */ 47;
            incr(pdfptr);
        }
    }
    pdfprint(s);
    {
        {
            if (pdfosmode && (1 + pdfptr > pdfbufsize))
                pdfosgetosbuf(1);
            else if (!pdfosmode && (1 > pdfbufsize))
                overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
            else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                pdfflush();
        }
        {
            pdfbuf[pdfptr] = /* str ' ' */ 32;
            incr(pdfptr);
        }
    }
    pdfprintint(v);
}
void zpdfintentryln(strnumber s, integer v) {
    pdfintentryln_regmem pdfintentry(s, v);
    {
        {
            if (pdfosmode && (1 + pdfptr > pdfbufsize))
                pdfosgetosbuf(1);
            else if (!pdfosmode && (1 > pdfbufsize))
                overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
            else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                pdfflush();
        }
        {
            pdfbuf[pdfptr] = 10;
            incr(pdfptr);
        }
    }
}
void zpdfindirect(strnumber s, integer o) {
    pdfindirect_regmem {
        {
            if (pdfosmode && (1 + pdfptr > pdfbufsize))
                pdfosgetosbuf(1);
            else if (!pdfosmode && (1 > pdfbufsize))
                overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
            else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                pdfflush();
        }
        {
            pdfbuf[pdfptr] = /* str '' */ 47;
            incr(pdfptr);
        }
    }
    pdfprint(s);
    {
        {
            if (pdfosmode && (1 + pdfptr > pdfbufsize))
                pdfosgetosbuf(1);
            else if (!pdfosmode && (1 > pdfbufsize))
                overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
            else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                pdfflush();
        }
        {
            pdfbuf[pdfptr] = /* str ' ' */ 32;
            incr(pdfptr);
        }
    }
    pdfprintint(o);
    pdfprint(/* str ' 0 R' */ 1080);
}
void zpdfindirectln(strnumber s, integer o) {
    pdfindirectln_regmem pdfindirect(s, o);
    {
        {
            if (pdfosmode && (1 + pdfptr > pdfbufsize))
                pdfosgetosbuf(1);
            else if (!pdfosmode && (1 > pdfbufsize))
                overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
            else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                pdfflush();
        }
        {
            pdfbuf[pdfptr] = 10;
            incr(pdfptr);
        }
    }
}
void zpdfprintstr(strnumber s) {
    pdfprintstr_regmem poolpointer i, j;
    boolean ishexstring;
    i = strstart[s];
    j = i + (strstart[s + 1] - strstart[s]) - 1;
    if (i > j) {
        pdfprint(/* str '()' */ 1081);
        return;
    }
    if ((strpool[i] == '(') && (strpool[j] == ')')) {
        pdfprint(s);
        return;
    }
    ishexstring = false;
    if ((strpool[i] != '<') || (strpool[j] != '>') ||
        odd((strstart[s + 1] - strstart[s])))
        goto labpdfprintstr30done;
    incr(i);
    decr(j);
    while (i < j) {

        if ((((strpool[i] >= '0') && (strpool[i] <= '9')) ||
             ((strpool[i] >= 'A') && (strpool[i] <= 'F')) ||
             ((strpool[i] >= 'a') && (strpool[i] <= 'f'))) &&
            (((strpool[i + 1] >= '0') && (strpool[i + 1] <= '9')) ||
             ((strpool[i + 1] >= 'A') && (strpool[i + 1] <= 'F')) ||
             ((strpool[i + 1] >= 'a') && (strpool[i + 1] <= 'f'))))
            i = i + 2;
        else
            goto labpdfprintstr30done;
    }
    ishexstring = true;
labpdfprintstr30done:
    if (ishexstring)
        pdfprint(s);
    else {

        {
            {
                if (pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfosgetosbuf(1);
                else if (!pdfosmode && (1 > pdfbufsize))
                    overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
                else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfflush();
            }
            {
                pdfbuf[pdfptr] = /* str '(' */ 40;
                incr(pdfptr);
            }
        }
        pdfprint(s);
        {
            {
                if (pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfosgetosbuf(1);
                else if (!pdfosmode && (1 > pdfbufsize))
                    overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
                else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfflush();
            }
            {
                pdfbuf[pdfptr] = /* str ')' */ 41;
                incr(pdfptr);
            }
        }
    }
}
void zpdfprintstrln(strnumber s) {
    pdfprintstrln_regmem pdfprintstr(s);
    {
        {
            if (pdfosmode && (1 + pdfptr > pdfbufsize))
                pdfosgetosbuf(1);
            else if (!pdfosmode && (1 > pdfbufsize))
                overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
            else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                pdfflush();
        }
        {
            pdfbuf[pdfptr] = 10;
            incr(pdfptr);
        }
    }
}
void zpdfstrentry(strnumber s, strnumber v) {
    pdfstrentry_regmem if (v == 0) return;
    {
        {
            if (pdfosmode && (1 + pdfptr > pdfbufsize))
                pdfosgetosbuf(1);
            else if (!pdfosmode && (1 > pdfbufsize))
                overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
            else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                pdfflush();
        }
        {
            pdfbuf[pdfptr] = /* str '' */ 47;
            incr(pdfptr);
        }
    }
    pdfprint(s);
    {
        {
            if (pdfosmode && (1 + pdfptr > pdfbufsize))
                pdfosgetosbuf(1);
            else if (!pdfosmode && (1 > pdfbufsize))
                overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
            else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                pdfflush();
        }
        {
            pdfbuf[pdfptr] = /* str ' ' */ 32;
            incr(pdfptr);
        }
    }
    pdfprintstr(v);
}
void zpdfstrentryln(strnumber s, strnumber v) {
    pdfstrentryln_regmem if (v == 0) return;
    pdfstrentry(s, v);
    {
        {
            if (pdfosmode && (1 + pdfptr > pdfbufsize))
                pdfosgetosbuf(1);
            else if (!pdfosmode && (1 > pdfbufsize))
                overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
            else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                pdfflush();
        }
        {
            pdfbuf[pdfptr] = 10;
            incr(pdfptr);
        }
    }
}
void zsettagcode(internalfontnumber f, eightbits c, integer i) {
    settagcode_regmem integer fixedi;
    if (((fontbc[f] <= c) && (c <= fontec[f]) &&
         (fontinfo[charbase[f] + c].qqqq.b0 > MINQUARTERWORD))) {
        fixedi = abs(fixint(i, -7, 0));
        if (fixedi >= 4) {
            if (((fontinfo[charbase[f] + effectivechar(true, f, c)].qqqq.b2) %
                 4) == EXTTAG)
                fontinfo[charbase[f] + effectivechar(true, f, c)].qqqq.b2 =
                    (fontinfo[charbase[f] + effectivechar(true, f, c)]
                         .qqqq.b2) /* @d7190@ */
                    - 3;
            fixedi = fixedi - 4;
        }
        if (fixedi >= 2) {
            if (((fontinfo[charbase[f] + effectivechar(true, f, c)].qqqq.b2) %
                 4) == LISTTAG)
                fontinfo[charbase[f] + effectivechar(true, f, c)].qqqq.b2 =
                    (fontinfo[charbase[f] + effectivechar(true, f, c)]
                         .qqqq.b2) /* @d7192@ */
                    - 2;
            fixedi = fixedi - 2;
        }
        if (fixedi >= 1) {
            if (((fontinfo[charbase[f] + effectivechar(true, f, c)].qqqq.b2) %
                 4) == LIGTAG)
                fontinfo[charbase[f] + effectivechar(true, f, c)].qqqq.b2 =
                    (fontinfo[charbase[f] + effectivechar(true, f, c)]
                         .qqqq.b2) /* @d7194@ */
                    - 1;
        }
    }
}
void zsetnoligatures(internalfontnumber f) {
    setnoligatures_regmem integer c;
    {
        register integer for_end;
        c = fontbc[f];
        for_end = fontec[f];
        if (c <= for_end)
            do
                if ((fontinfo[charbase[f] + c].qqqq.b0 > MINQUARTERWORD)) {

                    if (((fontinfo[charbase[f] + c].qqqq.b2) % 4) == LIGTAG)
                        fontinfo[charbase[f] + c].qqqq.b2 =
                            (fontinfo[charbase[f] + c].qqqq.b2) /* @d7197@ */ -
                            1;
                }
            while (c++ < for_end);
    }
}
integer zinitfontbase(integer v) {
    register integer Result;
    initfontbase_regmem integer i, j;
    i = pdfgetmem(256);
    {
        register integer for_end;
        j = 0;
        for_end = 255;
        if (j <= for_end)
            do
                pdfmem[i + j] = v;
            while (j++ < for_end);
    }
    Result = i;
    return Result;
}
void zsetlpcode(internalfontnumber f, eightbits c, integer i) {
    setlpcode_regmem if (pdffontlpbase[f] == 0) pdffontlpbase[f] =
        initfontbase(0);
    pdfmem[pdffontlpbase[f] + c] = fixint(i, -1000, 1000);
}
void zsetrpcode(internalfontnumber f, eightbits c, integer i) {
    setrpcode_regmem if (pdffontrpbase[f] == 0) pdffontrpbase[f] =
        initfontbase(0);
    pdfmem[pdffontrpbase[f] + c] = fixint(i, -1000, 1000);
}
void zsetefcode(internalfontnumber f, eightbits c, integer i) {
    setefcode_regmem if (pdffontefbase[f] == 0) pdffontefbase[f] =
        initfontbase(1000);
    pdfmem[pdffontefbase[f] + c] = fixint(i, 0, 1000);
}
void zsetknbscode(internalfontnumber f, eightbits c, integer i) {
    setknbscode_regmem if (pdffontknbsbase[f] == 0) pdffontknbsbase[f] =
        initfontbase(0);
    pdfmem[pdffontknbsbase[f] + c] = fixint(i, -1000, 1000);
}
void zsetstbscode(internalfontnumber f, eightbits c, integer i) {
    setstbscode_regmem if (pdffontstbsbase[f] == 0) pdffontstbsbase[f] =
        initfontbase(0);
    pdfmem[pdffontstbsbase[f] + c] = fixint(i, -1000, 1000);
}
void zsetshbscode(internalfontnumber f, eightbits c, integer i) {
    setshbscode_regmem if (pdffontshbsbase[f] == 0) pdffontshbsbase[f] =
        initfontbase(0);
    pdfmem[pdffontshbsbase[f] + c] = fixint(i, -1000, 1000);
}
void zsetknbccode(internalfontnumber f, eightbits c, integer i) {
    setknbccode_regmem if (pdffontknbcbase[f] == 0) pdffontknbcbase[f] =
        initfontbase(0);
    pdfmem[pdffontknbcbase[f] + c] = fixint(i, -1000, 1000);
}
void zsetknaccode(internalfontnumber f, eightbits c, integer i) {
    setknaccode_regmem if (pdffontknacbase[f] == 0) pdffontknacbase[f] =
        initfontbase(0);
    pdfmem[pdffontknacbase[f] + c] = fixint(i, -1000, 1000);
}
void zadjustinterwordglue(halfword p, halfword g) {
    adjustinterwordglue_regmem scaled kn, st, sh;
    halfword q, r;
    halfword c;
    internalfontnumber f;
    if (!(!(g >= himemmin) && mem[g].hh.b0 == GLUENODE)) {
        pdfwarning(/* str 'adjust_interword_glue' */ 1083,
                   /* str 'g is not a glue' */ 1084, false, false);
        return;
    }
    c = 256;
    if ((p >= himemmin)) {
        c = mem[p].hh.b1;
        f = mem[p].hh.b0;
    } else if (mem[p].hh.b0 == LIGATURENODE) {
        c = mem[p + 1].hh.b1;
        f = mem[p + 1].hh.b0;
    } else if ((mem[p].hh.b0 == KERNNODE) && (mem[p].hh.b1 == EXPLICIT) &&
               (savetail != TEXNULL)) {
        r = savetail;
        while ((mem[r].hh.v.RH != TEXNULL) && (mem[r].hh.v.RH != p))
            r = mem[r].hh.v.RH;
        if ((mem[r].hh.v.RH == p)) {

            if ((r >= himemmin)) {
                c = mem[r].hh.b1;
                f = mem[r].hh.b0;
            } else if (mem[r].hh.b0 == LIGATURENODE) {
                c = mem[r + 1].hh.b1;
                f = mem[r + 1].hh.b0;
            }
        }
    }
    if ((c == 256))
        return;
    kn = getknbscode(f, c);
    st = getstbscode(f, c);
    sh = getshbscode(f, c);
    if ((kn != 0) || (st != 0) || (sh != 0)) {
        q = newspec(mem[g + 1].hh.v.LH);
        deleteglueref(mem[g + 1].hh.v.LH);
        mem[q + WIDTHOFFSET].cint =
            mem[q + WIDTHOFFSET].cint +
            roundxnoverd(fontinfo[QUADCODE + parambase[f]].cint, kn, 1000);
        mem[q + 2].cint =
            mem[q + 2].cint +
            roundxnoverd(fontinfo[QUADCODE + parambase[f]].cint, st, 1000);
        mem[q + 3].cint =
            mem[q + 3].cint +
            roundxnoverd(fontinfo[QUADCODE + parambase[f]].cint, sh, 1000);
        mem[g + 1].hh.v.LH = q;
    }
}
halfword zgetautokern(internalfontnumber f, halfword l, halfword r) {
    register halfword Result;
    getautokern_regmem scaled tmpw;
    integer k;
    halfword p;
    pdfassert((l >= 0) && (r >= 0));
    Result = TEXNULL;
    if ((eqtb[INTBASE + PDFAPPENDKERNCODE].cint <= 0) &&
        (eqtb[INTBASE + PDFPREPENDKERNCODE].cint <= 0))
        return Result;
    tmpw = 0;
    if ((eqtb[INTBASE + PDFAPPENDKERNCODE].cint > 0) && (l < 256)) {
        k = getknaccode(f, l);
        if (k != 0)
            tmpw =
                roundxnoverd(fontinfo[QUADCODE + parambase[f]].cint, k, 1000);
    }
    if ((eqtb[INTBASE + PDFPREPENDKERNCODE].cint > 0) && (r < 256)) {
        k = getknbccode(f, r);
        if (k != 0)
            tmpw = tmpw + roundxnoverd(fontinfo[QUADCODE + parambase[f]].cint,
                                       k, 1000);
    }
    if (tmpw != 0) {
        p = newkern(tmpw);
        mem[p].hh.b1 = EXPLICIT;
        Result = p;
    }
    return Result;
}
strnumber zexpandfontname(internalfontnumber f, integer e) {
    register strnumber Result;
    expandfontname_regmem
        unsigned char oldsetting;
    oldsetting = selector;
    selector = NEWSTRING;
    print(fontname[f]);
    if (e > 0)
        print(/* str '+' */ 43);
    printint(e);
    selector = oldsetting;
    Result = makestring();
    return Result;
}
internalfontnumber zautoexpandfont(internalfontnumber f, integer e) {
    register internalfontnumber Result;
    autoexpandfont_regmem internalfontnumber k;
    integer nw, nk, ni, i;
    k = fontptr + 1;
    incr(fontptr);
    if ((fontptr >= fontmax))
        overflow(/* str 'maximum internal font number (font_max)' */ 1085,
                 fontmax);
    fontname[k] = expandfontname(f, e);
    fontarea[k] = fontarea[f];
    hash[FONTIDBASE + k].v.RH = hash[FONTIDBASE + f].v.RH;
    hyphenchar[k] = hyphenchar[f];
    skewchar[k] = skewchar[f];
    fontbchar[k] = fontbchar[f];
    fontfalsebchar[k] = fontfalsebchar[f];
    fontbc[k] = fontbc[f];
    fontec[k] = fontec[f];
    fontsize[k] = fontsize[f];
    fontdsize[k] = fontdsize[f];
    fontparams[k] = fontparams[f];
    fontglue[k] = fontglue[f];
    bcharlabel[k] = bcharlabel[f];
    charbase[k] = charbase[f];
    heightbase[k] = heightbase[f];
    depthbase[k] = depthbase[f];
    ligkernbase[k] = ligkernbase[f];
    extenbase[k] = extenbase[f];
    parambase[k] = parambase[f];
    nw = heightbase[f] - widthbase[f];
    ni = ligkernbase[f] - italicbase[f];
    nk = extenbase[f] - (kernbase[f] + 256 * (/* @d7230@ */ 128));
    if ((fmemptr + nw + ni + nk >= fontmemsize))
        overflow(
            /* str 'number of words of font memory (font_mem_size)' */ 1086,
            fontmemsize);
    widthbase[k] = fmemptr;
    italicbase[k] = widthbase[k] + nw;
    kernbase[k] = italicbase[k] + ni - 256 * (/* @d7232@ */ 128);
    fmemptr = fmemptr + nw + ni + nk;
    {
        register integer for_end;
        i = 0;
        for_end = nw - 1;
        if (i <= for_end)
            do
                fontinfo[widthbase[k] + i].cint = roundxnoverd(
                    fontinfo[widthbase[f] + i].cint, 1000 + e, 1000);
            while (i++ < for_end);
    }
    {
        register integer for_end;
        i = 0;
        for_end = ni - 1;
        if (i <= for_end)
            do
                fontinfo[italicbase[k] + i].cint = roundxnoverd(
                    fontinfo[italicbase[f] + i].cint, 1000 + e, 1000);
            while (i++ < for_end);
    }
    {
        register integer for_end;
        i = 0;
        for_end = nk - 1;
        if (i <= for_end)
            do
                fontinfo[kernbase[k] + 256 * (/* @d7233@ */ 128) + i]
                    .cint = roundxnoverd(
                    fontinfo[kernbase[f] + 256 * (/* @d7234@ */ 128) + i].cint,
                    1000 + e, 1000);
            while (i++ < for_end);
    }
    Result = k;
    return Result;
}
void zcopyexpandparams(internalfontnumber k, internalfontnumber f, integer e) {
    copyexpandparams_regmem if (pdffontrpbase[f] == 0) pdffontrpbase[f] =
        initfontbase(0);
    if (pdffontlpbase[f] == 0)
        pdffontlpbase[f] = initfontbase(0);
    if (pdffontefbase[f] == 0)
        pdffontefbase[f] = initfontbase(1000);
    pdffontexpandratio[k] = e;
    pdffontstep[k] = pdffontstep[f];
    pdffontautoexpand[k] = pdffontautoexpand[f];
    pdffontblink[k] = f;
    pdffontlpbase[k] = pdffontlpbase[f];
    pdffontrpbase[k] = pdffontrpbase[f];
    pdffontefbase[k] = pdffontefbase[f];
    if (pdffontknbsbase[f] == 0)
        pdffontknbsbase[f] = initfontbase(0);
    if (pdffontstbsbase[f] == 0)
        pdffontstbsbase[f] = initfontbase(0);
    if (pdffontshbsbase[f] == 0)
        pdffontshbsbase[f] = initfontbase(0);
    if (pdffontknbcbase[f] == 0)
        pdffontknbcbase[f] = initfontbase(0);
    if (pdffontknacbase[f] == 0)
        pdffontknacbase[f] = initfontbase(0);
    pdffontknbsbase[k] = pdffontknbsbase[f];
    pdffontstbsbase[k] = pdffontstbsbase[f];
    pdffontshbsbase[k] = pdffontshbsbase[f];
    pdffontknbcbase[k] = pdffontknbcbase[f];
    pdffontknacbase[k] = pdffontknacbase[f];
}
internalfontnumber ztfmlookup(strnumber s, scaled fs) {
    register internalfontnumber Result;
    tfmlookup_regmem internalfontnumber k;
    if (fs != 0) {
        {
            register integer for_end;
            k = /* @d7235@ */ 1;
            for_end = fontptr;
            if (k <= for_end)
                do
                    if ((fontarea[k] != /* str '...' */ 1082) &&
                        streqstr(fontname[k], s) && (fontsize[k] == fs)) {
                        flushstr(s);
                        Result = k;
                        return Result;
                    }
                while (k++ < for_end);
        }
    } else {

        {
            register integer for_end;
            k = /* @d7238@ */ 1;
            for_end = fontptr;
            if (k <= for_end)
                do
                    if ((fontarea[k] != /* str '...' */ 1082) &&
                        streqstr(fontname[k], s)) {
                        flushstr(s);
                        Result = k;
                        return Result;
                    }
                while (k++ < for_end);
        }
    }
    Result = FONTBASE;
    return Result;
}
internalfontnumber zloadexpandfont(internalfontnumber f, integer e) {
    register internalfontnumber Result;
    loadexpandfont_regmem strnumber s;
    internalfontnumber k;
    s = expandfontname(f, e);
    k = tfmlookup(s, fontsize[f]);
    if (k == FONTBASE) {
        if (pdffontautoexpand[f])
            k = autoexpandfont(f, e);
        else
            k = readfontinfo(NULLCS, s, /* str '' */ 345, fontsize[f]);
    }
    copyexpandparams(k, f, e);
    Result = k;
    return Result;
}
integer zfixexpandvalue(internalfontnumber f, integer e) {
    register integer Result;
    fixexpandvalue_regmem integer step;
    integer maxexpand;
    boolean neg;
    Result = 0;
    if (e == 0)
        return Result;
    if (e < 0) {
        e = -(integer)e;
        neg = true;
        maxexpand = -(integer)pdffontexpandratio[pdffontshrink[f]];
    } else {

        neg = false;
        maxexpand = pdffontexpandratio[pdffontstretch[f]];
    }
    if (e > maxexpand)
        e = maxexpand;
    else {

        step = pdffontstep[f];
        if (e % step > 0)
            e = step * roundxnoverd(e, 1, step);
    }
    if (neg)
        e = -(integer)e;
    Result = e;
    return Result;
}
internalfontnumber zgetexpandfont(internalfontnumber f, integer e) {
    register internalfontnumber Result;
    getexpandfont_regmem internalfontnumber k;
    k = pdffontelink[f];
    while (k != FONTBASE) {

        if (pdffontexpandratio[k] == e) {
            Result = k;
            return Result;
        }
        k = pdffontelink[k];
    }
    k = loadexpandfont(f, e);
    pdffontelink[k] = pdffontelink[f];
    pdffontelink[f] = k;
    Result = k;
    return Result;
}
internalfontnumber zexpandfont(internalfontnumber f, integer e) {
    register internalfontnumber Result;
    expandfont_regmem Result = f;
    if (e == 0)
        return Result;
    e = fixexpandvalue(f, e);
    if (e == 0)
        return Result;
    if (pdffontelink[f] == FONTBASE)
        pdferror(/* str 'font expansion' */ 1036,
                 /* str 'uninitialized pdf_font_elink' */ 1087);
    Result = getexpandfont(f, e);
    return Result;
}
void zsetexpandparams(internalfontnumber f, boolean autoexpand,
                      integer stretchlimit, integer shrinklimit,
                      integer fontstep, integer expandratio) {
    setexpandparams_regmem pdffontstep[f] = fontstep;
    pdffontautoexpand[f] = autoexpand;
    if (stretchlimit > 0)
        pdffontstretch[f] = getexpandfont(f, stretchlimit);
    if (shrinklimit > 0)
        pdffontshrink[f] = getexpandfont(f, -(integer)shrinklimit);
    if (expandratio != 0)
        pdffontexpandratio[f] = expandratio;
}
void zvfexpandlocalfonts(internalfontnumber f) {
    vfexpandlocalfonts_regmem internalfontnumber lf;
    integer k;
    pdfassert(pdffonttype[f] == VIRTUALFONTTYPE);
    {
        register integer for_end;
        k = 0;
        for_end = vflocalfontnum[f] - 1;
        if (k <= for_end)
            do {
                lf = vfifnts[vfdefaultfont[f] + k];
                setexpandparams(lf, pdffontautoexpand[f],
                                pdffontexpandratio[pdffontstretch[f]],
                                -(integer)pdffontexpandratio[pdffontshrink[f]],
                                pdffontstep[f], pdffontexpandratio[f]);
                if (pdffonttype[lf] == VIRTUALFONTTYPE)
                    vfexpandlocalfonts(lf);
            } while (k++ < for_end);
    }
}
void readexpandfont(void) {
    readexpandfont_regmem integer shrinklimit, stretchlimit, fontstep;
    internalfontnumber f;
    boolean autoexpand;
    scanfontident();
    f = curval;
    if (f == FONTBASE)
        pdferror(/* str 'font expansion' */ 1036,
                 /* str 'invalid font identifier' */ 873);
    if (pdffontblink[f] != FONTBASE)
        pdferror(
            /* str 'font expansion' */ 1036,
            /* str '\pdffontexpand cannot be used this way (the base ' */ 1088);
    scanoptionalequals();
    scanint();
    stretchlimit = fixint(curval, 0, 1000);
    scanint();
    shrinklimit = fixint(curval, 0, 500);
    scanint();
    fontstep = fixint(curval, 0, 100);
    if (fontstep == 0)
        pdferror(/* str 'font expansion' */ 1036,
                 /* str 'invalid step' */ 1089);
    stretchlimit = stretchlimit - stretchlimit % fontstep;
    if (stretchlimit < 0)
        stretchlimit = 0;
    shrinklimit = shrinklimit - shrinklimit % fontstep;
    if (shrinklimit < 0)
        shrinklimit = 0;
    if ((stretchlimit == 0) && (shrinklimit == 0))
        pdferror(/* str 'font expansion' */ 1036,
                 /* str 'invalid limit(s)' */ 1090);
    autoexpand = false;
    if (scankeyword(/* str 'autoexpand' */ 1091)) {
        autoexpand = true;
        /* comment:Scan an optional space */ {

            getxtoken();
            if (curcmd != SPACER)
                backinput();
        }
    }
    if ((pdffontexpandratio[f] != 0))
        pdferror(
            /* str 'font expansion' */ 1036,
            /* str 'this font has been expanded by another font so it' */ 1092);
    if ((pdffontstep[f] != 0)) {
        if (pdffontstep[f] != fontstep)
            pdferror(
                /* str 'font expansion' */ 1036,
                /* str 'font has been expanded with different expansion s' */
                1093);
        if (((pdffontstretch[f] == FONTBASE) && (stretchlimit != 0)) ||
            ((pdffontstretch[f] != FONTBASE) &&
             (pdffontexpandratio[pdffontstretch[f]] != stretchlimit)))
            pdferror(
                /* str 'font expansion' */ 1036,
                /* str 'font has been expanded with different stretch lim' */
                1094);
        if (((pdffontshrink[f] == FONTBASE) && (shrinklimit != 0)) ||
            ((pdffontshrink[f] != FONTBASE) &&
             (-(integer)pdffontexpandratio[pdffontshrink[f]] != shrinklimit)))
            pdferror(
                /* str 'font expansion' */ 1036,
                /* str 'font has been expanded with different shrink limi' */
                1095);
        if (pdffontautoexpand[f] != autoexpand)
            pdferror(
                /* str 'font expansion' */ 1036,
                /* str 'font has been expanded with different auto expans' */
                1096);
    } else {

        if ((pdffonttype[f] != NEWFONTTYPE) &&
            (pdffonttype[f] != VIRTUALFONTTYPE))
            pdfwarning(
                /* str 'font expansion' */ 1036,
                /* str 'font should be expanded before its first use' */ 1097,
                true, true);
        setexpandparams(f, autoexpand, stretchlimit, shrinklimit, fontstep, 0);
        if (pdffonttype[f] == VIRTUALFONTTYPE)
            vfexpandlocalfonts(f);
    }
}
internalfontnumber zletterspacefont(halfword u, internalfontnumber f,
                                    integer e) {
    register internalfontnumber Result;
    letterspacefont_regmem internalfontnumber k;
    scaled w, r;
    strnumber s;
    integer i, nw;
    unsigned char oldsetting;
    integer vfz;
    integer vfalpha;
    unsigned char vfbeta;
    k = readfontinfo(u, fontname[f], /* str '' */ 345, fontsize[f]);
    if (scankeyword(/* str 'nolig' */ 1098))
        setnoligatures(k);
    nw = heightbase[k] - widthbase[k];
    {
        register integer for_end;
        i = 0;
        for_end = nw - 1;
        if (i <= for_end)
            do
                fontinfo[widthbase[k] + i].cint =
                    fontinfo[widthbase[k] + i].cint +
                    roundxnoverd(fontinfo[QUADCODE + parambase[k]].cint, e,
                                 1000);
            while (i++ < for_end);
    }
    flushstr(fontname[k]);
    {
        if (poolptr + (strstart[fontname[k] + 1] - strstart[fontname[k]]) + 7 >
            poolsize)
            overflow(/* str 'pool size' */ 259, poolsize - initpoolptr);
    }
    oldsetting = selector;
    selector = NEWSTRING;
    print(fontname[k]);
    if (e > 0)
        print(/* str '+' */ 43);
    printint(e);
    print(/* str 'ls' */ 1099);
    selector = oldsetting;
    fontname[k] = makestring();
    allocvffnts();
    vfefnts[vfnf] = 0;
    vfifnts[vfnf] = f;
    incr(vfnf);
    vflocalfontnum[k] = 1;
    vfdefaultfont[k] = vfnf - 1;
    pdffonttype[k] = VIRTUALFONTTYPE;
    vfz = fontsize[f];
    {
        vfalpha = 16;
        while (vfz >= 8388608L) {

            vfz = vfz / 2;
            vfalpha = vfalpha + vfalpha;
        }
        vfbeta = 256 / vfalpha;
        vfalpha = vfalpha * vfz;
    }
    w = roundxnoverd(fontinfo[QUADCODE + parambase[f]].cint, e, 2000);
    if (w >= 0)
        tmpw.qqqq.b0 = 0;
    else {

        tmpw.qqqq.b0 = 255;
        w = vfalpha + w;
    }
    r = w * vfbeta;
    tmpw.qqqq.b1 = r / vfz;
    r = r % vfz;
    if (r == 0)
        tmpw.qqqq.b2 = 0;
    else {

        r = r * 256;
        tmpw.qqqq.b2 = r / vfz;
        r = r % vfz;
    }
    if (r == 0)
        tmpw.qqqq.b3 = 0;
    else {

        r = r * 256;
        tmpw.qqqq.b3 = r / vfz;
    }
    vfpacketbase[k] = newvfpacket(k);
    {
        register integer for_end;
        c = fontbc[k];
        for_end = fontec[k];
        if (c <= for_end)
            do {
                {
                    if (poolptr + 12 > poolsize)
                        overflow(/* str 'pool size' */ 259,
                                 poolsize - initpoolptr);
                }
                {
                    strpool[poolptr] = /* @d7299@ */ 146;
                    incr(poolptr);
                }
                {
                    strpool[poolptr] = tmpw.qqqq.b0;
                    incr(poolptr);
                }
                {
                    strpool[poolptr] = tmpw.qqqq.b1;
                    incr(poolptr);
                }
                {
                    strpool[poolptr] = tmpw.qqqq.b2;
                    incr(poolptr);
                }
                {
                    strpool[poolptr] = tmpw.qqqq.b3;
                    incr(poolptr);
                }
                if (c < SET1) {
                    strpool[poolptr] = c;
                    incr(poolptr);
                } else {

                    {
                        strpool[poolptr] = SET1;
                        incr(poolptr);
                    }
                    {
                        strpool[poolptr] = c;
                        incr(poolptr);
                    }
                }
                {
                    strpool[poolptr] = /* @d7302@ */ 146;
                    incr(poolptr);
                }
                {
                    strpool[poolptr] = tmpw.qqqq.b0;
                    incr(poolptr);
                }
                {
                    strpool[poolptr] = tmpw.qqqq.b1;
                    incr(poolptr);
                }
                {
                    strpool[poolptr] = tmpw.qqqq.b2;
                    incr(poolptr);
                }
                {
                    strpool[poolptr] = tmpw.qqqq.b3;
                    incr(poolptr);
                }
                s = makestring();
                storepacket(k, c, s);
                flushstr(s);
            } while (c++ < for_end);
    }
    Result = k;
    return Result;
}
void znewletterspacedfont(smallnumber a) {
    newletterspacedfont_regmem halfword u;
    strnumber t;
    unsigned char oldsetting;
    internalfontnumber f, k;
    getrtoken();
    u = curcs;
    if (u >= HASHBASE)
        t = hash[u].v.RH;
    else if (u >= SINGLEBASE) {

        if (u == NULLCS)
            t = /* str 'FONT' */ 1100;
        else
            t = u - SINGLEBASE;
    } else {

        oldsetting = selector;
        selector = NEWSTRING;
        print(/* str 'FONT' */ 1100);
        print(u - ACTIVEBASE);
        selector = oldsetting;
        {
            if (poolptr + 1 > poolsize)
                overflow(/* str 'pool size' */ 259, poolsize - initpoolptr);
        }
        t = makestring();
    }
    if ((a >= 4))
        geqdefine(u, SETFONT, FONTBASE);
    else
        eqdefine(u, SETFONT, FONTBASE);
    scanoptionalequals();
    scanfontident();
    k = curval;
    scanint();
    f = letterspacefont(u, k, fixint(curval, -1000, 1000));
    eqtb[u].hh.v.RH = f;
    eqtb[FONTIDBASE + f] = eqtb[u];
    hash[FONTIDBASE + f].v.RH = t;
}
boolean zisletterspacedfont(internalfontnumber f) {
    register boolean Result;
    isletterspacedfont_regmem poolpointer i, j;
    Result = false;
    if (pdffonttype[f] != VIRTUALFONTTYPE)
        return Result;
    i = strstart[fontname[f] + 1] - 1;
    j = strstart[fontname[f]];
    if ((strpool[i - 1] != 'l') || (strpool[i] != 's'))
        return Result;
    i = i - 2;
    while (i >= j) {

        if ((strpool[i] < '0') || (strpool[i] > '9'))
            goto labisletterspacedfont30done;
        i = i - 1;
    }
labisletterspacedfont30done:
    if (i < j)
        return Result;
    if ((strpool[i] != '+') && (strpool[i] != '-'))
        return Result;
    Result = true;
    return Result;
}
internalfontnumber zcopyfontinfo(internalfontnumber f) {
    register internalfontnumber Result;
    copyfontinfo_regmem halfword lf, bc, ec, i;
    internalfontnumber k;
    if ((pdffontexpandratio[f] != 0) || (pdffontstep[f] != 0))
        pdferror(/* str '\pdfcopyfont' */ 1101,
                 /* str 'cannot copy an expanded font' */ 1102);
    if (isletterspacedfont(f))
        pdferror(/* str '\pdfcopyfont' */ 1101,
                 /* str 'cannot copy a letterspaced font' */ 1103);
    k = fontptr + 1;
    incr(fontptr);
    if ((fontptr >= fontmax))
        overflow(/* str 'maximum internal font number (font_max)' */ 1085,
                 fontmax);
    fontname[k] = fontname[f];
    fontarea[k] = /* str '...' */ 1082;
    hyphenchar[k] = hyphenchar[f];
    skewchar[k] = skewchar[f];
    fontbchar[k] = fontbchar[f];
    fontfalsebchar[k] = fontfalsebchar[f];
    fontbc[k] = fontbc[f];
    fontec[k] = fontec[f];
    fontsize[k] = fontsize[f];
    fontdsize[k] = fontdsize[f];
    fontparams[k] = fontparams[f];
    fontglue[k] = fontglue[f];
    bcharlabel[k] = bcharlabel[f];
    bc = fontbc[f];
    ec = fontec[f];
    charbase[k] = fmemptr - bc;
    widthbase[k] = charbase[k] + ec + 1;
    heightbase[k] = widthbase[k] + (heightbase[f] - widthbase[f]);
    depthbase[k] = heightbase[k] + (depthbase[f] - heightbase[f]);
    italicbase[k] = depthbase[k] + (italicbase[f] - depthbase[f]);
    ligkernbase[k] = italicbase[k] + (ligkernbase[f] - italicbase[f]);
    kernbase[k] = ligkernbase[k] + (kernbase[f] - ligkernbase[f]);
    extenbase[k] = kernbase[k] + (extenbase[f] - kernbase[f]);
    parambase[k] = extenbase[k] + (parambase[f] - extenbase[f]);
    lf = (parambase[f] - charbase[f]) + fontparams[f] + 1;
    if ((fmemptr + lf >= fontmemsize))
        overflow(
            /* str 'number of words of font memory (font_mem_size)' */ 1086,
            fontmemsize);
    {
        register integer for_end;
        i = 0;
        for_end = lf - 1;
        if (i <= for_end)
            do
                fontinfo[charbase[k] + bc + i] = fontinfo[charbase[f] + bc + i];
            while (i++ < for_end);
    }
    fmemptr = fmemptr + lf;
    Result = k;
    return Result;
}
void zmakefontcopy(smallnumber a) {
    makefontcopy_regmem halfword u;
    strnumber t;
    unsigned char oldsetting;
    internalfontnumber f, k;
    getrtoken();
    u = curcs;
    if (u >= HASHBASE)
        t = hash[u].v.RH;
    else if (u >= SINGLEBASE) {

        if (u == NULLCS)
            t = /* str 'FONT' */ 1100;
        else
            t = u - SINGLEBASE;
    } else {

        oldsetting = selector;
        selector = NEWSTRING;
        print(/* str 'FONT' */ 1100);
        print(u - ACTIVEBASE);
        selector = oldsetting;
        {
            if (poolptr + 1 > poolsize)
                overflow(/* str 'pool size' */ 259, poolsize - initpoolptr);
        }
        t = makestring();
    }
    if ((a >= 4))
        geqdefine(u, SETFONT, FONTBASE);
    else
        eqdefine(u, SETFONT, FONTBASE);
    scanoptionalequals();
    scanfontident();
    k = curval;
    f = copyfontinfo(k);
    eqtb[u].hh.v.RH = f;
    eqtb[FONTIDBASE + f] = eqtb[u];
    hash[FONTIDBASE + f].v.RH = t;
}
void zvferror(strnumber filename, strnumber msg) {
    vferror_regmem
        unsigned char oldsetting;
    strnumber s;
    {
        if (poolptr + (strstart[filename + 1] - strstart[filename]) + 3 >
            poolsize)
            overflow(/* str 'pool size' */ 259, poolsize - initpoolptr);
    }
    oldsetting = selector;
    selector = NEWSTRING;
    print(filename);
    print(/* str '.vf' */ 1104);
    s = makestring();
    selector = oldsetting;
    pdferror(s, msg);
}
eightbits vfbyte(void) {
    register eightbits Result;
    vfbyte_regmem integer i;
    i = getc(vffile);
    if (i < 0)
        pdferror(/* str 'vf' */ 1105, /* str 'unexpected EOF or error' */ 1106);
    Result = i;
    return Result;
}
integer zvfreadsigned(integer k) {
    register integer Result;
    vfreadsigned_regmem integer i;
    pdfassert((k > 0) && (k <= 4));
    i = vfbyte();
    if (i >= 128)
        i = i - 256;
    decr(k);
    while (k > 0) {

        i = i * 256 + vfbyte();
        decr(k);
    }
    Result = i;
    return Result;
}
integer zvfreadunsigned(integer k) {
    register integer Result;
    vfreadunsigned_regmem integer i;
    pdfassert((k > 0) && (k <= 4));
    i = vfbyte();
    if ((k == 4) && (i >= 128))
        vferror(fontname[f], /* str 'number too big' */ 1028);
    decr(k);
    while (k > 0) {

        i = i * 256 + vfbyte();
        decr(k);
    }
    Result = i;
    return Result;
}
void zvflocalfontwarning(internalfontnumber f, internalfontnumber k,
                         strnumber s) {
    vflocalfontwarning_regmem printnl(s);
    print(/* str ' in local font ' */ 1107);
    print(fontname[k]);
    print(/* str ' in virtual font ' */ 1108);
    print(fontname[f]);
    print(/* str '.vf ignored.' */ 1109);
}
internalfontnumber zvfdeffont(internalfontnumber f) {
    register internalfontnumber Result;
    vfdeffont_regmem internalfontnumber k;
    strnumber s;
    scaled ds, fs;
    fourquarters cs;
    cs.b0 = vfbyte();
    cs.b1 = vfbyte();
    cs.b2 = vfbyte();
    cs.b3 = vfbyte();
    fs = storescaledf(vfreadsigned(4), fontsize[f]);
    ds = vfreadsigned(4) / 16;
    tmpw.qqqq.b0 = vfbyte();
    tmpw.qqqq.b1 = vfbyte();
    while (tmpw.qqqq.b0 > 0) {

        decr(tmpw.qqqq.b0);
        {
            if (vfbyte() != 0)
                ;
        }
    }
    {
        if (poolptr + tmpw.qqqq.b1 > poolsize)
            overflow(/* str 'pool size' */ 259, poolsize - initpoolptr);
    }
    while (tmpw.qqqq.b1 > 0) {

        decr(tmpw.qqqq.b1);
        {
            strpool[poolptr] = vfbyte();
            incr(poolptr);
        }
    }
    s = makestring();
    k = tfmlookup(s, fs);
    if (k == FONTBASE)
        k = readfontinfo(NULLCS, s, /* str '' */ 345, fs);
    if (k != FONTBASE) {
        if (((cs.b0 != 0) || (cs.b1 != 0) || (cs.b2 != 0) || (cs.b3 != 0)) &&
            ((fontcheck[k].b0 != 0) || (fontcheck[k].b1 != 0) ||
             (fontcheck[k].b2 != 0) || (fontcheck[k].b3 != 0)) &&
            ((cs.b0 != fontcheck[k].b0) || (cs.b1 != fontcheck[k].b1) ||
             (cs.b2 != fontcheck[k].b2) || (cs.b3 != fontcheck[k].b3)))
            vflocalfontwarning(f, k, /* str 'checksum mismatch' */ 1110);
        if (ds != fontdsize[k])
            vflocalfontwarning(f, k, /* str 'design size mismatch' */ 1111);
    }
    if ((pdffontstep[f] != 0))
        setexpandparams(k, pdffontautoexpand[f],
                        pdffontexpandratio[pdffontstretch[f]],
                        -(integer)pdffontexpandratio[pdffontshrink[f]],
                        pdffontstep[f], pdffontexpandratio[f]);
    Result = k;
    return Result;
}
void zdovf(internalfontnumber f) {
    dovf_regmem integer cmd, k, n;
    integer cc, cmdlength, packetlength;
    scaled tfmwidth;
    strnumber s;
    vfstackindex stacklevel;
    internalfontnumber savevfnf;
    pdffonttype[f] = REALFONTTYPE;
    if (autoexpandvf(f))
        return;
    stacklevel = 0;
    /* comment:Open |vf_file|, return if not found */ packfilename(
        fontname[f], /* str '' */ 345,
        /* str '.vf' */ 1104);
    if (!vfbopenin(vffile))
        return;
    /* comment:Process the preamble */ if (vfbyte() != PRE)
        vferror(fontname[f], /* str 'PRE command expected' */ 1113);
    if (vfbyte() != VFID)
        vferror(fontname[f], /* str 'wrong id byte' */ 1114);
    cmdlength = vfbyte();
    {
        register integer for_end;
        k = 1;
        for_end = cmdlength;
        if (k <= for_end)
            do {
                if (vfbyte() != 0)
                    ;
            } while (k++ < for_end);
    }
    tmpw.qqqq.b0 = vfbyte();
    tmpw.qqqq.b1 = vfbyte();
    tmpw.qqqq.b2 = vfbyte();
    tmpw.qqqq.b3 = vfbyte();
    if (((tmpw.qqqq.b0 != 0) || (tmpw.qqqq.b1 != 0) || (tmpw.qqqq.b2 != 0) ||
         (tmpw.qqqq.b3 != 0)) &&
        ((fontcheck[f].b0 != 0) || (fontcheck[f].b1 != 0) ||
         (fontcheck[f].b2 != 0) || (fontcheck[f].b3 != 0)) &&
        ((tmpw.qqqq.b0 != fontcheck[f].b0) ||
         (tmpw.qqqq.b1 != fontcheck[f].b1) ||
         (tmpw.qqqq.b2 != fontcheck[f].b2) ||
         (tmpw.qqqq.b3 != fontcheck[f].b3))) {
        printnl(/* str 'checksum mismatch in font ' */ 1115);
        print(fontname[f]);
        print(/* str '.vf ignored' */ 1116);
    }
    if (vfreadsigned(4) / 16 != fontdsize[f]) {
        printnl(/* str 'design size mismatch in font ' */ 1117);
        print(fontname[f]);
        print(/* str '.vf ignored' */ 1116);
    }
    fflush(stdout);
    /* comment:Process the font definitions */ cmd = vfbyte();
    savevfnf = vfnf;
    while ((cmd >= FNTDEF1) && (cmd <= /* @d7384@ */ 246)) {

        allocvffnts();
        vfefnts[vfnf] = vfreadunsigned(/* @d7385@ */ cmd - 242);
        vfifnts[vfnf] = vfdeffont(f);
        incr(vfnf);
        cmd = vfbyte();
    }
    vfdefaultfont[f] = savevfnf;
    vflocalfontnum[f] = vfnf - savevfnf;
    /* comment:Allocate memory for the new virtual font */ vfpacketbase[f] =
        newvfpacket(f);
    while (cmd <= LONGCHAR) {

        /* comment:Build a character packet */ if (cmd == LONGCHAR) {
            packetlength = vfreadunsigned(4);
            cc = vfreadunsigned(4);
            if (!((fontbc[f] <= cc) && (cc <= fontec[f]) &&
                  (fontinfo[charbase[f] + cc].qqqq.b0 > MINQUARTERWORD)))
                vferror(fontname[f], /* str 'invalid character code' */ 1118);
            tfmwidth = storescaledf(vfreadsigned(4), fontsize[f]);
        } else {

            packetlength = cmd;
            cc = vfbyte();
            if (!((fontbc[f] <= cc) && (cc <= fontec[f]) &&
                  (fontinfo[charbase[f] + cc].qqqq.b0 > MINQUARTERWORD)))
                vferror(fontname[f], /* str 'invalid character code' */ 1118);
            tfmwidth = storescaledf(vfreadunsigned(3), fontsize[f]);
        }
        if (packetlength < 0)
            vferror(fontname[f], /* str 'negative packet length' */ 1119);
        if (packetlength > VFMAXPACKETLENGTH)
            vferror(fontname[f], /* str 'packet length too long' */ 1120);
        if (tfmwidth !=
            fontinfo[widthbase[f] +
                     fontinfo[charbase[f] + effectivechar(true, f, cc)].qqqq.b0]
                .cint) {
            printnl(/* str 'character width mismatch in font ' */ 1121);
            print(fontname[f]);
            print(/* str '.vf ignored' */ 1116);
        }
        {
            if (poolptr + packetlength > poolsize)
                overflow(/* str 'pool size' */ 259, poolsize - initpoolptr);
        }
        while (packetlength > 0) {

            cmd = vfbyte();
            decr(packetlength);
            /* comment:Cases of \.{DVI} commands that can appear in chara */
            if ((cmd >= SETCHAR0) && (cmd <= /* @d7402@ */ 127))
                cmdlength = 0;
            else if (((FNTNUM0 <= cmd) && (cmd <= /* @d7404@ */ 234)) ||
                     ((FNT1 <= cmd) && (cmd <= /* @d7406@ */ 238))) {
                if (cmd >= FNT1) {
                    k = vfreadunsigned(/* @d7408@ */ cmd - 234);
                    packetlength = packetlength - (/* @d7409@ */ cmd - 234);
                } else
                    k = cmd - FNTNUM0;
                if (k >= 256)
                    vferror(fontname[f], /* str 'too many local fonts' */ 1124);
                n = 0;
                while ((n < vflocalfontnum[f]) &&
                       (vfefnts[vfdefaultfont[f] + n] != k))
                    incr(n);
                if (n == vflocalfontnum[f])
                    vferror(fontname[f], /* str 'undefined local font' */ 1125);
                if (k <= 63) {
                    strpool[poolptr] = FNTNUM0 + k;
                    incr(poolptr);
                } else {

                    {
                        strpool[poolptr] = FNT1;
                        incr(poolptr);
                    }
                    {
                        strpool[poolptr] = k;
                        incr(poolptr);
                    }
                }
                cmdlength = 0;
                cmd = NOP;
            } else
                switch (cmd) {
                case SETRULE:
                case PUTRULE:
                    cmdlength = 8;
                    break;
                case SET1:
                case SET1 + 1:
                case SET1 + 2:
                case SET1 + 3:
                    cmdlength = /* @d7422@ */ cmd - 127;
                    break;
                case PUT1:
                case PUT1 + 1:
                case PUT1 + 2:
                case PUT1 + 3:
                    cmdlength = /* @d7427@ */ cmd - 132;
                    break;
                case RIGHT1:
                case RIGHT1 + 1:
                case RIGHT1 + 2:
                case RIGHT1 + 3:
                    cmdlength = /* @d7432@ */ cmd - 142;
                    break;
                case W1:
                case W1 + 1:
                case W1 + 2:
                case W1 + 3:
                    cmdlength = /* @d7437@ */ cmd - 147;
                    break;
                case X1:
                case X1 + 1:
                case X1 + 2:
                case X1 + 3:
                    cmdlength = /* @d7442@ */ cmd - 152;
                    break;
                case DOWN1:
                case DOWN1 + 1:
                case DOWN1 + 2:
                case DOWN1 + 3:
                    cmdlength = /* @d7447@ */ cmd - 156;
                    break;
                case Y1:
                case Y1 + 1:
                case Y1 + 2:
                case Y1 + 3:
                    cmdlength = /* @d7452@ */ cmd - 161;
                    break;
                case Z1:
                case Z1 + 1:
                case Z1 + 2:
                case Z1 + 3:
                    cmdlength = /* @d7457@ */ cmd - 166;
                    break;
                case XXX1:
                case XXX1 + 1:
                case XXX1 + 2:
                case XXX1 + 3: {
                    cmdlength = vfreadunsigned(/* @d7462@ */ cmd - 238);
                    packetlength = packetlength - (/* @d7463@ */ cmd - 238);
                    if (cmdlength > VFMAXPACKETLENGTH)
                        vferror(fontname[f],
                                /* str 'packet length too long' */ 1120);
                    if (cmdlength < 0)
                        vferror(fontname[f],
                                /* str 'string of negative length' */ 1126);
                    {
                        strpool[poolptr] = XXX1;
                        incr(poolptr);
                    }
                    {
                        strpool[poolptr] = cmdlength;
                        incr(poolptr);
                    }
                    cmd = NOP;
                } break;
                case W0:
                case X0:
                case Y0:
                case Z0:
                case NOP:
                    cmdlength = 0;
                    break;
                case PUSH:
                case POP: {
                    cmdlength = 0;
                    if (cmd == PUSH) {

                        if (stacklevel == vfstacksize)
                            overflow(/* str 'virtual font stack size' */ 1127,
                                     vfstacksize);
                        else
                            incr(stacklevel);
                    } else if (stacklevel == 0)
                        vferror(
                            fontname[f],
                            /* str 'more POPs than PUSHs in character' */ 1128);
                    else
                        decr(stacklevel);
                } break;
                default:
                    vferror(fontname[f], /* str 'improver DVI command' */ 1129);
                    break;
                }
            if (cmd != NOP) {
                strpool[poolptr] = cmd;
                incr(poolptr);
            }
            packetlength = packetlength - cmdlength;
            while (cmdlength > 0) {

                decr(cmdlength);
                {
                    strpool[poolptr] = vfbyte();
                    incr(poolptr);
                }
            }
        }
        if (stacklevel != 0)
            vferror(fontname[f],
                    /* str 'more PUSHs than POPs in character packet' */ 1122);
        if (packetlength != 0)
            vferror(fontname[f],
                    /* str 'invalid packet length or DVI command in packet' */
                    1123);
        /* comment:Store the packet being built */ s = makestring();
        storepacket(f, cc, s);
        flushstr(s);
        cmd = vfbyte();
    }
    if (cmd != POST)
        vferror(fontname[f], /* str 'POST command expected' */ 1112);
    bclose(vffile);
    pdffonttype[f] = VIRTUALFONTTYPE;
}
void pdfcheckvfcurval(void) {
    pdfcheckvfcurval_regmem internalfontnumber f;
    f = curval;
    dovf(f);
    if (pdffonttype[f] == VIRTUALFONTTYPE)
        pdferror(/* str 'font' */ 595,
                 /* str 'command cannot be used with virtual font' */ 1130);
}
boolean zautoexpandvf(internalfontnumber f) {
    register boolean Result;
    autoexpandvf_regmem internalfontnumber bf, lf;
    integer e, k;
    Result = false;
    if ((!pdffontautoexpand[f]) || (pdffontblink[f] == FONTBASE))
        return Result;
    bf = pdffontblink[f];
    if (pdffonttype[bf] == NEWFONTTYPE)
        dovf(bf);
    if (pdffonttype[bf] != VIRTUALFONTTYPE)
        return Result;
    e = pdffontexpandratio[f];
    {
        register integer for_end;
        k = 0;
        for_end = vflocalfontnum[bf] - 1;
        if (k <= for_end)
            do {
                lf = vfdefaultfont[bf] + k;
                allocvffnts();
                vfefnts[vfnf] = vfefnts[lf];
                vfifnts[vfnf] = autoexpandfont(vfifnts[lf], e);
                copyexpandparams(vfifnts[vfnf], vfifnts[lf], e);
                incr(vfnf);
            } while (k++ < for_end);
    }
    vfpacketbase[f] = vfpacketbase[bf];
    vflocalfontnum[f] = vflocalfontnum[bf];
    vfdefaultfont[f] = vfnf - vflocalfontnum[f];
    pdffonttype[f] = VIRTUALFONTTYPE;
    Result = true;
    return Result;
}
integer zpacketreadsigned(integer k) {
    register integer Result;
    packetreadsigned_regmem integer i;
    pdfassert((k > 0) && (k <= 4));
    i = packetbyte();
    if (i >= 128)
        i = i - 256;
    decr(k);
    while (k > 0) {

        i = i * 256 + packetbyte();
        decr(k);
    }
    Result = i;
    return Result;
}
integer zpacketreadunsigned(integer k) {
    register integer Result;
    packetreadunsigned_regmem integer i;
    pdfassert((k > 0) && (k <= 4));
    i = packetbyte();
    if ((k == 4) && (i >= 128))
        vferror(fontname[f], /* str 'number too big' */ 1028);
    decr(k);
    while (k > 0) {

        i = i * 256 + packetbyte();
        decr(k);
    }
    Result = i;
    return Result;
}
scaled zpacketscaled(integer k, scaled fs) {
    register scaled Result;
    packetscaled_regmem Result = storescaledf(packetreadsigned(k), fs);
    return Result;
}
void zdovfpacket(internalfontnumber vff, eightbits c, halfword p) {
    dovfpacket_regmem internalfontnumber f, k, n;
    scaled savecurh, savecurv;
    integer cmd;
    boolean charmove;
    scaled w, x, y, z;
    strnumber s;
    incr(vfcurs);
    if (vfcurs > vfmaxrecursion)
        overflow(/* str 'max level recursion of virtual fonts' */ 1131,
                 vfmaxrecursion);
    savecurv = curv;
    savecurh = curh;
    pushpacketstate();
    startpacket(vff, c);
    f = vfifnts[vfdefaultfont[vff]];
    w = 0;
    x = 0;
    y = 0;
    z = 0;
    while (vfpacketlength > 0) {

        cmd = packetbyte();
        /* comment:Do typesetting the \.{DVI} commands in virtual cha */
        if ((cmd >= SETCHAR0) && (cmd <= /* @d7502@ */ 127)) {
            if (!((fontbc[f] <= cmd) && (cmd <= fontec[f]) &&
                  (fontinfo[charbase[f] + cmd].qqqq.b0 > MINQUARTERWORD))) {
                charwarning(f, cmd);
                goto labdovfpacket22continue;
            }
            c = cmd;
            charmove = true;
            goto labdovfpacket70do_char;
        } else if (((FNTNUM0 <= cmd) && (cmd <= /* @d7507@ */ 234)) ||
                   (cmd == FNT1)) {
            if (cmd == FNT1)
                k = packetbyte();
            else
                k = cmd - FNTNUM0;
            n = 0;
            while ((n < vflocalfontnum[vff]) &&
                   (vfefnts[vfdefaultfont[vff] + n] != k))
                incr(n);
            if ((n == vflocalfontnum[vff]))
                pdferror(/* str 'vf' */ 1105,
                         /* str 'local font not found' */ 1132);
            else
                f = vfifnts[vfdefaultfont[vff] + n];
        } else
            switch (cmd) {
            case PUSH: {
                vfstack[vfstackptr].stackh = curh;
                vfstack[vfstackptr].stackv = curv;
                vfstack[vfstackptr].stackw = w;
                vfstack[vfstackptr].stackx = x;
                vfstack[vfstackptr].stacky = y;
                vfstack[vfstackptr].stackz = z;
                incr(vfstackptr);
            } break;
            case POP: {
                decr(vfstackptr);
                curh = vfstack[vfstackptr].stackh;
                curv = vfstack[vfstackptr].stackv;
                w = vfstack[vfstackptr].stackw;
                x = vfstack[vfstackptr].stackx;
                y = vfstack[vfstackptr].stacky;
                z = vfstack[vfstackptr].stackz;
            } break;
            case SET1:
            case SET1 + 1:
            case SET1 + 2:
            case SET1 + 3:
            case PUT1:
            case PUT1 + 1:
            case PUT1 + 2:
            case PUT1 + 3: {
                if ((SET1 <= cmd) && (cmd <= /* @d7524@ */ 131)) {
                    tmpw.cint = packetreadunsigned(/* @d7525@ */ cmd - 127);
                    charmove = true;
                } else {

                    tmpw.cint = packetreadunsigned(/* @d7526@ */ cmd - 132);
                    charmove = false;
                }
                if (!((fontbc[f] <= tmpw.cint) && (tmpw.cint <= fontec[f]) &&
                      (fontinfo[charbase[f] + tmpw.cint].qqqq.b0 >
                       MINQUARTERWORD))) {
                    charwarning(f, tmpw.cint);
                    goto labdovfpacket22continue;
                }
                c = tmpw.cint;
                goto labdovfpacket70do_char;
            } break;
            case SETRULE:
            case PUTRULE: {
                ruleht = packetscaled(4, fontsize[vff]);
                rulewd = packetscaled(4, fontsize[vff]);
                if ((rulewd > 0) && (ruleht > 0)) {
                    pdfsetrule(curh, curv, rulewd, ruleht);
                    if (cmd == SETRULE)
                        curh = curh + rulewd;
                }
            } break;
            case RIGHT1:
            case RIGHT1 + 1:
            case RIGHT1 + 2:
            case RIGHT1 + 3:
                curh =
                    curh + packetscaled(/* @d7537@ */ cmd - 142, fontsize[vff]);
                break;
            case W0:
            case W1:
            case W1 + 1:
            case W1 + 2:
            case W1 + 3: {
                if (cmd > W0)
                    w = packetscaled(cmd - W0, fontsize[vff]);
                curh = curh + w;
            } break;
            case X0:
            case X1:
            case X1 + 1:
            case X1 + 2:
            case X1 + 3: {
                if (cmd > X0)
                    x = packetscaled(cmd - X0, fontsize[vff]);
                curh = curh + x;
            } break;
            case DOWN1:
            case DOWN1 + 1:
            case DOWN1 + 2:
            case DOWN1 + 3:
                curv =
                    curv + packetscaled(/* @d7556@ */ cmd - 156, fontsize[vff]);
                break;
            case Y0:
            case Y1:
            case Y1 + 1:
            case Y1 + 2:
            case Y1 + 3: {
                if (cmd > Y0)
                    y = packetscaled(cmd - Y0, fontsize[vff]);
                curv = curv + y;
            } break;
            case Z0:
            case Z1:
            case Z1 + 1:
            case Z1 + 2:
            case Z1 + 3: {
                if (cmd > Z0)
                    z = packetscaled(cmd - Z0, fontsize[vff]);
                curv = curv + z;
            } break;
            case XXX1:
            case XXX1 + 1:
            case XXX1 + 2:
            case XXX1 + 3: {
                tmpw.cint = packetreadunsigned(/* @d7575@ */ cmd - 238);
                {
                    if (poolptr + tmpw.cint > poolsize)
                        overflow(/* str 'pool size' */ 259,
                                 poolsize - initpoolptr);
                }
                while (tmpw.cint > 0) {

                    decr(tmpw.cint);
                    {
                        strpool[poolptr] = packetbyte();
                        incr(poolptr);
                    }
                }
                s = makestring();
                literal(s, 3, false);
                flushstr(s);
            } break;
            default:
                pdferror(/* str 'vf' */ 1105,
                         /* str 'invalid DVI command' */ 1133);
                break;
            }
        goto labdovfpacket22continue;
    labdovfpacket70do_char:
        if (((fontbc[f] <= c) && (c <= fontec[f]) &&
             (fontinfo[charbase[f] + c].qqqq.b0 > MINQUARTERWORD))) {
            if (pdffonttype[f] == NEWFONTTYPE)
                dovf(f);
            if (pdffonttype[f] == VIRTUALFONTTYPE)
                dovfpacket(f, c, p);
            else {

                pdfbeginstring(f, p);
                pdfprintchar(f, c);
                advcharwidth(f, c);
            }
        } else
            charwarning(f, c);
        if (charmove)
            curh = curh +
                   fontinfo[widthbase[f] +
                            fontinfo[charbase[f] + effectivechar(true, f, c)]
                                .qqqq.b0]
                       .cint;
    labdovfpacket22continue:;
    }
    poppacketstate();
    curv = savecurv;
    curh = savecurh;
    decr(vfcurs);
}
/* comment:Declare procedures needed in |pdf_hlist_out|, |pdf */ void
zpdfoutliteral(halfword p) {
    pdfoutliteral_regmem
        unsigned char oldsetting;
    strnumber s;
    oldsetting = selector;
    selector = NEWSTRING;
    showtokenlist(mem[mem[p + 1].hh.v.RH].hh.v.RH, TEXNULL, poolsize - poolptr);
    selector = oldsetting;
    s = makestring();
    literal(s, mem[p + 1].hh.v.LH, false);
    flushstr(s);
}
void zpdfoutcolorstack(halfword p) {
    pdfoutcolorstack_regmem
        unsigned char oldsetting;
    strnumber s;
    integer cmd;
    integer stackno;
    integer literalmode;
    cmd = mem[p + 1].hh.v.LH;
    stackno = mem[p + 1].hh.v.RH;
    if (stackno >= colorstackused()) {
        printnl(/* str '' */ 345);
        print(/* str 'Color stack ' */ 1134);
        printint(stackno);
        print(/* str ' is not initialized for use!' */ 1135);
        printnl(/* str '' */ 345);
        return;
    }
    switch (cmd) {
    case 0:
    case 1: {
        oldsetting = selector;
        selector = NEWSTRING;
        showtokenlist(mem[mem[p + 2].hh.v.RH].hh.v.RH, TEXNULL,
                      poolsize - poolptr);
        selector = oldsetting;
        s = makestring();
        if (cmd == 0)
            literalmode = colorstackset(stackno, s);
        else
            literalmode = colorstackpush(stackno, s);
        if ((strstart[s + 1] - strstart[s]) > 0)
            literal(s, literalmode, false);
        flushstr(s);
        return;
    } break;
    case 2:
        literalmode = colorstackpop(stackno);
        break;
    case 3:
        literalmode = colorstackcurrent(stackno);
        break;
    default:
        confusion(/* str 'pdfcolorstack' */ 1136);
        break;
    }
    if ((poolptr - strstart[strptr]) > 0) {
        s = makestring();
        literal(s, literalmode, false);
        flushstr(s);
    }
}
void pdfoutcolorstackstartpage(void) {
    pdfoutcolorstackstartpage_regmem integer i;
    integer max;
    integer startstatus;
    integer literalmode;
    strnumber s;
    i = 0;
    max = colorstackused();
    while (i < max) {

        startstatus = colorstackskippagestart(i);
        if (startstatus == 0) {
            literalmode = colorstackcurrent(i);
            if ((poolptr - strstart[strptr]) > 0) {
                s = makestring();
                literal(s, literalmode, false);
                flushstr(s);
            }
        }
        incr(i);
    }
}
void zpdfoutsetmatrix(halfword p) {
    pdfoutsetmatrix_regmem
        unsigned char oldsetting;
    strnumber s;
    oldsetting = selector;
    selector = NEWSTRING;
    showtokenlist(mem[mem[p + 1].hh.v.RH].hh.v.RH, TEXNULL, poolsize - poolptr);
    selector = oldsetting;
    {
        if (poolptr + 7 > poolsize)
            overflow(/* str 'pool size' */ 259, poolsize - initpoolptr);
    }
    strpool[poolptr] = 0;
    if (pdfsetmatrix(strstart[strptr], curh, curpageheight - curv) == 1) {
        {
            if (poolptr + 7 > poolsize)
                overflow(/* str 'pool size' */ 259, poolsize - initpoolptr);
        }
        {
            strpool[poolptr] = /* str ' ' */ 32;
            incr(poolptr);
        }
        {
            strpool[poolptr] = /* str '0' */ 48;
            incr(poolptr);
        }
        {
            strpool[poolptr] = /* str ' ' */ 32;
            incr(poolptr);
        }
        {
            strpool[poolptr] = /* str '0' */ 48;
            incr(poolptr);
        }
        {
            strpool[poolptr] = /* str ' ' */ 32;
            incr(poolptr);
        }
        {
            strpool[poolptr] = /* str 'c' */ 99;
            incr(poolptr);
        }
        {
            strpool[poolptr] = /* str 'm' */ 109;
            incr(poolptr);
        }
        s = makestring();
        literal(s, 0, false);
    } else {

        pdferror(/* str '\pdfsetmatrix' */ 1137,
                 /* str 'Unrecognized format.' */ 1138);
    }
    flushstr(s);
}
void zpdfoutsave(halfword p) {
    pdfoutsave_regmem checkpdfsave(curh, curv);
    literal(/* str 'q' */ 113, 0, false);
}
void zpdfoutrestore(halfword p) {
    pdfoutrestore_regmem checkpdfrestore(curh, curv);
    literal(/* str 'Q' */ 81, 0, false);
}
void zpdfspecial(halfword p) {
    pdfspecial_regmem
        unsigned char oldsetting;
    strnumber s;
    oldsetting = selector;
    selector = NEWSTRING;
    showtokenlist(mem[mem[p + 1].hh.v.RH].hh.v.RH, TEXNULL, poolsize - poolptr);
    selector = oldsetting;
    s = makestring();
    literal(s, 3, true);
    flushstr(s);
}
void zpdfprinttoks(halfword p) {
    pdfprinttoks_regmem strnumber s;
    s = tokenstostring(p);
    if ((strstart[s + 1] - strstart[s]) > 0)
        pdfprint(s);
    flushstr(s);
}
void zpdfprinttoksln(halfword p) {
    pdfprinttoksln_regmem strnumber s;
    s = tokenstostring(p);
    if ((strstart[s + 1] - strstart[s]) > 0) {
        {
            pdfprint(s);
            {
                {
                    if (pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfosgetosbuf(1);
                    else if (!pdfosmode && (1 > pdfbufsize))
                        overflow(/* str 'PDF output buffer' */ 1004,
                                 pdfopbufsize);
                    else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfflush();
                }
                {
                    pdfbuf[pdfptr] = 10;
                    incr(pdfptr);
                }
            }
        }
    }
    flushstr(s);
}
void zpdfwriteobj(integer n) {
    pdfwriteobj_regmem strnumber s;
    bytefile f;
    s = tokenstostring(pdfmem[objtab[n].int4 + 0]);
    {
        deletetokenref(pdfmem[objtab[n].int4 + 0]);
        pdfmem[objtab[n].int4 + 0] = TEXNULL;
    }
    if (pdfmem[objtab[n].int4 + 1] > 0) {
        pdfbegindict(n, 0);
        if (pdfmem[objtab[n].int4 + 2] != TEXNULL) {
            pdfprinttoksln(pdfmem[objtab[n].int4 + 2]);
            {
                deletetokenref(pdfmem[objtab[n].int4 + 2]);
                pdfmem[objtab[n].int4 + 2] = TEXNULL;
            }
        }
        pdfbeginstream();
    } else
        pdfbeginobj(n, 1);
    if (pdfmem[objtab[n].int4 + 3] > 0) {
        curname = s;
        curarea = /* str '' */ 345;
        curext = /* str '' */ 345;
        packfilename(curname, curarea, curext);
        if (!texbopenin(f))
            pdferror(/* str 'ext5' */ 1169,
                     /* str 'cannot open file for embedding' */ 1170);
        print(/* str '<<' */ 1076);
        print(s);
        if (!eof(f)) {
            while (!eof(f)) {

                {
                    if (pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfosgetosbuf(1);
                    else if (!pdfosmode && (1 > pdfbufsize))
                        overflow(/* str 'PDF output buffer' */ 1004,
                                 pdfopbufsize);
                    else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfflush();
                }
                {
                    pdfbuf[pdfptr] = getc(f);
                    incr(pdfptr);
                }
            }
            if ((!pdfmem[objtab[n].int4 + 1]) && (pdfptr > 0) &&
                (pdfbuf[pdfptr - 1] != 10)) {
                {
                    if (pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfosgetosbuf(1);
                    else if (!pdfosmode && (1 > pdfbufsize))
                        overflow(/* str 'PDF output buffer' */ 1004,
                                 pdfopbufsize);
                    else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfflush();
                }
                {
                    pdfbuf[pdfptr] = 10;
                    incr(pdfptr);
                }
            }
        }
        print(/* str '>>' */ 1018);
        bclose(f);
    } else if (pdfmem[objtab[n].int4 + 1] > 0)
        pdfprint(s);
    else {

        pdfprint(s);
        {
            {
                if (pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfosgetosbuf(1);
                else if (!pdfosmode && (1 > pdfbufsize))
                    overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
                else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfflush();
            }
            {
                pdfbuf[pdfptr] = 10;
                incr(pdfptr);
            }
        }
    }
    if (pdfmem[objtab[n].int4 + 1] > 0)
        pdfendstream();
    else
        pdfendobj();
    flushstr(s);
}
void zflushwhatsitnode(halfword p, smallnumber s) {
    flushwhatsitnode_regmem mem[p].hh.b0 = WHATSITNODE;
    mem[p].hh.b1 = s;
    if (mem[p].hh.v.RH != TEXNULL)
        pdferror(/* str 'flush_whatsit_node' */ 1171,
                 /* str 'link(p) is not null' */ 1172);
    flushnodelist(p);
}
void zpdfwriteimage(integer n) {
    pdfwriteimage_regmem pdfbegindict(n, 0);
    if (pdfmem[objtab[n].int4 + 3] != TEXNULL) {
        pdfprinttoksln(pdfmem[objtab[n].int4 + 3]);
        {
            deletetokenref(pdfmem[objtab[n].int4 + 3]);
            pdfmem[objtab[n].int4 + 3] = TEXNULL;
        }
    }
    if (fixedpdfdraftmode == 0)
        writeimage(pdfmem[objtab[n].int4 + 4]);
    deleteimage(pdfmem[objtab[n].int4 + 4]);
}
void zpdfprintrectspec(halfword r) {
    pdfprintrectspec_regmem pdfprintmagbp(((mem[r + 1].cint) - pdforiginh));
    {
        {
            if (pdfosmode && (1 + pdfptr > pdfbufsize))
                pdfosgetosbuf(1);
            else if (!pdfosmode && (1 > pdfbufsize))
                overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
            else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                pdfflush();
        }
        {
            pdfbuf[pdfptr] = /* str ' ' */ 32;
            incr(pdfptr);
        }
    }
    pdfprintmagbp((pdforiginv - (mem[r + 4].cint)));
    {
        {
            if (pdfosmode && (1 + pdfptr > pdfbufsize))
                pdfosgetosbuf(1);
            else if (!pdfosmode && (1 > pdfbufsize))
                overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
            else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                pdfflush();
        }
        {
            pdfbuf[pdfptr] = /* str ' ' */ 32;
            incr(pdfptr);
        }
    }
    pdfprintmagbp(((mem[r + 3].cint) - pdforiginh));
    {
        {
            if (pdfosmode && (1 + pdfptr > pdfbufsize))
                pdfosgetosbuf(1);
            else if (!pdfosmode && (1 > pdfbufsize))
                overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
            else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                pdfflush();
        }
        {
            pdfbuf[pdfptr] = /* str ' ' */ 32;
            incr(pdfptr);
        }
    }
    pdfprintmagbp((pdforiginv - (mem[r + 2].cint)));
}
void zwarndestdup(integer id, smallnumber byname, strnumber s1, strnumber s2) {
    warndestdup_regmem if (eqtb[INTBASE + PDFSUPPRESSWARNINGDUPDESTCODE].cint >
                           0) return;
    pdfwarning(s1, /* str 'destination with the same identifier (' */ 1844,
               false, false);
    if (byname > 0) {
        print(/* str 'name' */ 1830);
        printmark(id);
    } else {

        print(/* str 'num' */ 1198);
        printint(id);
    }
    print(/* str ') ' */ 1845);
    print(s2);
    println();
    showcontext();
}
void zwriteaction(halfword p) {
    writeaction_regmem strnumber s;
    integer d;
    if (mem[p].hh.b0 == 3) {
        pdfprinttoksln(mem[p + 2].hh.v.LH);
        return;
    }
    pdfprint(/* str '<< ' */ 1241);
    if (mem[p + 1].hh.v.LH != TEXNULL) {
        pdfprint(/* str 'F ' */ 1926);
        s = tokenstostring(mem[p + 1].hh.v.LH);
        if ((strpool[strstart[s]] == 40) &&
            (strpool[strstart[s] + (strstart[s + 1] - strstart[s]) - 1] == 41))
            pdfprint(s);
        else {

            pdfprintstr(s);
        }
        flushstr(s);
        pdfprint(/* str ' ' */ 32);
        if (mem[p + 1].hh.v.RH > 0) {
            pdfprint(/* str 'NewWindow ' */ 1927);
            if (mem[p + 1].hh.v.RH == 1)
                pdfprint(/* str 'true ' */ 1928);
            else
                pdfprint(/* str 'false ' */ 1929);
        }
    }
    switch (mem[p].hh.b0) {
    case 0: {
        if (mem[p + 1].hh.v.LH == TEXNULL) {
            pdfprint(/* str 'S GoTo D [' */ 1930);
            pdfprintint(getobj(1, mem[p].hh.v.RH, false));
            pdfprint(/* str ' 0 R' */ 1080);
        } else {

            pdfprint(/* str 'S GoToR D [' */ 1931);
            pdfprintint(mem[p].hh.v.RH - 1);
        }
        {
            {
                if (pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfosgetosbuf(1);
                else if (!pdfosmode && (1 > pdfbufsize))
                    overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
                else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfflush();
            }
            {
                pdfbuf[pdfptr] = /* str ' ' */ 32;
                incr(pdfptr);
            }
        }
        pdfprint(tokenstostring(mem[p + 2].hh.v.LH));
        flushstr(lasttokensstring);
        {
            {
                if (pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfosgetosbuf(1);
                else if (!pdfosmode && (1 > pdfbufsize))
                    overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
                else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfflush();
            }
            {
                pdfbuf[pdfptr] = /* str ']' */ 93;
                incr(pdfptr);
            }
        }
    } break;
    case 1: {
        if (mem[p + 1].hh.v.LH == TEXNULL) {
            pdfprint(/* str 'S GoTo ' */ 1932);
            d = getobj(5, mem[p].hh.v.RH, mem[p].hh.b1);
        } else
            pdfprint(/* str 'S GoToR ' */ 1933);
        if (mem[p].hh.b1 > 0) {
            pdfstrentry(/* str 'D' */ 68, tokenstostring(mem[p].hh.v.RH));
            flushstr(lasttokensstring);
        } else if (mem[p + 1].hh.v.LH == TEXNULL)
            pdfindirect(/* str 'D' */ 68, d);
        else
            pdferror(
                /* str 'ext4' */ 1857,
                /* str '`goto' option cannot be used with both `file' and' */
                1831);
    } break;
    case 2: {
        pdfprint(/* str 'S Thread ' */ 1934);
        if (mem[p + 1].hh.v.LH == TEXNULL)
            d = getobj(9, mem[p].hh.v.RH, mem[p].hh.b1);
        if (mem[p].hh.b1 > 0) {
            pdfstrentry(/* str 'D' */ 68, tokenstostring(mem[p].hh.v.RH));
            flushstr(lasttokensstring);
        } else if (mem[p + 1].hh.v.LH == TEXNULL)
            pdfindirect(/* str 'D' */ 68, d);
        else
            pdfintentry(/* str 'D' */ 68, mem[p].hh.v.RH);
    } break;
    }
    {
        pdfprint(/* str ' >>' */ 1242);
        {
            {
                if (pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfosgetosbuf(1);
                else if (!pdfosmode && (1 > pdfbufsize))
                    overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
                else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfflush();
            }
            {
                pdfbuf[pdfptr] = 10;
                incr(pdfptr);
            }
        }
    }
}
void zsetrectdimens(halfword p, halfword parentbox, scaled x, scaled y,
                    scaled w, scaled h, scaled d, scaled margin) {
    setrectdimens_regmem mem[p + 1].cint = curh;
    if ((w == -1073741824L))
        mem[p + 3].cint = x + mem[parentbox + WIDTHOFFSET].cint;
    else
        mem[p + 3].cint = curh + w;
    if ((h == -1073741824L))
        mem[p + 2].cint = y - mem[parentbox + HEIGHTOFFSET].cint;
    else
        mem[p + 2].cint = curv - h;
    if ((d == -1073741824L))
        mem[p + 4].cint = y + mem[parentbox + DEPTHOFFSET].cint;
    else
        mem[p + 4].cint = curv + d;
    if (isshippingpage && matrixused()) {
        matrixtransformrect(mem[p + 1].cint, curpageheight - mem[p + 4].cint,
                            mem[p + 3].cint, curpageheight - mem[p + 2].cint);
        mem[p + 1].cint = getllx();
        mem[p + 4].cint = curpageheight - getlly();
        mem[p + 3].cint = geturx();
        mem[p + 2].cint = curpageheight - getury();
    }
    mem[p + 1].cint = mem[p + 1].cint - margin;
    mem[p + 2].cint = mem[p + 2].cint - margin;
    mem[p + 3].cint = mem[p + 3].cint + margin;
    mem[p + 4].cint = mem[p + 4].cint + margin;
}
void zdoannot(halfword p, halfword parentbox, scaled x, scaled y) {
    doannot_regmem if (!isshippingpage)
        pdferror(/* str 'ext4' */ 1857,
                 /* str 'annotations cannot be inside an XForm' */ 1935);
    if (doingleaders)
        return;
    if ((objtab[mem[p + 6].cint].int2 > -2))
        mem[p + 6].cint = pdfnewobjnum();
    setrectdimens(p, parentbox, x, y, mem[p + 1].cint, mem[p + 2].cint,
                  mem[p + 3].cint, 0);
    objtab[mem[p + 6].cint].int4 = p;
    {
        pdfappendlistarg = mem[p + 6].cint;
        pdfannotlist = appendptr(pdfannotlist, pdfappendlistarg);
    }
    if (objtab[mem[p + 6].cint].int2 == -2)
        objtab[mem[p + 6].cint].int2 = -1;
}
void zpushlinklevel(halfword p) {
    pushlinklevel_regmem if (pdflinkstackptr >= pdfmaxlinklevel)
        overflow(/* str 'pdf link stack size' */ 1936, pdfmaxlinklevel);
    pdfassert((mem[p].hh.b0 == WHATSITNODE) &&
              (mem[p].hh.b1 == /* @d7674@ */ 14));
    incr(pdflinkstackptr);
    pdflinkstack[pdflinkstackptr].nestinglevel = curs;
    pdflinkstack[pdflinkstackptr].linknode = copynodelist(p);
    pdflinkstack[pdflinkstackptr].reflinknode = p;
}
void poplinklevel(void) {
    poplinklevel_regmem pdfassert(pdflinkstackptr > 0);
    flushnodelist(pdflinkstack[pdflinkstackptr].linknode);
    decr(pdflinkstackptr);
}
void zdolink(halfword p, halfword parentbox, scaled x, scaled y) {
    dolink_regmem if (!isshippingpage)
        pdferror(/* str 'ext4' */ 1857,
                 /* str 'link annotations cannot be inside an XForm' */ 1937);
    pdfassert(mem[parentbox].hh.b0 == HLISTNODE);
    if ((objtab[mem[p + 6].cint].int2 > -2))
        mem[p + 6].cint = pdfnewobjnum();
    pushlinklevel(p);
    setrectdimens(p, parentbox, x, y, mem[p + 1].cint, mem[p + 2].cint,
                  mem[p + 3].cint, eqtb[DIMENBASE + PDFLINKMARGINCODE].cint);
    objtab[mem[p + 6].cint].int4 = p;
    {
        pdfappendlistarg = mem[p + 6].cint;
        pdflinklist = appendptr(pdflinklist, pdfappendlistarg);
    }
    if (objtab[mem[p + 6].cint].int2 == -2)
        objtab[mem[p + 6].cint].int2 = -1;
}
void endlink(void) {
    endlink_regmem halfword p;
    if (pdflinkstackptr < 1)
        pdferror(
            /* str 'ext4' */ 1857,
            /* str 'pdf_link_stack empty, \pdfendlink used without \p' */ 1938);
    if (pdflinkstack[pdflinkstackptr].nestinglevel != curs)
        pdferror(
            /* str 'ext4' */ 1857,
            /* str '\pdfendlink ended up in different nesting level t' */ 1939);
    if ((mem[pdflinkstack[pdflinkstackptr].linknode + 1].cint ==
         -1073741824L)) {
        p = pdflinkstack[pdflinkstackptr].reflinknode;
        if (isshippingpage && matrixused()) {
            matrixrecalculate(curh + eqtb[DIMENBASE + PDFLINKMARGINCODE].cint);
            mem[p + 1].cint =
                getllx() - eqtb[DIMENBASE + PDFLINKMARGINCODE].cint;
            mem[p + 2].cint = curpageheight - getury() -
                              eqtb[DIMENBASE + PDFLINKMARGINCODE].cint;
            mem[p + 3].cint =
                geturx() + eqtb[DIMENBASE + PDFLINKMARGINCODE].cint;
            mem[p + 4].cint = curpageheight - getlly() +
                              eqtb[DIMENBASE + PDFLINKMARGINCODE].cint;
        } else
            mem[p + 3].cint = curh + eqtb[DIMENBASE + PDFLINKMARGINCODE].cint;
    }
    poplinklevel();
}
void zappendlink(halfword parentbox, scaled x, scaled y, smallnumber i) {
    appendlink_regmem halfword p;
    pdfassert(mem[parentbox].hh.b0 == HLISTNODE);
    p = copynodelist(pdflinkstack[i].linknode);
    pdflinkstack[i].reflinknode = p;
    mem[p].hh.v.LH = 2147483647L;
    mem[p].hh.v.RH = TEXNULL;
    setrectdimens(p, parentbox, x, y, mem[p + 1].cint, mem[p + 2].cint,
                  mem[p + 3].cint, eqtb[DIMENBASE + PDFLINKMARGINCODE].cint);
    pdfcreateobj(0, 0);
    objtab[objptr].int4 = p;
    {
        pdfappendlistarg = objptr;
        pdflinklist = appendptr(pdflinklist, pdfappendlistarg);
    }
}
void zappendbead(halfword p) {
    appendbead_regmem integer a, b, c, t;
    if (!isshippingpage)
        pdferror(/* str 'ext4' */ 1857,
                 /* str 'threads cannot be inside an XForm' */ 1940);
    t = getobj(9, mem[p + 5].hh.v.RH, mem[p + 5].hh.b1);
    b = pdfnewobjnum();
    objtab[b].int4 = pdfgetmem(5);
    pdfmem[objtab[b].int4 + 1] = pdflastpage;
    pdfmem[objtab[b].int4] = p;
    if (mem[p + 6].hh.v.LH != TEXNULL)
        pdfmem[objtab[b].int4 + 4] = tokenstostring(mem[p + 6].hh.v.LH);
    else
        pdfmem[objtab[b].int4 + 4] = 0;
    if (objtab[t].int4 == 0) {
        objtab[t].int4 = b;
        pdfmem[objtab[b].int4 + 2] = b;
        pdfmem[objtab[b].int4 + 3] = b;
    } else {

        a = objtab[t].int4;
        c = pdfmem[objtab[a].int4 + 3];
        pdfmem[objtab[b].int4 + 3] = c;
        pdfmem[objtab[b].int4 + 2] = a;
        pdfmem[objtab[a].int4 + 3] = b;
        pdfmem[objtab[c].int4 + 2] = b;
    }
    {
        pdfappendlistarg = b;
        pdfbeadlist = appendptr(pdfbeadlist, pdfappendlistarg);
    }
}
void zdothread(halfword p, halfword parentbox, scaled x, scaled y) {
    dothread_regmem if (doingleaders) return;
    if (mem[p].hh.b1 == /* @d7702@ */ 19) {
        pdfthreadwd = mem[p + 1].cint;
        pdfthreadht = mem[p + 2].cint;
        pdfthreaddp = mem[p + 3].cint;
        pdflastthreadid = mem[p + 5].hh.v.RH;
        pdflastthreadnamedid = (mem[p + 5].hh.b1 > 0);
        if (pdflastthreadnamedid)
            incr(mem[mem[p + 5].hh.v.RH].hh.v.LH);
        pdfthreadlevel = curs;
    }
    setrectdimens(p, parentbox, x, y, mem[p + 1].cint, mem[p + 2].cint,
                  mem[p + 3].cint, eqtb[DIMENBASE + PDFTHREADMARGINCODE].cint);
    appendbead(p);
    lastthread = p;
}
void zappendthread(halfword parentbox, scaled x, scaled y) {
    appendthread_regmem halfword p;
    p = getnode(7);
    mem[p].hh.v.LH = 2147483647L;
    mem[p].hh.v.RH = TEXNULL;
    mem[p + 1].cint = pdfthreadwd;
    mem[p + 2].cint = pdfthreadht;
    mem[p + 3].cint = pdfthreaddp;
    mem[p + 6].hh.v.LH = TEXNULL;
    mem[p + 5].hh.v.RH = pdflastthreadid;
    if (pdflastthreadnamedid) {
        incr(mem[mem[p + 5].hh.v.RH].hh.v.LH);
        mem[p + 5].hh.b1 = 1;
    } else
        mem[p + 5].hh.b1 = 0;
    setrectdimens(p, parentbox, x, y, mem[p + 1].cint, mem[p + 2].cint,
                  mem[p + 3].cint, eqtb[DIMENBASE + PDFTHREADMARGINCODE].cint);
    appendbead(p);
    lastthread = p;
}
void endthread(void) {
    endthread_regmem if (pdfthreadlevel != curs) pdferror(
        /* str 'ext4' */ 1857,
        /* str '\pdfendthread ended up in different nesting level' */ 1941);
    if ((pdfthreaddp == -1073741824L) && (lastthread != TEXNULL))
        mem[lastthread + 4].cint =
            curv + eqtb[DIMENBASE + PDFTHREADMARGINCODE].cint;
    if (pdflastthreadnamedid)
        deletetokenref(pdflastthreadid);
    lastthread = TEXNULL;
}
integer zopensubentries(halfword p) {
    register integer Result;
    opensubentries_regmem integer k, c;
    integer l, r;
    k = 0;
    if (pdfmem[objtab[p].int4 + 4] != 0) {
        l = pdfmem[objtab[p].int4 + 4];
        do {
            incr(k);
            c = opensubentries(l);
            if (objtab[l].int0 > 0)
                k = k + c;
            pdfmem[objtab[l].int4 + 1] = p;
            r = pdfmem[objtab[l].int4 + 3];
            if (r == 0)
                pdfmem[objtab[p].int4 + 5] = l;
            l = r;
        } while (!(l == 0));
    }
    if (objtab[p].int0 > 0)
        objtab[p].int0 = k;
    else
        objtab[p].int0 = -(integer)k;
    Result = k;
    return Result;
}
void zdodest(halfword p, halfword parentbox, scaled x, scaled y) {
    dodest_regmem integer k;
    if (!isshippingpage)
        pdferror(/* str 'ext4' */ 1857,
                 /* str 'destinations cannot be inside an XForm' */ 1942);
    if (doingleaders)
        return;
    k = getobj(5, mem[p + 5].hh.v.RH, mem[p + 5].hh.b1);
    if (objtab[k].int4 != TEXNULL) {
        warndestdup(mem[p + 5].hh.v.RH, mem[p + 5].hh.b1, /* str 'ext4' */ 1857,
                    /* str 'has been already used, duplicate ignored' */ 1858);
        return;
    }
    objtab[k].int4 = p;
    {
        pdfappendlistarg = k;
        pdfdestlist = appendptr(pdfdestlist, pdfappendlistarg);
    }
    switch (mem[p + 5].hh.b0) {
    case 0:
        if (matrixused())
            setrectdimens(p, parentbox, x, y, mem[p + 1].cint, mem[p + 2].cint,
                          mem[p + 3].cint,
                          eqtb[DIMENBASE + PDFDESTMARGINCODE].cint);
        else {

            mem[p + 1].cint = curh;
            mem[p + 2].cint = curv;
        }
        break;
    case 2:
    case 5:
        if (matrixused())
            setrectdimens(p, parentbox, x, y, mem[p + 1].cint, mem[p + 2].cint,
                          mem[p + 3].cint,
                          eqtb[DIMENBASE + PDFDESTMARGINCODE].cint);
        else
            mem[p + 2].cint = curv;
        break;
    case 3:
    case 6:
        if (matrixused())
            setrectdimens(p, parentbox, x, y, mem[p + 1].cint, mem[p + 2].cint,
                          mem[p + 3].cint,
                          eqtb[DIMENBASE + PDFDESTMARGINCODE].cint);
        else
            mem[p + 1].cint = curh;
        break;
    case 1:
    case 4:;
        break;
    case 7:
        setrectdimens(p, parentbox, x, y, mem[p + 1].cint, mem[p + 2].cint,
                      mem[p + 3].cint,
                      eqtb[DIMENBASE + PDFDESTMARGINCODE].cint);
        break;
    }
}
void zoutform(halfword p) {
    outform_regmem pdfendtext();
    {
        pdfprint(/* str 'q' */ 113);
        {
            {
                if (pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfosgetosbuf(1);
                else if (!pdfosmode && (1 > pdfbufsize))
                    overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
                else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfflush();
            }
            {
                pdfbuf[pdfptr] = 10;
                incr(pdfptr);
            }
        }
    }
    if (pdflookuplist(pdfxformlist, mem[p + 4].hh.v.LH) == TEXNULL) {
        pdfappendlistarg = mem[p + 4].hh.v.LH;
        pdfxformlist = appendptr(pdfxformlist, pdfappendlistarg);
    }
    curv = curv + pdfmem[objtab[mem[p + 4].hh.v.LH].int4 + 2];
    pdfprint(/* str '1 0 0 1 ' */ 1029);
    pdfprintbp(((curh)-pdforiginh));
    {
        {
            if (pdfosmode && (1 + pdfptr > pdfbufsize))
                pdfosgetosbuf(1);
            else if (!pdfosmode && (1 > pdfbufsize))
                overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
            else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                pdfflush();
        }
        {
            pdfbuf[pdfptr] = /* str ' ' */ 32;
            incr(pdfptr);
        }
    }
    pdfprintbp((pdforiginv - (curv)));
    {
        pdfprint(/* str ' cm' */ 1030);
        {
            {
                if (pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfosgetosbuf(1);
                else if (!pdfosmode && (1 > pdfbufsize))
                    overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
                else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfflush();
            }
            {
                pdfbuf[pdfptr] = 10;
                incr(pdfptr);
            }
        }
    }
    pdfprint(/* str 'Fm' */ 1153);
    pdfprintint(objtab[mem[p + 4].hh.v.LH].int0);
    if (pdfresnameprefix != 0)
        pdfprint(pdfresnameprefix);
    {
        pdfprint(/* str ' Do' */ 1943);
        {
            {
                if (pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfosgetosbuf(1);
                else if (!pdfosmode && (1 > pdfbufsize))
                    overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
                else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfflush();
            }
            {
                pdfbuf[pdfptr] = 10;
                incr(pdfptr);
            }
        }
    }
    {
        pdfprint(/* str 'Q' */ 81);
        {
            {
                if (pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfosgetosbuf(1);
                else if (!pdfosmode && (1 > pdfbufsize))
                    overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
                else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfflush();
            }
            {
                pdfbuf[pdfptr] = 10;
                incr(pdfptr);
            }
        }
    }
}
void zoutimage(halfword p) {
    outimage_regmem integer image, groupref;
    integer imgw, imgh;
    image = pdfmem[objtab[mem[p + 4].hh.v.LH].int4 + 4];
    if ((imagerotate(image) == 90) || (imagerotate(image) == 270)) {
        imgh = imagewidth(image);
        imgw = imageheight(image);
    } else {

        imgw = imagewidth(image);
        imgh = imageheight(image);
    }
    pdfendtext();
    {
        pdfprint(/* str 'q' */ 113);
        {
            {
                if (pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfosgetosbuf(1);
                else if (!pdfosmode && (1 > pdfbufsize))
                    overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
                else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfflush();
            }
            {
                pdfbuf[pdfptr] = 10;
                incr(pdfptr);
            }
        }
    }
    if (pdflookuplist(pdfximagelist, mem[p + 4].hh.v.LH) == TEXNULL) {
        pdfappendlistarg = mem[p + 4].hh.v.LH;
        pdfximagelist = appendptr(pdfximagelist, pdfappendlistarg);
    }
    if (!ispdfimage(image)) {
        if (ispngimage(image)) {
            groupref = getimagegroupref(image);
            if ((groupref > 0) && (pdfpagegroupval == 0))
                pdfpagegroupval = groupref;
        }
        pdfprintreal(extxnoverd(mem[p + 1].cint, tenpow[6], onehundredbp), 4);
        pdfprint(/* str ' 0 0 ' */ 1148);
        pdfprintreal(extxnoverd(mem[p + 2].cint + mem[p + 3].cint, tenpow[6],
                                onehundredbp),
                     4);
        {
            {
                if (pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfosgetosbuf(1);
                else if (!pdfosmode && (1 > pdfbufsize))
                    overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
                else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfflush();
            }
            {
                pdfbuf[pdfptr] = /* str ' ' */ 32;
                incr(pdfptr);
            }
        }
        pdfprintbp(((curh)-pdforiginh));
        {
            {
                if (pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfosgetosbuf(1);
                else if (!pdfosmode && (1 > pdfbufsize))
                    overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
                else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfflush();
            }
            {
                pdfbuf[pdfptr] = /* str ' ' */ 32;
                incr(pdfptr);
            }
        }
        pdfprintbp((pdforiginv - (curv)));
    } else {

        groupref = getimagegroupref(image);
        if ((groupref != 0) && (pdfpagegroupval == 0)) {
            if (groupref == -1) {
                pdfpagegroupval = pdfnewobjnum();
                setimagegroupref(image, pdfpagegroupval);
            } else
                pdfpagegroupval = groupref;
        }
        pdfprintreal(extxnoverd(mem[p + 1].cint, tenpow[6], imgw), 6);
        pdfprint(/* str ' 0 0 ' */ 1148);
        pdfprintreal(
            extxnoverd(mem[p + 2].cint + mem[p + 3].cint, tenpow[6], imgh), 6);
        {
            {
                if (pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfosgetosbuf(1);
                else if (!pdfosmode && (1 > pdfbufsize))
                    overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
                else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfflush();
            }
            {
                pdfbuf[pdfptr] = /* str ' ' */ 32;
                incr(pdfptr);
            }
        }
        pdfprintbp(((curh)-pdforiginh) -
                   extxnoverd(mem[p + 1].cint, epdforigx(image), imgw));
        {
            {
                if (pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfosgetosbuf(1);
                else if (!pdfosmode && (1 > pdfbufsize))
                    overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
                else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfflush();
            }
            {
                pdfbuf[pdfptr] = /* str ' ' */ 32;
                incr(pdfptr);
            }
        }
        pdfprintbp((pdforiginv - (curv)) -
                   extxnoverd(mem[p + 2].cint + mem[p + 3].cint,
                              epdforigy(image), imgh));
    }
    {
        pdfprint(/* str ' cm' */ 1030);
        {
            {
                if (pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfosgetosbuf(1);
                else if (!pdfosmode && (1 > pdfbufsize))
                    overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
                else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfflush();
            }
            {
                pdfbuf[pdfptr] = 10;
                incr(pdfptr);
            }
        }
    }
    pdfprint(/* str 'Im' */ 1154);
    pdfprintint(objtab[mem[p + 4].hh.v.LH].int0);
    if (pdfresnameprefix != 0)
        pdfprint(pdfresnameprefix);
    {
        pdfprint(/* str ' Do' */ 1943);
        {
            {
                if (pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfosgetosbuf(1);
                else if (!pdfosmode && (1 > pdfbufsize))
                    overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
                else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfflush();
            }
            {
                pdfbuf[pdfptr] = 10;
                incr(pdfptr);
            }
        }
    }
    {
        pdfprint(/* str 'Q' */ 81);
        {
            {
                if (pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfosgetosbuf(1);
                else if (!pdfosmode && (1 > pdfbufsize))
                    overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
                else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfflush();
            }
            {
                pdfbuf[pdfptr] = 10;
                incr(pdfptr);
            }
        }
    }
}
scaled zgapamount(halfword p, scaled curpos) {
    register scaled Result;
    gapamount_regmem scaled snapunit, stretchamount, shrinkamount;
    scaled lastpos, nextpos, g, g2;
    snapunit = mem[mem[p + 1].hh.v.LH /* @d7756@ */ + 1].cint;
    if (mem[mem[p + 1].hh.v.LH].hh.b0 > NORMAL)
        stretchamount = 1073741823L;
    else
        stretchamount = mem[mem[p + 1].hh.v.LH + 2].cint;
    if (mem[mem[p + 1].hh.v.LH].hh.b1 > NORMAL)
        shrinkamount = 1073741823L;
    else
        shrinkamount = mem[mem[p + 1].hh.v.LH + 3].cint;
    if (mem[p].hh.b1 == /* @d7759@ */ 35)
        lastpos =
            pdfsnapyrefpos + snapunit * ((curpos - pdfsnapyrefpos) / snapunit);
    else
        pdferror(/* str 'snapping' */ 1944,
                 /* str 'invalid parameter value for gap_amount' */ 1945);
    nextpos = lastpos + snapunit;
    g = 1073741823L;
    g2 = 1073741823L;
    Result = 0;
    if (curpos - lastpos < shrinkamount)
        g = curpos - lastpos;
    if ((nextpos - curpos < stretchamount))
        g2 = nextpos - curpos;
    if ((g == 1073741823L) && (g2 == 1073741823L))
        return Result;
    if (g2 <= g)
        Result = g2;
    else
        Result = -(integer)g;
    return Result;
}
halfword zgetvpos(halfword p, halfword q, halfword b) {
    register halfword Result;
    getvpos_regmem scaled tmpv;
    glueord gorder;
    unsigned char gsign;
    real gluetemp;
    real curglue;
    scaled curg;
    halfword thisbox;
    tmpv = curv;
    thisbox = b;
    curg = 0;
    curglue = 0.0;
    gorder = mem[thisbox + LISTOFFSET].hh.b1;
    gsign = mem[thisbox + LISTOFFSET].hh.b0;
    while ((p != q) && (p != TEXNULL)) {

        if ((p >= himemmin))
            confusion(/* str 'get_vpos' */ 1954);
        else {

            switch (mem[p].hh.b0) {
            case HLISTNODE:
            case VLISTNODE:
            case RULENODE:
                tmpv = tmpv + mem[p + HEIGHTOFFSET].cint +
                       mem[p + DEPTHOFFSET].cint;
                break;
            case WHATSITNODE:
                if ((mem[p].hh.b1 == /* @d7782@ */ 10) ||
                    (mem[p].hh.b1 == /* @d7783@ */ 12))
                    tmpv = tmpv + mem[p + 2].cint + mem[p + 3].cint;
                break;
            case GLUENODE: {
                /* comment:Move down without outputting leaders */ {

                    g = mem[p + 1].hh.v.LH;
                    ruleht = mem[g + WIDTHOFFSET].cint - curg;
                    if (gsign != NORMAL) {
                        if (gsign == STRETCHING) {
                            if (mem[g].hh.b0 == gorder) {
                                curglue = curglue + mem[g + 2].cint;
                                gluetemp =
                                    mem[thisbox + GLUEOFFSET].gr * curglue;
                                if (gluetemp > 1000000000.0)
                                    gluetemp = 1000000000.0;
                                else if (gluetemp < -1000000000.0)
                                    gluetemp = -1000000000.0;
                                curg = round(gluetemp);
                            }
                        } else if (mem[g].hh.b1 == gorder) {
                            curglue = curglue - mem[g + 3].cint;
                            gluetemp = mem[thisbox + GLUEOFFSET].gr * curglue;
                            if (gluetemp > 1000000000.0)
                                gluetemp = 1000000000.0;
                            else if (gluetemp < -1000000000.0)
                                gluetemp = -1000000000.0;
                            curg = round(gluetemp);
                        }
                    }
                    ruleht = ruleht + curg;
                }
                tmpv = tmpv + ruleht;
            } break;
            case KERNNODE:
                tmpv = tmpv + mem[p + WIDTHOFFSET].cint;
                break;
            default:;
                break;
            }
        }
        p = mem[p].hh.v.RH;
    }
    Result = tmpv;
    return Result;
}
void zdosnapycomp(halfword p, halfword b) {
    dosnapycomp_regmem halfword q;
    scaled tmpv, g, g2;
    if (!(!(p >= himemmin) && (mem[p].hh.b0 == WHATSITNODE) &&
          (mem[p].hh.b1 == /* @d7794@ */ 36)))
        pdferror(/* str 'snapping' */ 1944,
                 /* str 'invalid parameter value for do_snapy_comp' */ 1955);
    q = p;
    while ((q != TEXNULL)) {

        if (!(q >= himemmin) && (mem[q].hh.b0 == WHATSITNODE) &&
            (mem[q].hh.b1 == /* @d7798@ */ 35)) {
            tmpv = getvpos(p, q, b);
            g = gapamount(q, tmpv);
            g2 = roundxnoverd(g, mem[p + 1].cint, 1000);
            curv = curv + g2;
            mem[q + 2].cint = g - g2;
            if (mem[q + 2].cint == 0)
                mem[q + 2].cint = 1;
            return;
        }
        q = mem[q].hh.v.RH;
    }
}
void zdosnapy(halfword p) {
    dosnapy_regmem incr(countdosnapy);
    if (mem[p + 2].cint != 0)
        curv = curv + mem[p + 2].cint;
    else
        curv = curv + gapamount(p, curv);
}
void pdfhlistout(void) {
    /* @d7808@ */ /* @d7809@ */ /* @d7810@ */ /* @d7811@ */ /* @d7812@ */
    pdfhlistout_regmem scaled baseline;
    scaled leftedge;
    scaled saveh;
    halfword thisbox;
    glueord gorder;
    unsigned char gsign;
    halfword p;
    halfword leaderbox;
    scaled leaderwd;
    scaled lx;
    boolean outerdoingleaders;
    scaled edge;
    halfword prevp;
    real gluetemp;
    real curglue;
    scaled curg;
    smallnumber i;
    curg = 0;
    curglue = 0.0;
    thisbox = tempptr;
    gorder = mem[thisbox + LISTOFFSET].hh.b1;
    gsign = mem[thisbox + LISTOFFSET].hh.b0;
    p = mem[thisbox + LISTOFFSET].hh.v.RH;
    incr(curs);
    baseline = curv;
    prevp = thisbox + LISTOFFSET;
    /* comment:Initialize |hlist_out| for mixed direction typeset */
    if ((eTeXmode == 1)) {
        /* comment:Initialize the LR stack */ {

            tempptr = getavail();
            mem[tempptr].hh.v.LH = BEFORE;
            mem[tempptr].hh.v.RH = LRptr;
            LRptr = tempptr;
        }
        if ((mem[thisbox].hh.b1) == DLIST) {

            if (curdir == RIGHTTOLEFT) {
                curdir = LEFTTORIGHT;
                curh = curh - mem[thisbox + WIDTHOFFSET].cint;
            } else
                mem[thisbox].hh.b1 = 0;
        }
        if ((curdir == RIGHTTOLEFT) &&
            ((mem[thisbox].hh.b1) !=
             REVERSED)) /* comment:Reverse the complete hlist and set the
                                  subtype to  */
        {
            saveh = curh;
            tempptr = p;
            p = newkern(0);
            mem[prevp].hh.v.RH = p;
            curh = 0;
            mem[p].hh.v.RH = reverse(thisbox, TEXNULL, curg, curglue);
            mem[p + WIDTHOFFSET].cint = -(integer)curh;
            curh = saveh;
            mem[thisbox].hh.b1 = REVERSED;
        }
    }
    leftedge = curh;
    /* comment:Create link annotations for the current hbox if ne */ {
        register integer for_end;
        i = 1;
        for_end = pdflinkstackptr;
        if (i <= for_end)
            do {
                pdfassert(
                    (mem[pdflinkstack[i].linknode + 1].cint == -1073741824L));
                if ((pdflinkstack[i].nestinglevel == curs))
                    appendlink(thisbox, leftedge, baseline, i);
            } while (i++ < for_end);
    }
    while (p != TEXNULL) /* comment:Output node |p| for |pdf_hlist_out| and move
                            to th */
    labpdfhlistout21reswitch:
        if ((p >= himemmin)) {
            do {
                f = mem[p].hh.b0;
                c = mem[p].hh.b1;
                if (((fontbc[f] <= c) && (c <= fontec[f]) &&
                     (fontinfo[charbase[f] + c].qqqq.b0 > MINQUARTERWORD))) {
                    {
                        if (pdffonttype[f] == NEWFONTTYPE)
                            dovf(f);
                        if (pdffonttype[f] == VIRTUALFONTTYPE)
                            dovfpacket(f, c, p);
                        else {

                            pdfbeginstring(f, p);
                            pdfprintchar(f, c);
                            advcharwidth(f, c);
                        }
                    }
                    curh = curh + fontinfo[widthbase[f] +
                                           fontinfo[charbase[f] +
                                                    effectivechar(true, f, c)]
                                               .qqqq.b0]
                                      .cint;
                    goto labpdfhlistout22continue;
                }
                if (mltexenabledp) /* comment:(\pdfTeX) Output a substitution,
                                      |goto continue| i */
                {
                    /* comment:Get substitution information, check it, goto
                     * |foun */
                    if (c >= eqtb[INTBASE + CHARSUBDEFMINCODE].cint) {

                        if (c <= eqtb[INTBASE + CHARSUBDEFMAXCODE].cint) {

                            if ((eqtb[CHARSUBCODEBASE + c].hh.v.RH > 0)) {
                                basec =
                                    (eqtb[CHARSUBCODEBASE + c].hh.v.RH % 256);
                                accentc =
                                    (eqtb[CHARSUBCODEBASE + c].hh.v.RH / 256);
                                if ((fontec[f] >= basec)) {

                                    if ((fontbc[f] <= basec)) {

                                        if ((fontec[f] >= accentc)) {

                                            if ((fontbc[f] <= accentc)) {
                                                iac = fontinfo[charbase[f] +
                                                               effectivechar(
                                                                   true, f,
                                                                   accentc)]
                                                          .qqqq;
                                                ibc = fontinfo[charbase[f] +
                                                               effectivechar(
                                                                   true, f,
                                                                   basec)]
                                                          .qqqq;
                                                if ((ibc.b0 > MINQUARTERWORD)) {

                                                    if ((iac.b0 >
                                                         MINQUARTERWORD))
                                                        goto labpdfhlistout40found;
                                                }
                                            }
                                        }
                                    }
                                }
                                begindiagnostic();
                                printnl(/* str 'Missing character' */ 2076);
                                print(c);
                                print(/* str ' = ' */ 1630);
                                print(accentc);
                                print(/* str ' ' */ 32);
                                print(basec);
                                print(/* str ' in font ' */ 984);
                                slowprint(fontname[f]);
                                printchar(/* str '!' */ 33);
                                enddiagnostic(false);
                                goto labpdfhlistout22continue;
                            }
                        }
                    }
                    begindiagnostic();
                    printnl(/* str 'Missing character' */ 983);
                    print(/* str 'substitution for ' */ 2075);
                    print(c);
                    print(/* str ' in font ' */ 984);
                    slowprint(fontname[f]);
                    printchar(/* str '!' */ 33);
                    enddiagnostic(false);
                    goto labpdfhlistout22continue;
                labpdfhlistout40found
                    : /* comment:Print character substition tracing log */
                    if (eqtb[INTBASE + TRACINGLOSTCHARSCODE].cint > 99) {
                        begindiagnostic();
                        printnl(/* str 'Using character substitution' */ 2077);
                        print(c);
                        print(/* str ' = ' */ 1630);
                        print(accentc);
                        print(/* str ' ' */ 32);
                        print(basec);
                        print(/* str ' in font ' */ 984);
                        slowprint(fontname[f]);
                        printchar(/* str '.' */ 46);
                        enddiagnostic(false);
                    }
                    /* comment:(\pdfTeX) Rebuild character using substitution
                     * inf */
                    basexheight = fontinfo[XHEIGHTCODE + parambase[f]].cint;
                    baseslant = fontinfo[SLANTCODE + parambase[f]].cint /
                                ((double)65536.0);
                    accentslant = baseslant;
                    basewidth = fontinfo[widthbase[f] + ibc.b0].cint;
                    baseheight = fontinfo[heightbase[f] + (ibc.b1) / 16].cint;
                    accentwidth = fontinfo[widthbase[f] + iac.b0].cint;
                    accentheight = fontinfo[heightbase[f] + (iac.b1) / 16].cint;
                    delta = round((basewidth - accentwidth) / ((double)2.0) +
                                  baseheight * baseslant -
                                  basexheight * accentslant);
                    curh = curh + delta;
                    if (((baseheight != basexheight) && (accentheight > 0))) {
                        curv = baseline + (basexheight - baseheight);
                        {
                            if (pdffonttype[f] == NEWFONTTYPE)
                                dovf(f);
                            if (pdffonttype[f] == VIRTUALFONTTYPE)
                                dovfpacket(f, accentc, p);
                            else {

                                pdfbeginstring(f, p);
                                pdfprintchar(f, accentc);
                                advcharwidth(f, accentc);
                            }
                        }
                        curv = baseline;
                    } else {

                        {
                            if (pdffonttype[f] == NEWFONTTYPE)
                                dovf(f);
                            if (pdffonttype[f] == VIRTUALFONTTYPE)
                                dovfpacket(f, accentc, p);
                            else {

                                pdfbeginstring(f, p);
                                pdfprintchar(f, accentc);
                                advcharwidth(f, accentc);
                            }
                        }
                    }
                    curh = curh + accentwidth;
                    curh = curh + (-(integer)accentwidth - delta);
                    {
                        if (pdffonttype[f] == NEWFONTTYPE)
                            dovf(f);
                        if (pdffonttype[f] == VIRTUALFONTTYPE)
                            dovfpacket(f, basec, p);
                        else {

                            pdfbeginstring(f, p);
                            pdfprintchar(f, basec);
                            advcharwidth(f, basec);
                        }
                    }
                    curh = curh + basewidth;
                }
            labpdfhlistout22continue:
                prevp = mem[prevp].hh.v.RH;
                p = mem[p].hh.v.RH;
            } while (!(!(p >= himemmin)));
        } else /* comment:Output the non-|char_node| |p| for |pdf_hlist_out| */
        {

            switch (mem[p].hh.b0) {
            case HLISTNODE:
            case VLISTNODE:
                /* comment:(\pdfTeX) Output a box in an hlist */
                if (mem[p + LISTOFFSET].hh.v.RH == TEXNULL)
                    curh = curh + mem[p + WIDTHOFFSET].cint;
                else {

                    curv = baseline + mem[p + 4].cint;
                    tempptr = p;
                    edge = curh + mem[p + WIDTHOFFSET].cint;
                    if (curdir == RIGHTTOLEFT)
                        curh = edge;
                    if (mem[p].hh.b0 == VLISTNODE)
                        pdfvlistout();
                    else
                        pdfhlistout();
                    curh = edge;
                    curv = baseline;
                }
                break;
            case RULENODE: {
                ruleht = mem[p + HEIGHTOFFSET].cint;
                ruledp = mem[p + DEPTHOFFSET].cint;
                rulewd = mem[p + WIDTHOFFSET].cint;
                goto labpdfhlistout14fin_rule;
            } break;
            case WHATSITNODE:
                /* comment:Output the whatsit node |p| in |pdf_hlist_out| */
                switch (mem[p].hh.b1) {
                case PDFTEXFIRSTEXTENSIONCODE:
                    pdfoutliteral(p);
                    break;
                case PDFTEXFIRSTEXTENSIONCODE + 32:
                    pdfoutcolorstack(p);
                    break;
                case PDFTEXFIRSTEXTENSIONCODE + 33:
                    pdfoutsetmatrix(p);
                    break;
                case PDFTEXFIRSTEXTENSIONCODE + 34:
                    pdfoutsave(p);
                    break;
                case PDFTEXFIRSTEXTENSIONCODE + 35:
                    pdfoutrestore(p);
                    break;
                case PDFTEXFIRSTEXTENSIONCODE + 2: {
                    pdfappendlistarg = mem[p + 1].hh.v.LH;
                    pdfobjlist = appendptr(pdfobjlist, pdfappendlistarg);
                } break;
                case PDFTEXFIRSTEXTENSIONCODE + 4:
                    /* comment:Output a Form node in a hlist */ {

                        curv = baseline;
                        edge = curh;
                        outform(p);
                        curh = edge + mem[p + 1].cint;
                        curv = baseline;
                    }
                    break;
                case PDFTEXFIRSTEXTENSIONCODE + 6:
                    /* comment:Output a Image node in a hlist */ {

                        curv = baseline + mem[p + 3].cint;
                        edge = curh;
                        outimage(p);
                        curh = edge + mem[p + 1].cint;
                        curv = baseline;
                    }
                    break;
                case PDFTEXFIRSTEXTENSIONCODE + 7:
                    doannot(p, thisbox, leftedge, baseline);
                    break;
                case PDFTEXFIRSTEXTENSIONCODE + 8:
                    dolink(p, thisbox, leftedge, baseline);
                    break;
                case PDFTEXFIRSTEXTENSIONCODE + 9:
                    endlink();
                    break;
                case PDFTEXFIRSTEXTENSIONCODE + 11:
                    dodest(p, thisbox, leftedge, baseline);
                    break;
                case PDFTEXFIRSTEXTENSIONCODE + 12:
                    dothread(p, thisbox, leftedge, baseline);
                    break;
                case PDFTEXFIRSTEXTENSIONCODE + 13:
                    pdferror(
                        /* str 'ext4' */ 1857,
                        /* str '\pdfstartthread ended up in hlist' */ 1966);
                    break;
                case PDFTEXFIRSTEXTENSIONCODE + 14:
                    pdferror(/* str 'ext4' */ 1857,
                             /* str '\pdfendthread ended up in hlist' */ 1967);
                    break;
                case PDFTEXFIRSTEXTENSIONCODE + 15:
                    /* comment:Save current position to |pdf_last_x_pos|,
                     * |pdf_la */
                    {

                        pdflastxpos = curh;
                        if (isshippingpage)
                            pdflastypos = curpageheight - curv;
                        else
                            pdflastypos = pdfxformheight + pdfxformdepth - curv;
                    }
                    break;
                case SPECIALNODE:
                    pdfspecial(p);
                    break;
                case PDFTEXFIRSTEXTENSIONCODE + 28:
                    /* comment:Save current position to |pdf_snapx_refpos|,
                     * |pdf_ */
                    {

                        pdfsnapxrefpos = curh;
                        pdfsnapyrefpos = curv;
                    }
                    break;
                case PDFTEXFIRSTEXTENSIONCODE + 30:
                case PDFTEXFIRSTEXTENSIONCODE + 29:;
                    break;
                case PDFTEXFIRSTEXTENSIONCODE + 37:
                    genfakedinterwordspace = true;
                    break;
                case PDFTEXFIRSTEXTENSIONCODE + 38:
                    genfakedinterwordspace = false;
                    break;
                case PDFTEXFIRSTEXTENSIONCODE + 39:
                    pdfinsertfakespace();
                    break;
                default:
                    outwhat(p);
                    break;
                }
                break;
            case GLUENODE:
                /* comment:(\pdfTeX) Move right or output leaders */ {

                    g = mem[p + 1].hh.v.LH;
                    rulewd = mem[g + WIDTHOFFSET].cint - curg;
                    if (pdfdoingstring) {
                        pdfprint(/* str ')' */ 41);
                        pdfprint(/* str ']TJ ' */ 1051);
                        pdfprintint(obtaincharacterinfo(p, 0));
                        pdfprint(/* str ' i ' */ 1049);
                        pdfprintint(obtaincharacterinfo(p, 1));
                        pdfprint(/* str ' J [(' */ 1052);
                    }
                    if (gsign != NORMAL) {
                        if (gsign == STRETCHING) {
                            if (mem[g].hh.b0 == gorder) {
                                curglue = curglue + mem[g + 2].cint;
                                gluetemp =
                                    mem[thisbox + GLUEOFFSET].gr * curglue;
                                if (gluetemp > 1000000000.0)
                                    gluetemp = 1000000000.0;
                                else if (gluetemp < -1000000000.0)
                                    gluetemp = -1000000000.0;
                                curg = round(gluetemp);
                            }
                        } else if (mem[g].hh.b1 == gorder) {
                            curglue = curglue - mem[g + 3].cint;
                            gluetemp = mem[thisbox + GLUEOFFSET].gr * curglue;
                            if (gluetemp > 1000000000.0)
                                gluetemp = 1000000000.0;
                            else if (gluetemp < -1000000000.0)
                                gluetemp = -1000000000.0;
                            curg = round(gluetemp);
                        }
                    }
                    rulewd = rulewd + curg;
                    if ((eTeXmode == 1)) /* comment:Handle a glue node for mixed
                                            direction typesetting */
                    {

                        if ((((gsign == STRETCHING) &&
                              (mem[g].hh.b0 == gorder)) ||
                             ((gsign == SHRINKING) &&
                              (mem[g].hh.b1 == gorder)))) {
                            {
                                if (mem[g].hh.v.RH == TEXNULL)
                                    freenode(g, GLUESPECSIZE);
                                else
                                    decr(mem[g].hh.v.RH);
                            }
                            if (mem[p].hh.b1 < ALEADERS) {
                                mem[p].hh.b0 = KERNNODE;
                                mem[p + WIDTHOFFSET].cint = rulewd;
                            } else {

                                g = getnode(GLUESPECSIZE);
                                mem[g].hh.b0 = /* @d7947@ */ 4;
                                mem[g].hh.b1 = /* @d7948@ */ 4;
                                mem[g + WIDTHOFFSET].cint = rulewd;
                                mem[g + 2].cint = 0;
                                mem[g + 3].cint = 0;
                                mem[p + 1].hh.v.LH = g;
                            }
                        }
                    }
                    if (mem[p].hh.b1 >=
                        ALEADERS) /* comment:(\pdfTeX) Output leaders
                                              in an hlist, |goto fin_ru */
                    {
                        leaderbox = mem[p + 1].hh.v.RH;
                        if (mem[leaderbox].hh.b0 == RULENODE) {
                            ruleht = mem[leaderbox + HEIGHTOFFSET].cint;
                            ruledp = mem[leaderbox + DEPTHOFFSET].cint;
                            goto labpdfhlistout14fin_rule;
                        }
                        leaderwd = mem[leaderbox + WIDTHOFFSET].cint;
                        if ((leaderwd > 0) && (rulewd > 0)) {
                            rulewd = rulewd + 10;
                            if (curdir == RIGHTTOLEFT)
                                curh = curh - 10;
                            edge = curh + rulewd;
                            lx = 0;
                            /* comment:Let |cur_h| be the position of the first
                             * box, and  */
                            if (mem[p].hh.b1 == ALEADERS) {
                                saveh = curh;
                                curh =
                                    leftedge +
                                    leaderwd * ((curh - leftedge) / leaderwd);
                                if (curh < saveh)
                                    curh = curh + leaderwd;
                            } else {

                                lq = rulewd / leaderwd;
                                lr = rulewd % leaderwd;
                                if (mem[p].hh.b1 == CLEADERS)
                                    curh = curh + (lr / 2);
                                else {

                                    lx = lr / (lq + 1);
                                    curh = curh + ((lr - (lq - 1) * lx) / 2);
                                }
                            }
                            while (curh + leaderwd <=
                                   edge) /* comment:(\pdfTeX) Output a leader
                                            box at |cur_h|, then adv */
                            {

                                curv = baseline + mem[leaderbox + 4].cint;
                                saveh = curh;
                                tempptr = leaderbox;
                                if (curdir == RIGHTTOLEFT)
                                    curh = curh + leaderwd;
                                outerdoingleaders = doingleaders;
                                doingleaders = true;
                                if (mem[leaderbox].hh.b0 == VLISTNODE)
                                    pdfvlistout();
                                else
                                    pdfhlistout();
                                doingleaders = outerdoingleaders;
                                curv = baseline;
                                curh = saveh + leaderwd + lx;
                            }
                            if (curdir == RIGHTTOLEFT)
                                curh = edge;
                            else
                                curh = edge - 10;
                            goto labpdfhlistout15next_p;
                        }
                    }
                    goto labpdfhlistout13move_past;
                }
                break;
            case MARGINKERNNODE:
            case KERNNODE:
                curh = curh + mem[p + WIDTHOFFSET].cint;
                break;
            case MATHNODE:
                /* comment:Handle a math node in |hlist_out| */ {

                    if ((eTeXmode == 1)) /* comment:Adjust \(t)the LR stack for
                                            the |hlist_out| routin */
                    {
                        if (odd(mem[p].hh.b1)) {

                            if (mem[LRptr].hh.v.LH ==
                                (LCODE * (mem[p].hh.b1 / LCODE) /* @d7975@ */
                                 + 3)) {
                                tempptr = LRptr;
                                LRptr = mem[tempptr].hh.v.RH;
                                {
                                    mem[tempptr].hh.v.RH = avail;
                                    avail = tempptr;
                                    mem[tempptr].hh.me = 0;
                                    ;
#ifdef STAT
                                    decr(dynused);
#endif /* STAT */
                                }
                            } else {

                                if (mem[p].hh.b1 > LCODE)
                                    incr(LRproblems);
                            }
                        } else {

                            {
                                tempptr = getavail();
                                mem[tempptr].hh.v.LH =
                                    (LCODE *
                                         (mem[p].hh.b1 / LCODE) /* @d7979@ */
                                     + 3);
                                mem[tempptr].hh.v.RH = LRptr;
                                LRptr = tempptr;
                            }
                            if ((mem[p].hh.b1 / RCODE) !=
                                curdir) /* comment:Reverse an hlist segment and
                                           |goto reswitch| */
                            {
                                saveh = curh;
                                tempptr = mem[p].hh.v.RH;
                                rulewd = mem[p + WIDTHOFFSET].cint;
                                freenode(p, SMALLNODESIZE);
                                curdir = 1 - curdir;
                                p = newedge(curdir, rulewd);
                                mem[prevp].hh.v.RH = p;
                                curh = curh - leftedge + rulewd;
                                mem[p].hh.v.RH =
                                    reverse(thisbox, newedge(1 - curdir, 0),
                                            curg, curglue);
                                mem[p + DEPTHOFFSET].cint = curh;
                                curdir = 1 - curdir;
                                curh = saveh;
                                goto labpdfhlistout21reswitch;
                            }
                        }
                        mem[p].hh.b0 = KERNNODE;
                    }
                    curh = curh + mem[p + WIDTHOFFSET].cint;
                }
                break;
            case LIGATURENODE:
                /* comment:Make node |p| look like a |char_node| and |goto re */
                {

                    mem[memtop - 12] = mem[p + 1];
                    mem[memtop - 12].hh.v.RH = mem[p].hh.v.RH;
                    mem[memtop - 12].hh.me = mem[p].hh.me;
                    p = memtop - 12;
                    goto labpdfhlistout21reswitch;
                }
                break;
            /* comment:Cases of |hlist_out| that arise in mixed direction */
            case EDGENODE: {
                curh = curh + mem[p + WIDTHOFFSET].cint;
                leftedge = curh + mem[p + DEPTHOFFSET].cint;
                curdir = mem[p].hh.b1;
            } break;
            default:;
                break;
            }
            goto labpdfhlistout15next_p;
        labpdfhlistout14fin_rule
            : /* comment:(\pdfTeX) Output a rule in an hlist */
            if ((ruleht == -1073741824L))
                ruleht = mem[thisbox + HEIGHTOFFSET].cint;
            if ((ruledp == -1073741824L))
                ruledp = mem[thisbox + DEPTHOFFSET].cint;
            ruleht = ruleht + ruledp;
            if ((ruleht > 0) && (rulewd > 0)) {
                curv = baseline + ruledp;
                pdfsetrule(curh, curv, rulewd, ruleht);
                curv = baseline;
            }
        labpdfhlistout13move_past:
            curh = curh + rulewd;
        labpdfhlistout15next_p:
            prevp = p;
            p = mem[p].hh.v.RH;
        }
    /* comment:Finish |hlist_out| for mixed direction typesetting */
    if ((eTeXmode == 1)) {
        /* comment:Check for LR anomalies at the end of |hlist_out| */ {

            while (mem[LRptr].hh.v.LH != BEFORE) {

                if (mem[LRptr].hh.v.LH > LCODE)
                    LRproblems = LRproblems + 10000;
                {
                    tempptr = LRptr;
                    LRptr = mem[tempptr].hh.v.RH;
                    {
                        mem[tempptr].hh.v.RH = avail;
                        avail = tempptr;
                        mem[tempptr].hh.me = 0;
                        ;
#ifdef STAT
                        decr(dynused);
#endif /* STAT */
                    }
                }
            }
            {
                tempptr = LRptr;
                LRptr = mem[tempptr].hh.v.RH;
                {
                    mem[tempptr].hh.v.RH = avail;
                    avail = tempptr;
                    mem[tempptr].hh.me = 0;
                    ;
#ifdef STAT
                    decr(dynused);
#endif /* STAT */
                }
            }
        }
        if ((mem[thisbox].hh.b1) == DLIST)
            curdir = RIGHTTOLEFT;
    }
    decr(curs);
}
void pdfvlistout(void) {
    pdfvlistout_regmem scaled leftedge;
    scaled topedge;
    scaled savev;
    halfword thisbox;
    glueord gorder;
    unsigned char gsign;
    halfword p;
    halfword leaderbox;
    scaled leaderht;
    scaled lx;
    boolean outerdoingleaders;
    scaled edge;
    real gluetemp;
    real curglue;
    scaled curg;
    curg = 0;
    curglue = 0.0;
    thisbox = tempptr;
    gorder = mem[thisbox + LISTOFFSET].hh.b1;
    gsign = mem[thisbox + LISTOFFSET].hh.b0;
    p = mem[thisbox + LISTOFFSET].hh.v.RH;
    incr(curs);
    leftedge = curh;
    curv = curv - mem[thisbox + HEIGHTOFFSET].cint;
    topedge = curv;
    /* comment:Create thread for the current vbox if needed */
    if ((lastthread != TEXNULL) && (pdfthreaddp == -1073741824L) &&
        (pdfthreadlevel == curs))
        appendthread(thisbox, leftedge,
                     topedge + mem[thisbox + HEIGHTOFFSET].cint);
    while (p != TEXNULL) /* comment:Output node |p| for |pdf_vlist_out| and
                                 move to th */
    {

        if ((p >= himemmin))
            confusion(/* str 'pdfvlistout' */ 1139);
        else /* comment:Output the non-|char_node| |p| for |pdf_vlist_out| */ {

            switch (mem[p].hh.b0) {
            case HLISTNODE:
            case VLISTNODE:
                /* comment:(\pdfTeX) Output a box in a vlist */
                if (mem[p + LISTOFFSET].hh.v.RH == TEXNULL)
                    curv = curv + mem[p + HEIGHTOFFSET].cint +
                           mem[p + DEPTHOFFSET].cint;
                else {

                    curv = curv + mem[p + HEIGHTOFFSET].cint;
                    savev = curv;
                    if (curdir == RIGHTTOLEFT)
                        curh = leftedge - mem[p + 4].cint;
                    else
                        curh = leftedge + mem[p + 4].cint;
                    tempptr = p;
                    if (mem[p].hh.b0 == VLISTNODE)
                        pdfvlistout();
                    else
                        pdfhlistout();
                    curv = savev + mem[p + DEPTHOFFSET].cint;
                    curh = leftedge;
                }
                break;
            case RULENODE: {
                ruleht = mem[p + HEIGHTOFFSET].cint;
                ruledp = mem[p + DEPTHOFFSET].cint;
                rulewd = mem[p + WIDTHOFFSET].cint;
                goto labpdfvlistout14fin_rule;
            } break;
            case WHATSITNODE:
                /* comment:Output the whatsit node |p| in |pdf_vlist_out| */
                switch (mem[p].hh.b1) {
                case PDFTEXFIRSTEXTENSIONCODE:
                    pdfoutliteral(p);
                    break;
                case PDFTEXFIRSTEXTENSIONCODE + 32:
                    pdfoutcolorstack(p);
                    break;
                case PDFTEXFIRSTEXTENSIONCODE + 33:
                    pdfoutsetmatrix(p);
                    break;
                case PDFTEXFIRSTEXTENSIONCODE + 34:
                    pdfoutsave(p);
                    break;
                case PDFTEXFIRSTEXTENSIONCODE + 35:
                    pdfoutrestore(p);
                    break;
                case PDFTEXFIRSTEXTENSIONCODE + 2: {
                    pdfappendlistarg = mem[p + 1].hh.v.LH;
                    pdfobjlist = appendptr(pdfobjlist, pdfappendlistarg);
                } break;
                case PDFTEXFIRSTEXTENSIONCODE + 4:
                    /* comment:Output a Form node in a vlist */ {

                        curv = curv + mem[p + 2].cint;
                        savev = curv;
                        curh = leftedge;
                        outform(p);
                        curv = savev + mem[p + 3].cint;
                        curh = leftedge;
                    }
                    break;
                case PDFTEXFIRSTEXTENSIONCODE + 6:
                    /* comment:Output a Image node in a vlist */ {

                        curv = curv + mem[p + 2].cint + mem[p + 3].cint;
                        savev = curv;
                        curh = leftedge;
                        outimage(p);
                        curv = savev;
                        curh = leftedge;
                    }
                    break;
                case PDFTEXFIRSTEXTENSIONCODE + 7:
                    doannot(p, thisbox, leftedge,
                            topedge + mem[thisbox + HEIGHTOFFSET].cint);
                    break;
                case PDFTEXFIRSTEXTENSIONCODE + 8:
                    pdferror(/* str 'ext4' */ 1857,
                             /* str '\pdfstartlink ended up in vlist' */ 1964);
                    break;
                case PDFTEXFIRSTEXTENSIONCODE + 9:
                    pdferror(/* str 'ext4' */ 1857,
                             /* str '\pdfendlink ended up in vlist' */ 1965);
                    break;
                case PDFTEXFIRSTEXTENSIONCODE + 11:
                    dodest(p, thisbox, leftedge,
                           topedge + mem[thisbox + HEIGHTOFFSET].cint);
                    break;
                case PDFTEXFIRSTEXTENSIONCODE + 12:
                case PDFTEXFIRSTEXTENSIONCODE + 13:
                    dothread(p, thisbox, leftedge,
                             topedge + mem[thisbox + HEIGHTOFFSET].cint);
                    break;
                case PDFTEXFIRSTEXTENSIONCODE + 14:
                    endthread();
                    break;
                case PDFTEXFIRSTEXTENSIONCODE + 15:
                    /* comment:Save current position to |pdf_last_x_pos|,
                     * |pdf_la */
                    {

                        pdflastxpos = curh;
                        if (isshippingpage)
                            pdflastypos = curpageheight - curv;
                        else
                            pdflastypos = pdfxformheight + pdfxformdepth - curv;
                    }
                    break;
                case SPECIALNODE:
                    pdfspecial(p);
                    break;
                case PDFTEXFIRSTEXTENSIONCODE + 28:
                    /* comment:Save current position to |pdf_snapx_refpos|,
                     * |pdf_ */
                    {

                        pdfsnapxrefpos = curh;
                        pdfsnapyrefpos = curv;
                    }
                    break;
                case PDFTEXFIRSTEXTENSIONCODE + 30:
                    dosnapycomp(p, thisbox);
                    break;
                case PDFTEXFIRSTEXTENSIONCODE + 29:
                    dosnapy(p);
                    break;
                case PDFTEXFIRSTEXTENSIONCODE + 37:
                    genfakedinterwordspace = true;
                    break;
                case PDFTEXFIRSTEXTENSIONCODE + 38:
                    genfakedinterwordspace = false;
                    break;
                case PDFTEXFIRSTEXTENSIONCODE + 39:
                    pdfinsertfakespace();
                    break;
                default:
                    outwhat(p);
                    break;
                }
                break;
            case GLUENODE:
                /* comment:(\pdfTeX) Move down or output leaders */ {

                    g = mem[p + 1].hh.v.LH;
                    ruleht = mem[g + WIDTHOFFSET].cint - curg;
                    if (gsign != NORMAL) {
                        if (gsign == STRETCHING) {
                            if (mem[g].hh.b0 == gorder) {
                                curglue = curglue + mem[g + 2].cint;
                                gluetemp =
                                    mem[thisbox + GLUEOFFSET].gr * curglue;
                                if (gluetemp > 1000000000.0)
                                    gluetemp = 1000000000.0;
                                else if (gluetemp < -1000000000.0)
                                    gluetemp = -1000000000.0;
                                curg = round(gluetemp);
                            }
                        } else if (mem[g].hh.b1 == gorder) {
                            curglue = curglue - mem[g + 3].cint;
                            gluetemp = mem[thisbox + GLUEOFFSET].gr * curglue;
                            if (gluetemp > 1000000000.0)
                                gluetemp = 1000000000.0;
                            else if (gluetemp < -1000000000.0)
                                gluetemp = -1000000000.0;
                            curg = round(gluetemp);
                        }
                    }
                    ruleht = ruleht + curg;
                    if (mem[p].hh.b1 >=
                        ALEADERS) /* comment:(\pdfTeX) Output leaders
                                              in a vlist, |goto fin_rul */
                    {
                        leaderbox = mem[p + 1].hh.v.RH;
                        if (mem[leaderbox].hh.b0 == RULENODE) {
                            rulewd = mem[leaderbox + WIDTHOFFSET].cint;
                            ruledp = 0;
                            goto labpdfvlistout14fin_rule;
                        }
                        leaderht = mem[leaderbox + HEIGHTOFFSET].cint +
                                   mem[leaderbox + DEPTHOFFSET].cint;
                        if ((leaderht > 0) && (ruleht > 0)) {
                            ruleht = ruleht + 10;
                            edge = curv + ruleht;
                            lx = 0;
                            /* comment:Let |cur_v| be the position of the first
                             * box, and  */
                            if (mem[p].hh.b1 == ALEADERS) {
                                savev = curv;
                                curv = topedge +
                                       leaderht * ((curv - topedge) / leaderht);
                                if (curv < savev)
                                    curv = curv + leaderht;
                            } else {

                                lq = ruleht / leaderht;
                                lr = ruleht % leaderht;
                                if (mem[p].hh.b1 == CLEADERS)
                                    curv = curv + (lr / 2);
                                else {

                                    lx = lr / (lq + 1);
                                    curv = curv + ((lr - (lq - 1) * lx) / 2);
                                }
                            }
                            while (curv + leaderht <=
                                   edge) /* comment:(\pdfTeX) Output a leader
                                            box at |cur_v|, then adv */
                            {

                                if (curdir == RIGHTTOLEFT)
                                    curh = leftedge - mem[leaderbox + 4].cint;
                                else
                                    curh = leftedge + mem[leaderbox + 4].cint;
                                curv =
                                    curv + mem[leaderbox + HEIGHTOFFSET].cint;
                                savev = curv;
                                tempptr = leaderbox;
                                outerdoingleaders = doingleaders;
                                doingleaders = true;
                                if (mem[leaderbox].hh.b0 == VLISTNODE)
                                    pdfvlistout();
                                else
                                    pdfhlistout();
                                doingleaders = outerdoingleaders;
                                curh = leftedge;
                                curv = savev -
                                       mem[leaderbox + HEIGHTOFFSET].cint +
                                       leaderht + lx;
                            }
                            curv = edge - 10;
                            goto labpdfvlistout15next_p;
                        }
                    }
                    goto labpdfvlistout13move_past;
                }
                break;
            case KERNNODE:
                curv = curv + mem[p + WIDTHOFFSET].cint;
                break;
            default:;
                break;
            }
            goto labpdfvlistout15next_p;
        labpdfvlistout14fin_rule
            : /* comment:(\pdfTeX) Output a rule in a vlist, |goto next_p|
               */
            if ((rulewd == -1073741824L))
                rulewd = mem[thisbox + WIDTHOFFSET].cint;
            ruleht = ruleht + ruledp;
            curv = curv + ruleht;
            if ((ruleht > 0) && (rulewd > 0)) {
                if (curdir == RIGHTTOLEFT)
                    curh = curh - rulewd;
                pdfsetrule(curh, curv, rulewd, ruleht);
                curh = leftedge;
            }
            goto labpdfvlistout15next_p;
        labpdfvlistout13move_past:
            curv = curv + ruleht;
        }
    labpdfvlistout15next_p:
        p = mem[p].hh.v.RH;
    }
    decr(curs);
}
void fixpdfoutput(void) {
    fixpdfoutput_regmem if (!fixedpdfoutputset) {
        fixedpdfoutput = eqtb[INTBASE + PDFOUTPUTCODE].cint;
        fixedpdfoutputset = true;
    }
    else if (fixedpdfoutput != eqtb[INTBASE + PDFOUTPUTCODE].cint) pdferror(
        /* str 'setup' */ 1011,
        /* str '\pdfoutput can only be changed before anything is' */ 1140);
    if (fixedpdfoutputset)
        fixpdfdraftmode();
}
void fixpdfdraftmode(void) {
    fixpdfdraftmode_regmem if (!fixedpdfdraftmodeset) {
        fixedpdfdraftmode = eqtb[INTBASE + PDFDRAFTMODECODE].cint;
        fixedpdfdraftmodeset = true;
    }
    else if (fixedpdfdraftmode != eqtb[INTBASE + PDFDRAFTMODECODE].cint)
        pdferror(
            /* str 'setup' */ 1011,
            /* str '\pdfdraftmode can only be changed before anything' */ 1141);
    if (fixedpdfdraftmodeset && fixedpdfdraftmode > 0) {
        fixedpdfdraftmodeset = true;
        eqtb[INTBASE + PDFCOMPRESSLEVELCODE].cint = 0;
        fixedpdfobjcompresslevel = 0;
    }
}
boolean zsubstrofstr(strnumber s, strnumber t) {
    register boolean Result;
    substrofstr_regmem poolpointer j, k, kk;
    k = strstart[t];
    while ((k < strstart[t + 1] - (strstart[s + 1] - strstart[s]))) {

        j = strstart[s];
        kk = k;
        while ((j < strstart[s + 1])) {

            if (strpool[j] != strpool[kk])
                goto labsubstrofstr22continue;
            incr(j);
            incr(kk);
        }
        Result = true;
        return Result;
    labsubstrofstr22continue:
        incr(k);
    }
    Result = false;
    return Result;
}
void zpdfshipout(halfword p, boolean shippingpage) {
    pdfshipout_regmem integer i, j, k;
    poolpointer s;
    boolean mediaboxgiven;
    halfword savefontlist;
    halfword saveobjlist;
    halfword saveximagelist;
    halfword savexformlist;
    integer saveimageprocset;
    integer savetextprocset;
    integer pdflastresources;
    if (eqtb[INTBASE + TRACINGOUTPUTCODE].cint > 0) {
        printnl(/* str '' */ 345);
        println();
        print(/* str 'Completed box being shipped out' */ 988);
    }
    if (!initpdfoutput) {
        /* comment:Initialize variables for \.{PDF} output */
        checkpdfminorversion();
        preparemag();
        fixeddecimaldigits =
            fixint(eqtb[INTBASE + PDFDECIMALDIGITSCODE].cint, 0, 4);
        minbpval =
            dividescaled(onehundredbp, tenpow[fixeddecimaldigits + 2], 0);
        if (eqtb[INTBASE + PDFPKRESOLUTIONCODE].cint == 0)
            eqtb[INTBASE + PDFPKRESOLUTIONCODE].cint = pkdpi;
        fixedpkresolution =
            fixint(eqtb[INTBASE + PDFPKRESOLUTIONCODE].cint, 72, 8000);
        pkscalefactor =
            dividescaled(72, fixedpkresolution, 5 + fixeddecimaldigits);
        if (eqtb[PDFPKMODELOC].hh.v.RH != TEXNULL) {
            kpseinitprog(
                "PDFTEX", fixedpkresolution,
                makecstring(tokenstostring(eqtb[PDFPKMODELOC].hh.v.RH)), nil);
            {
                decr(strptr);
                poolptr = strstart[strptr];
            }
        } else
            kpseinitprog("PDFTEX", fixedpkresolution, nil, nil);
        kpsesetprogramenabled(kpsepkformat, 1, kpsesrccompile);
        setjobid(eqtb[INTBASE + YEARCODE].cint, eqtb[INTBASE + MONTHCODE].cint,
                 eqtb[INTBASE + DAYCODE].cint, eqtb[INTBASE + TIMECODE].cint);
        if ((eqtb[INTBASE + PDFUNIQUERESNAMECODE].cint > 0) &&
            (pdfresnameprefix == 0))
            pdfresnameprefix = getresnameprefix();
        initpdfoutput = true;
    }
    isshippingpage = shippingpage;
    if (shippingpage) {
        if (termoffset > maxprintline - 9)
            println();
        else if ((termoffset > 0) || (fileoffset > 0))
            printchar(/* str ' ' */ 32);
        printchar(/* str '[' */ 91);
        j = 9;
        while ((eqtb[COUNTBASE + j].cint == 0) && (j > 0))
            decr(j);
        {
            register integer for_end;
            k = 0;
            for_end = j;
            if (k <= for_end)
                do {
                    printint(eqtb[COUNTBASE + k].cint);
                    if (k < j)
                        printchar(/* str '.' */ 46);
                } while (k++ < for_end);
        }
        fflush(stdout);
    }
    if (eqtb[INTBASE + TRACINGOUTPUTCODE].cint > 0) {
        if (shippingpage)
            printchar(/* str ']' */ 93);
        begindiagnostic();
        showbox(p);
        enddiagnostic(true);
    }
    /* comment:(\pdfTeX) Ship box |p| out */ /* comment:Update the values of
                                                |max_h| and |max_v|; but if t */
    if ((mem[p + HEIGHTOFFSET].cint > 1073741823L) ||
        (mem[p + DEPTHOFFSET].cint > 1073741823L) ||
        (mem[p + HEIGHTOFFSET].cint + mem[p + DEPTHOFFSET].cint +
             eqtb[DIMENBASE + VOFFSETCODE].cint >
         1073741823L) ||
        (mem[p + WIDTHOFFSET].cint + eqtb[DIMENBASE + HOFFSETCODE].cint >
         1073741823L)) {
        {
            if (interaction == ERRORSTOPMODE)
                ;
            if (filelineerrorstylep)
                printfileline();
            else
                printnl(/* str '! ' */ 264);
            print(/* str 'Huge page cannot be shipped out' */ 992);
        }
        {
            helpptr = 2;
            helpline[1] =
                /* str 'The page just created is more than 18 feet tall o' */
                993;
            helpline[0] =
                /* str 'more than 18 feet wide, so I suspect something we' */
                994;
        }
        error();
        if (eqtb[INTBASE + TRACINGOUTPUTCODE].cint <= 0) {
            begindiagnostic();
            printnl(/* str 'The following box has been deleted' */ 995);
            showbox(p);
            enddiagnostic(true);
        }
        goto labpdfshipout30done;
    }
    if (mem[p + HEIGHTOFFSET].cint + mem[p + DEPTHOFFSET].cint +
            eqtb[DIMENBASE + VOFFSETCODE].cint >
        maxv)
        maxv = mem[p + HEIGHTOFFSET].cint + mem[p + DEPTHOFFSET].cint +
               eqtb[DIMENBASE + VOFFSETCODE].cint;
    if (mem[p + WIDTHOFFSET].cint + eqtb[DIMENBASE + HOFFSETCODE].cint > maxh)
        maxh = mem[p + WIDTHOFFSET].cint + eqtb[DIMENBASE + HOFFSETCODE].cint;
    /* comment:Initialize variables as |pdf_ship_out| begins */ fixpdfoutput();
    tempptr = p;
    preparemag();
    pdflastresources = pdfnewobjnum();
    pdfpagegroupval = 0;
    /* comment:Reset resource lists */ pdffontlist = TEXNULL;
    pdfobjlist = TEXNULL;
    pdfxformlist = TEXNULL;
    pdfximagelist = TEXNULL;
    pdftextprocset = false;
    pdfimageprocset = 0;
    if (!shippingpage) {
        pdfxformwidth = mem[p + WIDTHOFFSET].cint;
        pdfxformheight = mem[p + HEIGHTOFFSET].cint;
        pdfxformdepth = mem[p + DEPTHOFFSET].cint;
        pdfbegindict(pdfcurform, 0);
        pdflaststream = pdfcurform;
        curv = mem[p + HEIGHTOFFSET].cint;
        curh = 0;
        pdforiginh = 0;
        pdforiginv = pdfxformheight + pdfxformdepth;
    } else {

        /* comment:Calculate page dimensions and margins */ curhoffset =
            eqtb[DIMENBASE + PDFHORIGINCODE].cint +
            eqtb[DIMENBASE + HOFFSETCODE].cint;
        curvoffset = eqtb[DIMENBASE + PDFVORIGINCODE].cint +
                     eqtb[DIMENBASE + VOFFSETCODE].cint;
        if (eqtb[DIMENBASE + PDFPAGEWIDTHCODE].cint != 0)
            curpagewidth = eqtb[DIMENBASE + PDFPAGEWIDTHCODE].cint;
        else
            curpagewidth = mem[p + WIDTHOFFSET].cint + 2 * curhoffset;
        if (eqtb[DIMENBASE + PDFPAGEHEIGHTCODE].cint != 0)
            curpageheight = eqtb[DIMENBASE + PDFPAGEHEIGHTCODE].cint;
        else
            curpageheight = mem[p + HEIGHTOFFSET].cint +
                            mem[p + DEPTHOFFSET].cint + 2 * curvoffset;
        pdflastpage = getobj(1, totalpages + 1, 0);
        objtab[pdflastpage].int4 = 1;
        pdfnewdict(0, 0, 0);
        pdflaststream = objptr;
        curh = curhoffset;
        curv = mem[p + HEIGHTOFFSET].cint + curvoffset;
        pdforiginh = 0;
        pdforiginv = curpageheight;
        /* comment:Reset PDF mark lists */ pdfannotlist = TEXNULL;
        pdflinklist = TEXNULL;
        pdfdestlist = TEXNULL;
        pdfbeadlist = TEXNULL;
        lastthread = TEXNULL;
    }
    if (!shippingpage) {
        /* comment:Write out Form stream header */ {

            pdfprint(/* str 'Type XObject' */ 1142);
            {
                {
                    if (pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfosgetosbuf(1);
                    else if (!pdfosmode && (1 > pdfbufsize))
                        overflow(/* str 'PDF output buffer' */ 1004,
                                 pdfopbufsize);
                    else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfflush();
                }
                {
                    pdfbuf[pdfptr] = 10;
                    incr(pdfptr);
                }
            }
        }
        {
            pdfprint(/* str 'Subtype Form' */ 1143);
            {
                {
                    if (pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfosgetosbuf(1);
                    else if (!pdfosmode && (1 > pdfbufsize))
                        overflow(/* str 'PDF output buffer' */ 1004,
                                 pdfopbufsize);
                    else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfflush();
                }
                {
                    pdfbuf[pdfptr] = 10;
                    incr(pdfptr);
                }
            }
        }
        if (pdfmem[objtab[pdfcurform].int4 + 4] != TEXNULL) {
            pdfprinttoksln(pdfmem[objtab[pdfcurform].int4 + 4]);
            {
                deletetokenref(pdfmem[objtab[pdfcurform].int4 + 4]);
                pdfmem[objtab[pdfcurform].int4 + 4] = TEXNULL;
            }
        }
        pdfprint(/* str 'BBox [' */ 1144);
        pdfprint(/* str '0 0 ' */ 1059);
        pdfprintbp(pdfxformwidth);
        {
            {
                if (pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfosgetosbuf(1);
                else if (!pdfosmode && (1 > pdfbufsize))
                    overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
                else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfflush();
            }
            {
                pdfbuf[pdfptr] = /* str ' ' */ 32;
                incr(pdfptr);
            }
        }
        pdfprintbp(pdfxformheight + pdfxformdepth);
        {
            pdfprint(/* str ']' */ 93);
            {
                {
                    if (pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfosgetosbuf(1);
                    else if (!pdfosmode && (1 > pdfbufsize))
                        overflow(/* str 'PDF output buffer' */ 1004,
                                 pdfopbufsize);
                    else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfflush();
                }
                {
                    pdfbuf[pdfptr] = 10;
                    incr(pdfptr);
                }
            }
        }
        {
            pdfprint(/* str 'FormType 1' */ 1145);
            {
                {
                    if (pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfosgetosbuf(1);
                    else if (!pdfosmode && (1 > pdfbufsize))
                        overflow(/* str 'PDF output buffer' */ 1004,
                                 pdfopbufsize);
                    else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfflush();
                }
                {
                    pdfbuf[pdfptr] = 10;
                    incr(pdfptr);
                }
            }
        }
        {
            pdfprint(/* str 'Matrix [1 0 0 1 0 0]' */ 1146);
            {
                {
                    if (pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfosgetosbuf(1);
                    else if (!pdfosmode && (1 > pdfbufsize))
                        overflow(/* str 'PDF output buffer' */ 1004,
                                 pdfopbufsize);
                    else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfflush();
                }
                {
                    pdfbuf[pdfptr] = 10;
                    incr(pdfptr);
                }
            }
        }
        pdfindirectln(/* str 'Resources' */ 1147, pdflastresources);
    }
    /* comment:Start stream of pageform contents */ pdfbeginstream();
    if (shippingpage) {
        /* comment:Adjust transformation matrix for the magnification */
        preparemag();
        if (eqtb[INTBASE + MAGCODE].cint != 1000) {
            pdfprintreal(eqtb[INTBASE + MAGCODE].cint, 3);
            pdfprint(/* str ' 0 0 ' */ 1148);
            pdfprintreal(eqtb[INTBASE + MAGCODE].cint, 3);
            {
                pdfprint(/* str ' 0 0 cm' */ 1149);
                {
                    {
                        if (pdfosmode && (1 + pdfptr > pdfbufsize))
                            pdfosgetosbuf(1);
                        else if (!pdfosmode && (1 > pdfbufsize))
                            overflow(/* str 'PDF output buffer' */ 1004,
                                     pdfopbufsize);
                        else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                            pdfflush();
                    }
                    {
                        pdfbuf[pdfptr] = 10;
                        incr(pdfptr);
                    }
                }
            }
        }
    }
    pdfshipoutbegin(shippingpage);
    if (shippingpage)
        pdfoutcolorstackstartpage();
    if (mem[p].hh.b0 == VLISTNODE)
        pdfvlistout();
    else
        pdfhlistout();
    if (shippingpage)
        incr(totalpages);
    curs = -1;
    /* comment:Finish shipping */
    /* comment:Finish stream of pageform contents */ pdfendtext();
    pdfshipoutend(shippingpage);
    pdfendstream();
    if (shippingpage) {
        /* comment:Write out page object */ pdfbegindict(pdflastpage, 1);
        {
            pdfprint(/* str 'Type Page' */ 1161);
            {
                {
                    if (pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfosgetosbuf(1);
                    else if (!pdfosmode && (1 > pdfbufsize))
                        overflow(/* str 'PDF output buffer' */ 1004,
                                 pdfopbufsize);
                    else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfflush();
                }
                {
                    pdfbuf[pdfptr] = 10;
                    incr(pdfptr);
                }
            }
        }
        pdfindirectln(/* str 'Contents' */ 1162, pdflaststream);
        pdfindirectln(/* str 'Resources' */ 1147, pdflastresources);
        mediaboxgiven = false;
        if (eqtb[PDFPAGEATTRLOC].hh.v.RH != TEXNULL) {
            s = tokenstostring(eqtb[PDFPAGEATTRLOC].hh.v.RH);
            mediaboxgiven = substrofstr(/* str 'MediaBox' */ 1163, s);
            flushstr(s);
        }
        if (!mediaboxgiven) {
            pdfprint(/* str 'MediaBox [0 0 ' */ 1164);
            pdfprintmagbp(curpagewidth);
            {
                {
                    if (pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfosgetosbuf(1);
                    else if (!pdfosmode && (1 > pdfbufsize))
                        overflow(/* str 'PDF output buffer' */ 1004,
                                 pdfopbufsize);
                    else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfflush();
                }
                {
                    pdfbuf[pdfptr] = /* str ' ' */ 32;
                    incr(pdfptr);
                }
            }
            pdfprintmagbp(curpageheight);
            {
                pdfprint(/* str ']' */ 93);
                {
                    {
                        if (pdfosmode && (1 + pdfptr > pdfbufsize))
                            pdfosgetosbuf(1);
                        else if (!pdfosmode && (1 > pdfbufsize))
                            overflow(/* str 'PDF output buffer' */ 1004,
                                     pdfopbufsize);
                        else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                            pdfflush();
                    }
                    {
                        pdfbuf[pdfptr] = 10;
                        incr(pdfptr);
                    }
                }
            }
        }
        if (eqtb[PDFPAGEATTRLOC].hh.v.RH != TEXNULL)
            pdfprinttoksln(eqtb[PDFPAGEATTRLOC].hh.v.RH);
        /* comment:Generate parent pages object */ if (totalpages % 6 == 1) {
            pdfcreateobj(2, 6);
            pdflastpages = objptr;
        }
        pdfindirectln(/* str 'Parent' */ 1166, pdflastpages);
        if (pdfpagegroupval > 0) {
            pdfprint(/* str 'Group ' */ 1165);
            pdfprintint(pdfpagegroupval);
            {
                pdfprint(/* str ' 0 R' */ 1080);
                {
                    {
                        if (pdfosmode && (1 + pdfptr > pdfbufsize))
                            pdfosgetosbuf(1);
                        else if (!pdfosmode && (1 > pdfbufsize))
                            overflow(/* str 'PDF output buffer' */ 1004,
                                     pdfopbufsize);
                        else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                            pdfflush();
                    }
                    {
                        pdfbuf[pdfptr] = 10;
                        incr(pdfptr);
                    }
                }
            }
        }
        /* comment:Generate array of annotations or beads in page */
        if ((pdfannotlist != TEXNULL) || (pdflinklist != TEXNULL)) {
            pdfprint(/* str 'Annots [ ' */ 1167);
            k = pdfannotlist;
            while (k != TEXNULL) {

                pdfprintint(mem[k].hh.v.LH);
                pdfprint(/* str ' 0 R ' */ 1151);
                k = mem[k].hh.v.RH;
            }
            k = pdflinklist;
            while (k != TEXNULL) {

                pdfprintint(mem[k].hh.v.LH);
                pdfprint(/* str ' 0 R ' */ 1151);
                k = mem[k].hh.v.RH;
            }
            {
                pdfprint(/* str ']' */ 93);
                {
                    {
                        if (pdfosmode && (1 + pdfptr > pdfbufsize))
                            pdfosgetosbuf(1);
                        else if (!pdfosmode && (1 > pdfbufsize))
                            overflow(/* str 'PDF output buffer' */ 1004,
                                     pdfopbufsize);
                        else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                            pdfflush();
                    }
                    {
                        pdfbuf[pdfptr] = 10;
                        incr(pdfptr);
                    }
                }
            }
        }
        if (pdfbeadlist != TEXNULL) {
            k = pdfbeadlist;
            pdfprint(/* str 'B [ ' */ 1168);
            while (k != TEXNULL) {

                pdfprintint(mem[k].hh.v.LH);
                pdfprint(/* str ' 0 R ' */ 1151);
                k = mem[k].hh.v.RH;
            }
            {
                pdfprint(/* str ']' */ 93);
                {
                    {
                        if (pdfosmode && (1 + pdfptr > pdfbufsize))
                            pdfosgetosbuf(1);
                        else if (!pdfosmode && (1 > pdfbufsize))
                            overflow(/* str 'PDF output buffer' */ 1004,
                                     pdfopbufsize);
                        else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                            pdfflush();
                    }
                    {
                        pdfbuf[pdfptr] = 10;
                        incr(pdfptr);
                    }
                }
            }
        }
        pdfenddict();
    }
    /* comment:Write out resource lists */
    /* comment:Write out pending raw objects */ if (pdfobjlist != TEXNULL) {
        k = pdfobjlist;
        while (k != TEXNULL) {

            if (!(objtab[mem[k].hh.v.LH].int2 > -1))
                pdfwriteobj(mem[k].hh.v.LH);
            k = mem[k].hh.v.RH;
        }
    }
    /* comment:Write out pending forms */ if (pdfxformlist != TEXNULL) {
        k = pdfxformlist;
        while (k != TEXNULL) {

            if (!(objtab[mem[k].hh.v.LH].int2 > -1)) {
                savedpdfcurform = pdfcurform;
                pdfcurform = mem[k].hh.v.LH;
                /* comment:Save resource lists */ savefontlist = pdffontlist;
                saveobjlist = pdfobjlist;
                savexformlist = pdfxformlist;
                saveximagelist = pdfximagelist;
                savetextprocset = pdftextprocset;
                saveimageprocset = pdfimageprocset;
                /* comment:Reset resource lists */ pdffontlist = TEXNULL;
                pdfobjlist = TEXNULL;
                pdfxformlist = TEXNULL;
                pdfximagelist = TEXNULL;
                pdftextprocset = false;
                pdfimageprocset = 0;
                pdfshipout(pdfmem[objtab[pdfcurform].int4 + 3], false);
                pdfcurform = savedpdfcurform;
                /* comment:Restore resource lists */ pdffontlist = savefontlist;
                pdfobjlist = saveobjlist;
                pdfxformlist = savexformlist;
                pdfximagelist = saveximagelist;
                pdftextprocset = savetextprocset;
                pdfimageprocset = saveimageprocset;
            }
            k = mem[k].hh.v.RH;
        }
    }
    /* comment:Write out pending images */ if (pdfximagelist != TEXNULL) {
        k = pdfximagelist;
        while (k != TEXNULL) {

            if (!(objtab[mem[k].hh.v.LH].int2 > -1))
                pdfwriteimage(mem[k].hh.v.LH);
            k = mem[k].hh.v.RH;
        }
    }
    if (shippingpage) {
        /* comment:Write out pending PDF marks */ pdforiginh = 0;
        pdforiginv = curpageheight;
        /* comment:Write out PDF annotations */ if (pdfannotlist != TEXNULL) {
            k = pdfannotlist;
            while (k != TEXNULL) {

                i = objtab[mem[k].hh.v.LH].int4;
                pdfbegindict(mem[k].hh.v.LH, 1);
                {
                    pdfprint(/* str 'Type Annot' */ 1173);
                    {
                        {
                            if (pdfosmode && (1 + pdfptr > pdfbufsize))
                                pdfosgetosbuf(1);
                            else if (!pdfosmode && (1 > pdfbufsize))
                                overflow(/* str 'PDF output buffer' */ 1004,
                                         pdfopbufsize);
                            else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                                pdfflush();
                        }
                        {
                            pdfbuf[pdfptr] = 10;
                            incr(pdfptr);
                        }
                    }
                }
                pdfprinttoksln(mem[i + 5].hh.v.LH);
                pdfrectangle(mem[i + 1].cint, mem[i + 2].cint, mem[i + 3].cint,
                             mem[i + 4].cint);
                pdfenddict();
                k = mem[k].hh.v.RH;
            }
        }
        /* comment:Write out PDF link annotations */ if (pdflinklist !=
                                                         TEXNULL) {
            k = pdflinklist;
            while (k != TEXNULL) {

                i = objtab[mem[k].hh.v.LH].int4;
                pdfbegindict(mem[k].hh.v.LH, 1);
                {
                    pdfprint(/* str 'Type Annot' */ 1173);
                    {
                        {
                            if (pdfosmode && (1 + pdfptr > pdfbufsize))
                                pdfosgetosbuf(1);
                            else if (!pdfosmode && (1 > pdfbufsize))
                                overflow(/* str 'PDF output buffer' */ 1004,
                                         pdfopbufsize);
                            else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                                pdfflush();
                        }
                        {
                            pdfbuf[pdfptr] = 10;
                            incr(pdfptr);
                        }
                    }
                }
                if (mem[mem[i + 5].hh.v.RH].hh.b0 != 3) {
                    pdfprint(/* str 'Subtype Link' */ 1174);
                    {
                        {
                            if (pdfosmode && (1 + pdfptr > pdfbufsize))
                                pdfosgetosbuf(1);
                            else if (!pdfosmode && (1 > pdfbufsize))
                                overflow(/* str 'PDF output buffer' */ 1004,
                                         pdfopbufsize);
                            else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                                pdfflush();
                        }
                        {
                            pdfbuf[pdfptr] = 10;
                            incr(pdfptr);
                        }
                    }
                }
                if (mem[i + 5].hh.v.LH != TEXNULL)
                    pdfprinttoksln(mem[i + 5].hh.v.LH);
                pdfrectangle(mem[i + 1].cint, mem[i + 2].cint, mem[i + 3].cint,
                             mem[i + 4].cint);
                if (mem[mem[i + 5].hh.v.RH].hh.b0 != 3)
                    pdfprint(/* str 'A ' */ 1175);
                writeaction(mem[i + 5].hh.v.RH);
                pdfenddict();
                k = mem[k].hh.v.RH;
            }
            /* comment:Flush |pdf_start_link_node|'s created by |append_l */ k =
                pdflinklist;
            while (k != TEXNULL) {

                i = objtab[mem[k].hh.v.LH].int4;
                if (mem[i].hh.v.LH == 2147483647L)
                    flushwhatsitnode(i, /* @d8301@ */ 14);
                k = mem[k].hh.v.RH;
            }
        }
        /* comment:Write out PDF mark destinations */ if (pdfdestlist !=
                                                          TEXNULL) {
            k = pdfdestlist;
            while (k != TEXNULL) {

                if ((objtab[mem[k].hh.v.LH].int2 > -1))
                    pdferror(/* str 'ext5' */ 1169,
                             /* str 'destination has been already written (this
                                should' */
                             1176);
                else {

                    i = objtab[mem[k].hh.v.LH].int4;
                    if (mem[i + 5].hh.b1 > 0) {
                        pdfbegindict(mem[k].hh.v.LH, 1);
                        pdfprint(/* str 'D ' */ 1177);
                    } else
                        pdfbeginobj(mem[k].hh.v.LH, 1);
                    {
                        {
                            if (pdfosmode && (1 + pdfptr > pdfbufsize))
                                pdfosgetosbuf(1);
                            else if (!pdfosmode && (1 > pdfbufsize))
                                overflow(/* str 'PDF output buffer' */ 1004,
                                         pdfopbufsize);
                            else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                                pdfflush();
                        }
                        {
                            pdfbuf[pdfptr] = /* str '[' */ 91;
                            incr(pdfptr);
                        }
                    }
                    pdfprintint(pdflastpage);
                    pdfprint(/* str ' 0 R ' */ 1151);
                    switch (mem[i + 5].hh.b0) {
                    case 0: {
                        pdfprint(/* str 'XYZ ' */ 1178);
                        pdfprintmagbp(((mem[i + 1].cint) - pdforiginh));
                        {
                            {
                                if (pdfosmode && (1 + pdfptr > pdfbufsize))
                                    pdfosgetosbuf(1);
                                else if (!pdfosmode && (1 > pdfbufsize))
                                    overflow(/* str 'PDF output buffer' */ 1004,
                                             pdfopbufsize);
                                else if (!pdfosmode &&
                                         (1 + pdfptr > pdfbufsize))
                                    pdfflush();
                            }
                            {
                                pdfbuf[pdfptr] = /* str ' ' */ 32;
                                incr(pdfptr);
                            }
                        }
                        pdfprintmagbp((pdforiginv - (mem[i + 2].cint)));
                        {
                            {
                                if (pdfosmode && (1 + pdfptr > pdfbufsize))
                                    pdfosgetosbuf(1);
                                else if (!pdfosmode && (1 > pdfbufsize))
                                    overflow(/* str 'PDF output buffer' */ 1004,
                                             pdfopbufsize);
                                else if (!pdfosmode &&
                                         (1 + pdfptr > pdfbufsize))
                                    pdfflush();
                            }
                            {
                                pdfbuf[pdfptr] = /* str ' ' */ 32;
                                incr(pdfptr);
                            }
                        }
                        if (mem[i + 6].hh.v.LH == TEXNULL)
                            pdfprint(/* str 'null' */ 1179);
                        else {

                            pdfprintint(mem[i + 6].hh.v.LH / 1000);
                            {
                                {
                                    if (pdfosmode && (1 + pdfptr > pdfbufsize))
                                        pdfosgetosbuf(1);
                                    else if (!pdfosmode && (1 > pdfbufsize))
                                        overflow(
                                            /* str 'PDF output buffer' */ 1004,
                                            pdfopbufsize);
                                    else if (!pdfosmode &&
                                             (1 + pdfptr > pdfbufsize))
                                        pdfflush();
                                }
                                {
                                    pdfbuf[pdfptr] = /* str '.' */ 46;
                                    incr(pdfptr);
                                }
                            }
                            pdfprintint((mem[i + 6].hh.v.LH % 1000));
                        }
                    } break;
                    case 1:
                        pdfprint(/* str 'Fit' */ 1180);
                        break;
                    case 2: {
                        pdfprint(/* str 'FitH ' */ 1181);
                        pdfprintmagbp((pdforiginv - (mem[i + 2].cint)));
                    } break;
                    case 3: {
                        pdfprint(/* str 'FitV ' */ 1182);
                        pdfprintmagbp(((mem[i + 1].cint) - pdforiginh));
                    } break;
                    case 4:
                        pdfprint(/* str 'FitB' */ 1183);
                        break;
                    case 5: {
                        pdfprint(/* str 'FitBH ' */ 1184);
                        pdfprintmagbp((pdforiginv - (mem[i + 2].cint)));
                    } break;
                    case 6: {
                        pdfprint(/* str 'FitBV ' */ 1185);
                        pdfprintmagbp(((mem[i + 1].cint) - pdforiginh));
                    } break;
                    case 7: {
                        pdfprint(/* str 'FitR ' */ 1186);
                        pdfprintrectspec(i);
                    } break;
                    default:
                        pdferror(/* str 'ext5' */ 1169,
                                 /* str 'unknown dest type' */ 1187);
                        break;
                    }
                    {
                        pdfprint(/* str ']' */ 93);
                        {
                            {
                                if (pdfosmode && (1 + pdfptr > pdfbufsize))
                                    pdfosgetosbuf(1);
                                else if (!pdfosmode && (1 > pdfbufsize))
                                    overflow(/* str 'PDF output buffer' */ 1004,
                                             pdfopbufsize);
                                else if (!pdfosmode &&
                                         (1 + pdfptr > pdfbufsize))
                                    pdfflush();
                            }
                            {
                                pdfbuf[pdfptr] = 10;
                                incr(pdfptr);
                            }
                        }
                    }
                    if (mem[i + 5].hh.b1 > 0)
                        pdfenddict();
                    else
                        pdfendobj();
                }
                k = mem[k].hh.v.RH;
            }
        }
        /* comment:Write out PDF bead rectangle specifications */
        if (pdfbeadlist != TEXNULL) {
            k = pdfbeadlist;
            while (k != TEXNULL) {

                pdfnewobj(0, 0, 1);
                {
                    {
                        if (pdfosmode && (1 + pdfptr > pdfbufsize))
                            pdfosgetosbuf(1);
                        else if (!pdfosmode && (1 > pdfbufsize))
                            overflow(/* str 'PDF output buffer' */ 1004,
                                     pdfopbufsize);
                        else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                            pdfflush();
                    }
                    {
                        pdfbuf[pdfptr] = /* str '[' */ 91;
                        incr(pdfptr);
                    }
                }
                i = pdfmem[objtab[mem[k].hh.v.LH].int4];
                pdfprintrectspec(i);
                if (mem[i].hh.v.LH == 2147483647L)
                    flushwhatsitnode(i, /* @d8331@ */ 19);
                {
                    pdfprint(/* str ']' */ 93);
                    {
                        {
                            if (pdfosmode && (1 + pdfptr > pdfbufsize))
                                pdfosgetosbuf(1);
                            else if (!pdfosmode && (1 > pdfbufsize))
                                overflow(/* str 'PDF output buffer' */ 1004,
                                         pdfopbufsize);
                            else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                                pdfflush();
                        }
                        {
                            pdfbuf[pdfptr] = 10;
                            incr(pdfptr);
                        }
                    }
                }
                pdfmem[objtab[mem[k].hh.v.LH].int4] = objptr;
                pdfendobj();
                k = mem[k].hh.v.RH;
            }
        }
    }
    /* comment:Write out resources dictionary */ pdfbegindict(pdflastresources,
                                                              1);
    /* comment:Print additional resources */ if (shippingpage) {
        if (eqtb[PDFPAGERESOURCESLOC].hh.v.RH != TEXNULL)
            pdfprinttoksln(eqtb[PDFPAGERESOURCESLOC].hh.v.RH);
    } else {

        if (pdfmem[objtab[pdfcurform].int4 + 5] != TEXNULL) {
            pdfprinttoksln(pdfmem[objtab[pdfcurform].int4 + 5]);
            {
                deletetokenref(pdfmem[objtab[pdfcurform].int4 + 5]);
                pdfmem[objtab[pdfcurform].int4 + 5] = TEXNULL;
            }
        }
    }
    /* comment:Generate font resources */ if (pdffontlist != TEXNULL) {
        pdfprint(/* str 'Font << ' */ 1150);
        k = pdffontlist;
        while (k != TEXNULL) {

            pdfprint(/* str 'F' */ 1038);
            {
                if (pdffontnum[mem[k].hh.v.LH] < 0)
                    ff = -(integer)pdffontnum[mem[k].hh.v.LH];
                else
                    ff = mem[k].hh.v.LH;
            }
            pdfprintint(ff);
            if (pdfresnameprefix != 0)
                pdfprint(pdfresnameprefix);
            {
                {
                    if (pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfosgetosbuf(1);
                    else if (!pdfosmode && (1 > pdfbufsize))
                        overflow(/* str 'PDF output buffer' */ 1004,
                                 pdfopbufsize);
                    else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfflush();
                }
                {
                    pdfbuf[pdfptr] = /* str ' ' */ 32;
                    incr(pdfptr);
                }
            }
            pdfprintint(pdffontnum[ff]);
            pdfprint(/* str ' 0 R ' */ 1151);
            k = mem[k].hh.v.RH;
        }
        {
            pdfprint(/* str '>>' */ 1018);
            {
                {
                    if (pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfosgetosbuf(1);
                    else if (!pdfosmode && (1 > pdfbufsize))
                        overflow(/* str 'PDF output buffer' */ 1004,
                                 pdfopbufsize);
                    else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfflush();
                }
                {
                    pdfbuf[pdfptr] = 10;
                    incr(pdfptr);
                }
            }
        }
        pdftextprocset = true;
    }
    /* comment:Generate XObject resources */ if ((pdfxformlist != TEXNULL) ||
                                                 (pdfximagelist != TEXNULL)) {
        pdfprint(/* str 'XObject << ' */ 1152);
        k = pdfxformlist;
        while (k != TEXNULL) {

            pdfprint(/* str 'Fm' */ 1153);
            pdfprintint(objtab[mem[k].hh.v.LH].int0);
            if (pdfresnameprefix != 0)
                pdfprint(pdfresnameprefix);
            {
                {
                    if (pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfosgetosbuf(1);
                    else if (!pdfosmode && (1 > pdfbufsize))
                        overflow(/* str 'PDF output buffer' */ 1004,
                                 pdfopbufsize);
                    else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfflush();
                }
                {
                    pdfbuf[pdfptr] = /* str ' ' */ 32;
                    incr(pdfptr);
                }
            }
            pdfprintint(mem[k].hh.v.LH);
            pdfprint(/* str ' 0 R ' */ 1151);
            k = mem[k].hh.v.RH;
        }
        k = pdfximagelist;
        while (k != TEXNULL) {

            pdfprint(/* str 'Im' */ 1154);
            pdfprintint(objtab[mem[k].hh.v.LH].int0);
            if (pdfresnameprefix != 0)
                pdfprint(pdfresnameprefix);
            {
                {
                    if (pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfosgetosbuf(1);
                    else if (!pdfosmode && (1 > pdfbufsize))
                        overflow(/* str 'PDF output buffer' */ 1004,
                                 pdfopbufsize);
                    else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfflush();
                }
                {
                    pdfbuf[pdfptr] = /* str ' ' */ 32;
                    incr(pdfptr);
                }
            }
            pdfprintint(mem[k].hh.v.LH);
            pdfprint(/* str ' 0 R ' */ 1151);
            updateimageprocset(pdfmem[objtab[mem[k].hh.v.LH].int4 + 4]);
            k = mem[k].hh.v.RH;
        }
        {
            pdfprint(/* str '>>' */ 1018);
            {
                {
                    if (pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfosgetosbuf(1);
                    else if (!pdfosmode && (1 > pdfbufsize))
                        overflow(/* str 'PDF output buffer' */ 1004,
                                 pdfopbufsize);
                    else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfflush();
                }
                {
                    pdfbuf[pdfptr] = 10;
                    incr(pdfptr);
                }
            }
        }
    }
    /* comment:Generate ProcSet */ pdfprint(/* str 'ProcSet [ PDF' */ 1155);
    if (pdftextprocset)
        pdfprint(/* str ' Text' */ 1156);
    if (checkimageb(pdfimageprocset))
        pdfprint(/* str ' ImageB' */ 1157);
    if (checkimagec(pdfimageprocset))
        pdfprint(/* str ' ImageC' */ 1158);
    if (checkimagei(pdfimageprocset))
        pdfprint(/* str ' ImageI' */ 1159);
    {
        pdfprint(/* str ' ]' */ 1160);
        {
            {
                if (pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfosgetosbuf(1);
                else if (!pdfosmode && (1 > pdfbufsize))
                    overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
                else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfflush();
            }
            {
                pdfbuf[pdfptr] = 10;
                incr(pdfptr);
            }
        }
    }
    pdfenddict();
    /* comment:Flush resource lists */ flushlist(pdffontlist);
    flushlist(pdfobjlist);
    flushlist(pdfxformlist);
    flushlist(pdfximagelist);
    if (shippingpage) {
        /* comment:Flush PDF mark lists */ flushlist(pdfannotlist);
        flushlist(pdflinklist);
        flushlist(pdfdestlist);
        flushlist(pdfbeadlist);
    }
labpdfshipout30done:;
    if ((eTeXmode ==
         1)) /* comment:Check for LR anomalies at the end of |ship_out| */
    {
        if (LRproblems > 0) {
            /* comment:Report LR problems */ {

                println();
                printnl(/* str '\endL or \endR problem (' */ 2027);
                printint(LRproblems / 10000);
                print(/* str ' missing, ' */ 2028);
                printint(LRproblems % 10000);
                print(/* str ' extra' */ 2029);
                LRproblems = 0;
            }
            printchar(/* str ')' */ 41);
            println();
        }
        if ((LRptr != TEXNULL) || (curdir != LEFTTORIGHT))
            confusion(/* str 'LR3' */ 2031);
    }
    if ((eqtb[INTBASE + TRACINGOUTPUTCODE].cint <= 0) && shippingpage)
        printchar(/* str ']' */ 93);
    deadcycles = 0;
    fflush(stdout);
    /* comment:Flush the box from memory, showing statistics if r */;
#ifdef STAT
    if (eqtb[INTBASE + TRACINGSTATSCODE].cint > 1) {
        printnl(/* str 'Memory usage before' */ 989);
        printint(varused);
        printchar(/* str '&' */ 38);
        printint(dynused);
        printchar(/* str ';' */ 59);
    }
#endif /* STAT */
    flushnodelist(p);
    ;
#ifdef STAT
    if (eqtb[INTBASE + TRACINGSTATSCODE].cint > 1) {
        print(/* str ' after' */ 990);
        printint(varused);
        printchar(/* str '&' */ 38);
        printint(dynused);
        print(/* str '; still untouched' */ 991);
        printint(himemmin - lomemmax - 1);
        println();
    }
#endif /* STAT */
}
void zshipout(halfword p) {
    shipout_regmem fixpdfoutput();
    if (eqtb[INTBASE + PDFOUTPUTCODE].cint > 0)
    {
        
        pdfshipout(p, true);
    }
    else
        dvishipout(p);
}
boolean zstrlessstr(strnumber s1, strnumber s2) {
    register boolean Result;
    strlessstr_regmem poolpointer j1, j2, e1, e2;
    packedASCIIcode c1, c2;
    j1 = strstart[s1];
    j2 = strstart[s2];
    e1 = j1 + (strstart[s1 + 1] - strstart[s1]);
    e2 = j2 + (strstart[s2 + 1] - strstart[s2]);
    while ((j1 < e1) && (j2 < e2)) {

        c1 = strpool[j1];
        incr(j1);
        if ((c1 == 92) && (j1 < e1)) {
            c1 = strpool[j1];
            incr(j1);
            if ((c1 >= 48) && (c1 <= 55)) {
                c1 = c1 - 48;
                if ((j1 < e1) && (strpool[j1] >= 48) && (strpool[j1] <= 55)) {
                    c1 = 8 * c1 + strpool[j1] - 48;
                    incr(j1);
                    if ((j1 < e1) && (strpool[j1] >= 48) &&
                        (strpool[j1] <= 55) && (c1 < 32)) {
                        c1 = 8 * c1 + strpool[j1] - 48;
                        incr(j1);
                    }
                }
            } else {

                switch (c1) {
                case 98:
                    c1 = 8;
                    break;
                case 102:
                    c1 = 12;
                    break;
                case 110:
                    c1 = 10;
                    break;
                case 114:
                    c1 = 13;
                    break;
                case 116:
                    c1 = 9;
                    break;
                default:;
                    break;
                }
            }
        }
        c2 = strpool[j2];
        incr(j2);
        if ((c2 == 92) && (j2 < e2)) {
            c2 = strpool[j2];
            incr(j2);
            if ((c2 >= 48) && (c2 <= 55)) {
                c2 = c2 - 48;
                if ((j2 < e2) && (strpool[j2] >= 48) && (strpool[j2] <= 55)) {
                    c2 = 8 * c2 + strpool[j2] - 48;
                    incr(j2);
                    if ((j2 < e2) && (strpool[j2] >= 48) &&
                        (strpool[j2] <= 55) && (c2 < 32)) {
                        c2 = 8 * c2 + strpool[j2] - 48;
                        incr(j2);
                    }
                }
            } else {

                switch (c2) {
                case 98:
                    c2 = 8;
                    break;
                case 102:
                    c2 = 12;
                    break;
                case 110:
                    c2 = 10;
                    break;
                case 114:
                    c2 = 13;
                    break;
                case 116:
                    c2 = 9;
                    break;
                default:;
                    break;
                }
            }
        }
        if (c1 < c2) {
            Result = true;
            return Result;
        } else if (c1 > c2) {
            Result = false;
            return Result;
        }
    }
    if ((j1 >= e1) && (j2 < e2))
        Result = true;
    else
        Result = false;
    return Result;
}
void zsortdestnames(integer l, integer r) {
    sortdestnames_regmem integer i, j;
    strnumber s;
    destnameentry e;
    i = l;
    j = r;
    s = destnames[(l + r) / 2].objname;
    do {
        while (strlessstr(destnames[i].objname, s))
            incr(i);
        while (strlessstr(s, destnames[j].objname))
            decr(j);
        if (i <= j) {
            e = destnames[i];
            destnames[i] = destnames[j];
            destnames[j] = e;
            incr(i);
            decr(j);
        }
    } while (!(i > j));
    if (l < j)
        sortdestnames(l, j);
    if (i < r)
        sortdestnames(i, r);
}
void zpdffixdest(integer k) {
    pdffixdest_regmem if (objtab[k].int4 != TEXNULL) return;
    pdfwarning(/* str 'dest' */ 1196, /* str '' */ 345, false, false);
    if (objtab[k].int0 < 0) {
        print(/* str 'name{' */ 1197);
        print(-(integer)objtab[k].int0);
        print(/* str '}' */ 125);
    } else {

        print(/* str 'num' */ 1198);
        printint(objtab[k].int0);
    }
    print(/* str ' has been referenced but does not exist, replaced' */ 1199);
    println();
    println();
    pdfbeginobj(k, 1);
    {
        {
            if (pdfosmode && (1 + pdfptr > pdfbufsize))
                pdfosgetosbuf(1);
            else if (!pdfosmode && (1 > pdfbufsize))
                overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
            else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                pdfflush();
        }
        {
            pdfbuf[pdfptr] = /* str '[' */ 91;
            incr(pdfptr);
        }
    }
    pdfprintint(headtab[1]);
    {
        pdfprint(/* str ' 0 R Fit]' */ 1200);
        {
            {
                if (pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfosgetosbuf(1);
                else if (!pdfosmode && (1 > pdfbufsize))
                    overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
                else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfflush();
            }
            {
                pdfbuf[pdfptr] = 10;
                incr(pdfptr);
            }
        }
    }
    pdfendobj();
}
void pdfprintinfo(void) {
    pdfprintinfo_regmem strnumber s;
    boolean creatorgiven, producergiven, creationdategiven, moddategiven,
        trappedgiven;
    pdfnewdict(0, 0, 3);
    creatorgiven = false;
    producergiven = false;
    creationdategiven = false;
    moddategiven = false;
    trappedgiven = false;
    if (pdfinfotoks != TEXNULL) {
        s = tokenstostring(pdfinfotoks);
        creatorgiven = substrofstr(/* str 'Creator' */ 1218, s);
        producergiven = substrofstr(/* str 'Producer' */ 1219, s);
        creationdategiven = substrofstr(/* str 'CreationDate' */ 1220, s);
        moddategiven = substrofstr(/* str 'ModDate' */ 1221, s);
        trappedgiven = substrofstr(/* str 'Trapped' */ 1222, s);
    }
    if (!producergiven) {
        /* comment:Print the Producer key */ pdfprint(
            /* str 'Producer (pdfTeX-' */ 1227);
        pdfprintint(140 / 100);
        {
            {
                if (pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfosgetosbuf(1);
                else if (!pdfosmode && (1 > pdfbufsize))
                    overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
                else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfflush();
            }
            {
                pdfbuf[pdfptr] = /* str '.' */ 46;
                incr(pdfptr);
            }
        }
        pdfprintint(140 % 100);
        {
            {
                if (pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfosgetosbuf(1);
                else if (!pdfosmode && (1 > pdfbufsize))
                    overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
                else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfflush();
            }
            {
                pdfbuf[pdfptr] = /* str '.' */ 46;
                incr(pdfptr);
            }
        }
        pdfprint(/* str '20' */ 257);
        {
            pdfprint(/* str ')' */ 41);
            {
                {
                    if (pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfosgetosbuf(1);
                    else if (!pdfosmode && (1 > pdfbufsize))
                        overflow(/* str 'PDF output buffer' */ 1004,
                                 pdfopbufsize);
                    else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfflush();
                }
                {
                    pdfbuf[pdfptr] = 10;
                    incr(pdfptr);
                }
            }
        }
    }
    if (pdfinfotoks != TEXNULL) {
        if ((strstart[s + 1] - strstart[s]) > 0) {
            {
                pdfprint(s);
                {
                    {
                        if (pdfosmode && (1 + pdfptr > pdfbufsize))
                            pdfosgetosbuf(1);
                        else if (!pdfosmode && (1 > pdfbufsize))
                            overflow(/* str 'PDF output buffer' */ 1004,
                                     pdfopbufsize);
                        else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                            pdfflush();
                    }
                    {
                        pdfbuf[pdfptr] = 10;
                        incr(pdfptr);
                    }
                }
            }
        }
        flushstr(s);
        {
            deletetokenref(pdfinfotoks);
            pdfinfotoks = TEXNULL;
        }
    }
    if (!creatorgiven)
        pdfstrentryln(/* str 'Creator' */ 1223, /* str 'TeX' */ 1224);
    if (eqtb[INTBASE + PDFINFOOMITDATECODE].cint == 0) {
        if (!creationdategiven) {
            /* comment:Print the CreationDate key */ printcreationdate();
        }
        if (!moddategiven) {
            /* comment:Print the ModDate key */ printmoddate();
        }
    }
    if (!trappedgiven) {
        {
            pdfprint(/* str 'Trapped False' */ 1225);
            {
                {
                    if (pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfosgetosbuf(1);
                    else if (!pdfosmode && (1 > pdfbufsize))
                        overflow(/* str 'PDF output buffer' */ 1004,
                                 pdfopbufsize);
                    else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfflush();
                }
                {
                    pdfbuf[pdfptr] = 10;
                    incr(pdfptr);
                }
            }
        }
    }
    if (eqtb[INTBASE + PDFSUPPRESSPTEXINFOCODE].cint % 2 == 0) {
        pdfstrentryln(/* str 'PTEX.Fullbanner' */ 1226, pdftexbanner);
    }
    pdfenddict();
}
void zscanspec(groupcode c, boolean threecodes) {
    scanspec_regmem integer s;
    unsigned char speccode;
    if (threecodes)
        s = savestack[saveptr + 0].cint;
    if (scankeyword(/* str 'to' */ 1245))
        speccode = EXACTLY;
    else if (scankeyword(/* str 'spread' */ 1246))
        speccode = ADDITIONAL;
    else {

        speccode = ADDITIONAL;
        curval = 0;
        goto labscanspec40found;
    }
    scandimen(false, false, false);
labscanspec40found:
    if (threecodes) {
        savestack[saveptr + 0].cint = s;
        incr(saveptr);
    }
    savestack[saveptr + 0].cint = speccode;
    savestack[saveptr + 1].cint = curval;
    saveptr = saveptr + 2;
    newsavelevel(c);
    scanleftbrace();
}
boolean zcheckexpandpars(internalfontnumber f) {
    register boolean Result;
    checkexpandpars_regmem internalfontnumber k;
    Result = false;
    if ((pdffontstep[f] == 0) ||
        ((pdffontstretch[f] == FONTBASE) && (pdffontshrink[f] == FONTBASE)))
        return Result;
    if (curfontstep < 0)
        curfontstep = pdffontstep[f];
    else if (curfontstep != pdffontstep[f])
        pdferror(
            /* str 'font expansion' */ 1036,
            /* str 'using fonts with different step of expansion in o' */ 1247);
    k = pdffontstretch[f];
    if (k != FONTBASE) {
        if (maxstretchratio < 0)
            maxstretchratio = pdffontexpandratio[k];
        else if (maxstretchratio != pdffontexpandratio[k])
            pdferror(
                /* str 'font expansion' */ 1036,
                /* str 'using fonts with different limit of expansion in ' */
                1248);
    }
    k = pdffontshrink[f];
    if (k != FONTBASE) {
        if (maxshrinkratio < 0)
            maxshrinkratio = -(integer)pdffontexpandratio[k];
        else if (maxshrinkratio != -(integer)pdffontexpandratio[k])
            pdferror(
                /* str 'font expansion' */ 1036,
                /* str 'using fonts with different limit of expansion in ' */
                1248);
    }
    Result = true;
    return Result;
}
scaled zcharstretch(internalfontnumber f, eightbits c) {
    register scaled Result;
    charstretch_regmem internalfontnumber k;
    scaled dw;
    integer ef;
    Result = 0;
    k = pdffontstretch[f];
    ef = getefcode(f, c);
    if ((k != FONTBASE) && (ef > 0)) {
        dw = fontinfo[widthbase[k] +
                      fontinfo[charbase[k] + effectivechar(true, k, c)].qqqq.b0]
                 .cint -
             fontinfo[widthbase[f] +
                      fontinfo[charbase[f] + effectivechar(true, f, c)].qqqq.b0]
                 .cint;
        if (dw > 0)
            Result = roundxnoverd(dw, ef, 1000);
    }
    return Result;
}
scaled zcharshrink(internalfontnumber f, eightbits c) {
    register scaled Result;
    charshrink_regmem internalfontnumber k;
    scaled dw;
    integer ef;
    Result = 0;
    k = pdffontshrink[f];
    ef = getefcode(f, c);
    if ((k != FONTBASE) && (ef > 0)) {
        dw = fontinfo[widthbase[f] +
                      fontinfo[charbase[f] + effectivechar(true, f, c)].qqqq.b0]
                 .cint -
             fontinfo[widthbase[k] +
                      fontinfo[charbase[k] + effectivechar(true, k, c)].qqqq.b0]
                 .cint;
        if (dw > 0)
            Result = roundxnoverd(dw, ef, 1000);
    }
    return Result;
}
scaled zgetkern(internalfontnumber f, eightbits lc, eightbits rc) {
    register scaled Result;
    getkern_regmem fourquarters i;
    fourquarters j;
    fontindex k;
    Result = 0;
    i = fontinfo[charbase[f] + effectivechar(true, f, lc)].qqqq;
    if (((i.b2) % 4) != LIGTAG)
        return Result;
    k = ligkernbase[f] + i.b3;
    j = fontinfo[k].qqqq;
    if (j.b0 <= 128)
        goto labgetkern23continue;
    k = ligkernbase[f] + 256 * j.b2 + j.b3 + 32768L - 256 * (/* @d8460@ */ 128);
labgetkern22continue:
    j = fontinfo[k].qqqq;
labgetkern23continue:
    if ((j.b1 == rc) && (j.b0 <= 128) && (j.b2 >= 128)) {
        Result = fontinfo[kernbase[f] + 256 * j.b2 + j.b3].cint;
        return Result;
    }
    if (j.b0 == 0)
        incr(k);
    else {

        if (j.b0 >= 128)
            return Result;
        k = k + j.b0 + 1;
    }
    goto labgetkern22continue;
    return Result;
}
scaled zkernstretch(halfword p) {
    register scaled Result;
    kernstretch_regmem halfword l, r;
    scaled d;
    Result = 0;
    if ((prevcharp == TEXNULL) || (mem[prevcharp].hh.v.RH != p) ||
        (mem[p].hh.v.RH == TEXNULL))
        return Result;
    l = prevcharp;
    r = mem[p].hh.v.RH;
    if (!(l >= himemmin)) {

        if (mem[l].hh.b0 == LIGATURENODE)
            l = l + 1;
        else /* @d8468@ */
            return Result;
    }
    if (!(r >= himemmin)) {

        if (mem[r].hh.b0 == LIGATURENODE)
            r = r + 1;
        else /* @d8470@ */
            return Result;
    }
    if (!((mem[l].hh.b0 == mem[r].hh.b0) &&
          (pdffontstretch[mem[l].hh.b0] != FONTBASE)))
        return Result;
    d = getkern(pdffontstretch[mem[l].hh.b0], mem[l].hh.b1, mem[r].hh.b1);
    Result = roundxnoverd(d - mem[p + WIDTHOFFSET].cint,
                          getefcode(mem[l].hh.b0, mem[l].hh.b1), 1000);
    return Result;
}
scaled zkernshrink(halfword p) {
    register scaled Result;
    kernshrink_regmem halfword l, r;
    scaled d;
    Result = 0;
    if ((prevcharp == TEXNULL) || (mem[prevcharp].hh.v.RH != p) ||
        (mem[p].hh.v.RH == TEXNULL))
        return Result;
    l = prevcharp;
    r = mem[p].hh.v.RH;
    if (!(l >= himemmin)) {

        if (mem[l].hh.b0 == LIGATURENODE)
            l = l + 1;
        else /* @d8476@ */
            return Result;
    }
    if (!(r >= himemmin)) {

        if (mem[r].hh.b0 == LIGATURENODE)
            r = r + 1;
        else /* @d8478@ */
            return Result;
    }
    if (!((mem[l].hh.b0 == mem[r].hh.b0) &&
          (pdffontshrink[mem[l].hh.b0] != FONTBASE)))
        return Result;
    d = getkern(pdffontshrink[mem[l].hh.b0], mem[l].hh.b1, mem[r].hh.b1);
    Result = roundxnoverd(mem[p + WIDTHOFFSET].cint - d,
                          getefcode(mem[l].hh.b0, mem[l].hh.b1), 1000);
    return Result;
}
void zdosubstfont(halfword p, integer exratio) {
    dosubstfont_regmem internalfontnumber f, k;
    halfword r;
    integer ef;
    if (!(p >= himemmin) && (mem[p].hh.b0 == DISCNODE)) {
        r = mem[p + 1].hh.v.LH;
        while (r != TEXNULL) {

            if ((r >= himemmin) || (mem[r].hh.b0 == LIGATURENODE))
                dosubstfont(r, exratio);
            r = mem[r].hh.v.RH;
        }
        r = mem[p + 1].hh.v.RH;
        while (r != TEXNULL) {

            if ((r >= himemmin) || (mem[r].hh.b0 == LIGATURENODE))
                dosubstfont(r, exratio);
            r = mem[r].hh.v.RH;
        }
        return;
    }
    if ((p >= himemmin))
        r = p;
    else if (mem[p].hh.b0 == LIGATURENODE)
        r = p + 1;
    else {

        pdferror(/* str 'font expansion' */ 1036,
                 /* str 'invalid node type' */ 1249);
    }
    f = mem[r].hh.b0;
    ef = getefcode(f, mem[r].hh.b1);
    if (ef == 0)
        return;
    if ((pdffontstretch[f] != FONTBASE) && (exratio > 0))
        k = expandfont(f, extxnoverd(exratio * ef,
                                     pdffontexpandratio[pdffontstretch[f]],
                                     1000000L));
    else if ((pdffontshrink[f] != FONTBASE) && (exratio < 0))
        k = expandfont(
            f, extxnoverd(exratio * ef,
                          -(integer)pdffontexpandratio[pdffontshrink[f]],
                          1000000L));
    else
        k = f;
    if (k != f) {
        mem[r].hh.b0 = k;
        if (!(p >= himemmin)) {
            r = mem[p + 1].hh.v.RH;
            while (r != TEXNULL) {

                mem[r].hh.b0 = k;
                r = mem[r].hh.v.RH;
            }
        }
    }
}
scaled zcharpw(halfword p, smallnumber side) {
    register scaled Result;
    charpw_regmem internalfontnumber f;
    integer c;
    Result = 0;
    if (side == 0)
        lastleftmostchar = TEXNULL;
    else
        lastrightmostchar = TEXNULL;
    if (p == TEXNULL)
        return Result;
    if (!(p >= himemmin)) {
        if (mem[p].hh.b0 == LIGATURENODE)
            p = p + 1;
        else /* @d8494@ */
            return Result;
    }
    f = mem[p].hh.b0;
    if (side == 0) {
        c = getlpcode(f, mem[p].hh.b1);
        lastleftmostchar = p;
    } else {

        c = getrpcode(f, mem[p].hh.b1);
        lastrightmostchar = p;
    }
    if (c == 0)
        return Result;
    Result = roundxnoverd(fontinfo[QUADCODE + parambase[f]].cint, c, 1000);
    return Result;
}
halfword znewmarginkern(scaled w, halfword p, smallnumber side) {
    register halfword Result;
    newmarginkern_regmem halfword k;
    k = getnode(MARGINKERNNODESIZE);
    mem[k].hh.b0 = MARGINKERNNODE;
    mem[k].hh.b1 = side;
    mem[k + WIDTHOFFSET].cint = w;
    if (p == TEXNULL)
        pdferror(/* str 'margin kerning' */ 1250,
                 /* str 'invalid pointer to marginal char node' */ 1251);
    {
        mem[k + 2].hh.v.LH = avail;
        if (mem[k + 2].hh.v.LH == TEXNULL)
            mem[k + 2].hh.v.LH = getavail();
        else {

            avail = mem[mem[k + 2].hh.v.LH].hh.v.RH;
            mem[mem[k + 2].hh.v.LH].hh.v.RH = TEXNULL;
            mem[mem[k + 2].hh.v.LH].hh.me = curchrsig;
            ;
#ifdef STAT
            incr(dynused);
#endif /* STAT */
        }
    }
    mem[mem[k + 2].hh.v.LH].hh.b1 = mem[p].hh.b1;
    mem[mem[k + 2].hh.v.LH].hh.b0 = mem[p].hh.b0;
    Result = k;
    return Result;
}
halfword zhpack(halfword p, scaled w, smallnumber m) {
    register halfword Result;
    hpack_regmem halfword r;
    halfword q;
    scaled h, d, x;
    scaled s;
    halfword g;
    glueord o;
    internalfontnumber f;
    fourquarters i;
    eightbits hd;
    scaled fontstretch;
    scaled fontshrink;
    scaled k;
    lastbadness = 0;
    r = getnode(BOXNODESIZE);
    mem[r].hh.b0 = HLISTNODE;
    mem[r].hh.b1 = MINQUARTERWORD;
    mem[r + 4].cint = 0;
    q = r + LISTOFFSET;
    mem[q].hh.v.RH = p;
    if (m == 2) {
        prevcharp = TEXNULL;
        fontstretch = 0;
        fontshrink = 0;
        fontexpandratio = 0;
    }
    h = 0;
    /* comment:Clear dimensions to zero */ d = 0;
    x = 0;
    totalstretch[NORMAL] = 0;
    totalshrink[NORMAL] = 0;
    totalstretch[FIL] = 0;
    totalshrink[FIL] = 0;
    totalstretch[FILL] = 0;
    totalshrink[FILL] = 0;
    totalstretch[FILLL] = 0;
    totalshrink[FILLL] = 0;
    if ((eqtb[ETEXSTATEBASE + TEXXETCODE].cint >
         0)) /* comment:Initialize the LR stack */
    {
        tempptr = getavail();
        mem[tempptr].hh.v.LH = BEFORE;
        mem[tempptr].hh.v.RH = LRptr;
        LRptr = tempptr;
    }
    while (p != TEXNULL) /* comment:Examine node |p| in the hlist, taking
                                 account of i */
    {

    labhpack21reswitch:
        while ((p >= himemmin)) /* comment:Incorporate character
                                   dimensions into the dimensio */
        {

            if (m >= 2) {
                prevcharp = p;
                switch (m) {
                case 2: {
                    f = mem[p].hh.b0;
                    fontstretch = fontstretch + charstretch(f, mem[p].hh.b1);
                    fontshrink = fontshrink + charshrink(f, mem[p].hh.b1);
                } break;
                case 3:
                    dosubstfont(p, fontexpandratio);
                    break;
                }
            }
            f = mem[p].hh.b0;
            i = fontinfo[charbase[f] + effectivechar(true, f, mem[p].hh.b1)]
                    .qqqq;
            hd = i.b1;
            x = x + fontinfo[widthbase[f] + i.b0].cint;
            s = fontinfo[heightbase[f] + (hd) / 16].cint;
            if (s > h)
                h = s;
            s = fontinfo[depthbase[f] + (hd) % 16].cint;
            if (s > d)
                d = s;
            p = mem[p].hh.v.RH;
        }
        if (p != TEXNULL) {
            switch (mem[p].hh.b0) {
            case HLISTNODE:
            case VLISTNODE:
            case RULENODE:
            case UNSETNODE:
                /* comment:Incorporate box dimensions into the dimensions of  */
                {

                    x = x + mem[p + WIDTHOFFSET].cint;
                    if (mem[p].hh.b0 >= RULENODE)
                        s = 0;
                    else
                        s = mem[p + 4].cint;
                    if (mem[p + HEIGHTOFFSET].cint - s > h)
                        h = mem[p + HEIGHTOFFSET].cint - s;
                    if (mem[p + DEPTHOFFSET].cint + s > d)
                        d = mem[p + DEPTHOFFSET].cint + s;
                }
                break;
            case INSNODE:
            case MARKNODE:
            case ADJUSTNODE:
                if ((adjusttail != TEXNULL) ||
                    (preadjusttail != TEXNULL)) /* comment:Transfer node |p| to
                                                   the adjustment list */
                {
                    while (mem[q].hh.v.RH != p)
                        q = mem[q].hh.v.RH;
                    if (mem[p].hh.b0 == ADJUSTNODE) {
                        if (mem[p].hh.b1 != 0) {
                            if (preadjusttail == TEXNULL)
                                confusion(/* str 'pre vadjust' */ 1252);
                            mem[preadjusttail].hh.v.RH = mem[p + 1].cint;
                            while (mem[preadjusttail].hh.v.RH != TEXNULL)
                                preadjusttail = mem[preadjusttail].hh.v.RH;
                        } else {

                            if (adjusttail == TEXNULL)
                                confusion(/* str 'pre vadjust' */ 1252);
                            mem[adjusttail].hh.v.RH = mem[p + 1].cint;
                            while (mem[adjusttail].hh.v.RH != TEXNULL)
                                adjusttail = mem[adjusttail].hh.v.RH;
                        }
                        p = mem[p].hh.v.RH;
                        freenode(mem[q].hh.v.RH, SMALLNODESIZE);
                    } else {

                        mem[adjusttail].hh.v.RH = p;
                        adjusttail = p;
                        p = mem[p].hh.v.RH;
                    }
                    mem[q].hh.v.RH = p;
                    p = q;
                }
                break;
            case WHATSITNODE:
                /* comment:Incorporate a whatsit node into an hbox */
                if ((mem[p].hh.b1 == /* @d8546@ */ 10) ||
                    (mem[p].hh.b1 == /* @d8547@ */ 12)) {
                    x = x + mem[p + 1].cint;
                    s = 0;
                    if (mem[p + 2].cint - s > h)
                        h = mem[p + 2].cint - s;
                    if (mem[p + 3].cint + s > d)
                        d = mem[p + 3].cint + s;
                }
                break;
            case GLUENODE:
                /* comment:Incorporate glue into the horizontal totals */ {

                    g = mem[p + 1].hh.v.LH;
                    x = x + mem[g + WIDTHOFFSET].cint;
                    o = mem[g].hh.b0;
                    totalstretch[o] = totalstretch[o] + mem[g + 2].cint;
                    o = mem[g].hh.b1;
                    totalshrink[o] = totalshrink[o] + mem[g + 3].cint;
                    if (mem[p].hh.b1 >= ALEADERS) {
                        g = mem[p + 1].hh.v.RH;
                        if (mem[g + HEIGHTOFFSET].cint > h)
                            h = mem[g + HEIGHTOFFSET].cint;
                        if (mem[g + DEPTHOFFSET].cint > d)
                            d = mem[g + DEPTHOFFSET].cint;
                    }
                }
                break;
            case MARGINKERNNODE: {
                if (m == 2) {
                    f = mem[mem[p + 2].hh.v.LH].hh.b0;
                    dosubstfont(mem[p + 2].hh.v.LH, 1000);
                    if (f != mem[mem[p + 2].hh.v.LH].hh.b0)
                        fontstretch = fontstretch - mem[p + WIDTHOFFSET].cint -
                                      charpw(mem[p + 2].hh.v.LH, mem[p].hh.b1);
                    mem[mem[p + 2].hh.v.LH].hh.b0 = f;
                    dosubstfont(mem[p + 2].hh.v.LH, -1000);
                    if (f != mem[mem[p + 2].hh.v.LH].hh.b0)
                        fontshrink = fontshrink - mem[p + WIDTHOFFSET].cint -
                                     charpw(mem[p + 2].hh.v.LH, mem[p].hh.b1);
                    mem[mem[p + 2].hh.v.LH].hh.b0 = f;
                } else if (m == 3) {
                    dosubstfont(mem[p + 2].hh.v.LH, fontexpandratio);
                    mem[p + WIDTHOFFSET].cint =
                        -(integer)charpw(mem[p + 2].hh.v.LH, mem[p].hh.b1);
                }
                x = x + mem[p + WIDTHOFFSET].cint;
            } break;
            case KERNNODE: {
                if (mem[p].hh.b1 == NORMAL) {
                    if (m == 2) {
                        fontstretch = fontstretch + kernstretch(p);
                        fontshrink = fontshrink + kernshrink(p);
                    } else if (m == 3) {
                        if (fontexpandratio > 0)
                            k = kernstretch(p);
                        else if (fontexpandratio < 0)
                            k = kernshrink(p);
                        else
                            pdfassert(0);
                        if (k != 0) {
                            if ((mem[p].hh.v.RH >= himemmin))
                                mem[p + WIDTHOFFSET].cint = getkern(
                                    mem[prevcharp].hh.b0, mem[prevcharp].hh.b1,
                                    mem[mem[p].hh.v.RH].hh.b1);
                            else if (mem[mem[p].hh.v.RH].hh.b0 == LIGATURENODE)
                                mem[p + WIDTHOFFSET].cint = getkern(
                                    mem[prevcharp].hh.b0, mem[prevcharp].hh.b1,
                                    mem[mem[p].hh.v.RH + 1].hh.b1);
                        }
                    }
                }
                x = x + mem[p + WIDTHOFFSET].cint;
            } break;
            case MATHNODE: {
                x = x + mem[p + WIDTHOFFSET].cint;
                if ((eqtb[ETEXSTATEBASE + TEXXETCODE].cint >
                     0)) /* comment:Adjust \(t)the LR stack for the |hpack|
                            routine */
                {

                    if (odd(mem[p].hh.b1)) {

                        if (mem[LRptr].hh.v.LH ==
                            (LCODE * (mem[p].hh.b1 / LCODE) /* @d8574@ */
                             + 3)) {
                            tempptr = LRptr;
                            LRptr = mem[tempptr].hh.v.RH;
                            {
                                mem[tempptr].hh.v.RH = avail;
                                avail = tempptr;
                                mem[tempptr].hh.me = 0;
                                ;
#ifdef STAT
                                decr(dynused);
#endif /* STAT */
                            }
                        } else {

                            incr(LRproblems);
                            mem[p].hh.b0 = KERNNODE;
                            mem[p].hh.b1 = EXPLICIT;
                        }
                    } else {

                        tempptr = getavail();
                        mem[tempptr].hh.v.LH =
                            (LCODE * (mem[p].hh.b1 / LCODE) /* @d8579@ */
                             + 3);
                        mem[tempptr].hh.v.RH = LRptr;
                        LRptr = tempptr;
                    }
                }
            } break;
            case LIGATURENODE: {
                if (m == 3)
                    dosubstfont(p, fontexpandratio);
                /* comment:Make node |p| look like a |char_node| and |goto re */
                {

                    mem[memtop - 12] = mem[p + 1];
                    mem[memtop - 12].hh.v.RH = mem[p].hh.v.RH;
                    mem[memtop - 12].hh.me = mem[p].hh.me;
                    p = memtop - 12;
                    goto labhpack21reswitch;
                }
            } break;
            case DISCNODE:
                if (m == 3)
                    dosubstfont(p, fontexpandratio);
                break;
            default:;
                break;
            }
            p = mem[p].hh.v.RH;
        }
    }
    if (adjusttail != TEXNULL)
        mem[adjusttail].hh.v.RH = TEXNULL;
    if (preadjusttail != TEXNULL)
        mem[preadjusttail].hh.v.RH = TEXNULL;
    mem[r + HEIGHTOFFSET].cint = h;
    mem[r + DEPTHOFFSET].cint = d;
    /* comment:Determine the value of |width(r)| and the appropri */
    if (m == ADDITIONAL)
        w = x + w;
    mem[r + WIDTHOFFSET].cint = w;
    x = w - x;
    if (x == 0) {
        mem[r + LISTOFFSET].hh.b0 = NORMAL;
        mem[r + LISTOFFSET].hh.b1 = NORMAL;
        mem[r + GLUEOFFSET].gr = 0.0;
        goto labhpack10exit;
    } else if (x > 0) /* comment:Determine horizontal glue stretch setting, then
                         |r */
    {
        /* comment:Determine the stretch order */ if (totalstretch[FILLL] != 0)
            o = FILLL;
        else if (totalstretch[FILL] != 0)
            o = FILL;
        else if (totalstretch[FIL] != 0)
            o = FIL;
        else
            o = NORMAL;
        if ((m == 2) && (o == NORMAL) && (fontstretch > 0)) {
            fontexpandratio = dividescaled(x, fontstretch, 3);
            goto labhpack10exit;
        }
        mem[r + LISTOFFSET].hh.b1 = o;
        mem[r + LISTOFFSET].hh.b0 = STRETCHING;
        if (totalstretch[o] != 0)
            mem[r + GLUEOFFSET].gr = x / ((double)totalstretch[o]);
        else {

            mem[r + LISTOFFSET].hh.b0 = NORMAL;
            mem[r + GLUEOFFSET].gr = 0.0;
        }
        if (o == NORMAL) {

            if (mem[r + LISTOFFSET].hh.v.RH !=
                TEXNULL) /* comment:Report an underfull hbox and |goto
                                 common_ending|, */
            {
                lastbadness = badness(x, totalstretch[NORMAL]);
                if (lastbadness > eqtb[INTBASE + HBADNESSCODE].cint) {
                    println();
                    if (lastbadness > 100)
                        printnl(/* str 'Underfull' */ 1253);
                    else
                        printnl(/* str 'Loose' */ 1254);
                    print(/* str ' \hbox (badness ' */ 1255);
                    printint(lastbadness);
                    goto labhpack50common_ending;
                }
            }
        }
        goto labhpack10exit;
    } else /* comment:Determine horizontal glue shrink setting, then |re */ {

        /* comment:Determine the shrink order */ if (totalshrink[FILLL] != 0)
            o = FILLL;
        else if (totalshrink[FILL] != 0)
            o = FILL;
        else if (totalshrink[FIL] != 0)
            o = FIL;
        else
            o = NORMAL;
        if ((m == 2) && (o == NORMAL) && (fontshrink > 0)) {
            fontexpandratio = dividescaled(x, fontshrink, 3);
            goto labhpack10exit;
        }
        mem[r + LISTOFFSET].hh.b1 = o;
        mem[r + LISTOFFSET].hh.b0 = SHRINKING;
        if (totalshrink[o] != 0)
            mem[r + GLUEOFFSET].gr = (-(integer)x) / ((double)totalshrink[o]);
        else {

            mem[r + LISTOFFSET].hh.b0 = NORMAL;
            mem[r + GLUEOFFSET].gr = 0.0;
        }
        if ((totalshrink[o] < -(integer)x) && (o == NORMAL) &&
            (mem[r + LISTOFFSET].hh.v.RH != TEXNULL)) {
            lastbadness = 1000000L;
            mem[r + GLUEOFFSET].gr = 1.0;
            /* comment:Report an overfull hbox and |goto common_ending|,  */
            if ((-(integer)x - totalshrink[NORMAL] >
                 eqtb[DIMENBASE + HFUZZCODE].cint) ||
                (eqtb[INTBASE + HBADNESSCODE].cint < 100)) {
                if ((eqtb[DIMENBASE + OVERFULLRULECODE].cint > 0) &&
                    (-(integer)x - totalshrink[NORMAL] >
                     eqtb[DIMENBASE + HFUZZCODE].cint)) {
                    while (mem[q].hh.v.RH != TEXNULL)
                        q = mem[q].hh.v.RH;
                    mem[q].hh.v.RH = newrule();
                    mem[mem[q].hh.v.RH /* @d8656@ */ + 1].cint =
                        eqtb[DIMENBASE + OVERFULLRULECODE].cint;
                }
                println();
                printnl(/* str 'Overfull \hbox (' */ 1261);
                printscaled(-(integer)x - totalshrink[NORMAL]);
                print(/* str 'pt too wide' */ 1262);
                goto labhpack50common_ending;
            }
        } else if (o == NORMAL) {

            if (mem[r + LISTOFFSET].hh.v.RH !=
                TEXNULL) /* comment:Report a tight hbox and |goto
                                 common_ending|, if t */
            {
                lastbadness = badness(-(integer)x, totalshrink[NORMAL]);
                if (lastbadness > eqtb[INTBASE + HBADNESSCODE].cint) {
                    println();
                    printnl(/* str 'Tight \hbox (badness ' */ 1263);
                    printint(lastbadness);
                    goto labhpack50common_ending;
                }
            }
        }
        goto labhpack10exit;
    }
labhpack50common_ending
    : /* comment:Finish issuing a diagnostic message for an overful */
    if (outputactive)
        print(/* str ') has occurred while \output is active' */ 1256);
    else {

        if (packbeginline != 0) {
            if (packbeginline > 0)
                print(/* str ') in paragraph at lines ' */ 1257);
            else
                print(/* str ') in alignment at lines ' */ 1258);
            printint(abs(packbeginline));
            print(/* str '--' */ 1259);
        } else
            print(/* str ') detected at line ' */ 1260);
        printint(line);
    }
    println();
    fontinshortdisplay = FONTBASE;
    shortdisplay(mem[r + LISTOFFSET].hh.v.RH);
    println();
    begindiagnostic();
    showbox(r);
    enddiagnostic(true);
labhpack10exit:
    if ((eqtb[ETEXSTATEBASE + TEXXETCODE].cint >
         0)) /* comment:Check for LR anomalies at the end of |hpack| */
    {
        if (mem[LRptr].hh.v.LH != BEFORE) {
            while (mem[q].hh.v.RH != TEXNULL)
                q = mem[q].hh.v.RH;
            do {
                tempptr = q;
                q = newmath(0, mem[LRptr].hh.v.LH);
                mem[tempptr].hh.v.RH = q;
                LRproblems = LRproblems + 10000;
                {
                    tempptr = LRptr;
                    LRptr = mem[tempptr].hh.v.RH;
                    {
                        mem[tempptr].hh.v.RH = avail;
                        avail = tempptr;
                        mem[tempptr].hh.me = 0;
                        ;
#ifdef STAT
                        decr(dynused);
#endif /* STAT */
                    }
                }
            } while (!(mem[LRptr].hh.v.LH == BEFORE));
        }
        if (LRproblems > 0) {
            /* comment:Report LR problems */ {

                println();
                printnl(/* str '\endL or \endR problem (' */ 2027);
                printint(LRproblems / 10000);
                print(/* str ' missing, ' */ 2028);
                printint(LRproblems % 10000);
                print(/* str ' extra' */ 2029);
                LRproblems = 0;
            }
            goto labhpack50common_ending;
        }
        {
            tempptr = LRptr;
            LRptr = mem[tempptr].hh.v.RH;
            {
                mem[tempptr].hh.v.RH = avail;
                avail = tempptr;
                mem[tempptr].hh.me = 0;
                ;
#ifdef STAT
                decr(dynused);
#endif /* STAT */
            }
        }
        if (LRptr != TEXNULL)
            confusion(/* str 'LR1' */ 2026);
    }
    if ((m == 2) && (fontexpandratio != 0)) {
        fontexpandratio = fixint(fontexpandratio, -1000, 1000);
        q = mem[r + LISTOFFSET].hh.v.RH;
        freenode(r, BOXNODESIZE);
        r = hpack(q, w, 3);
    }
    Result = r;
    return Result;
}
halfword zvpackage(halfword p, scaled h, smallnumber m, scaled l) {
    register halfword Result;
    vpackage_regmem halfword r;
    scaled w, d, x;
    scaled s;
    halfword g;
    glueord o;
    lastbadness = 0;
    r = getnode(BOXNODESIZE);
    mem[r].hh.b0 = VLISTNODE;
    mem[r].hh.b1 = MINQUARTERWORD;
    mem[r + 4].cint = 0;
    mem[r + LISTOFFSET].hh.v.RH = p;
    w = 0;
    /* comment:Clear dimensions to zero */ d = 0;
    x = 0;
    totalstretch[NORMAL] = 0;
    totalshrink[NORMAL] = 0;
    totalstretch[FIL] = 0;
    totalshrink[FIL] = 0;
    totalstretch[FILL] = 0;
    totalshrink[FILL] = 0;
    totalstretch[FILLL] = 0;
    totalshrink[FILLL] = 0;
    while (p != TEXNULL) /* comment:Examine node |p| in the vlist, taking
                                 account of i */
    {

        if ((p >= himemmin))
            confusion(/* str 'vpack' */ 1264);
        else
            switch (mem[p].hh.b0) {
            case HLISTNODE:
            case VLISTNODE:
            case RULENODE:
            case UNSETNODE:
                /* comment:Incorporate box dimensions into the dimensions of  */
                {

                    x = x + d + mem[p + HEIGHTOFFSET].cint;
                    d = mem[p + DEPTHOFFSET].cint;
                    if (mem[p].hh.b0 >= RULENODE)
                        s = 0;
                    else
                        s = mem[p + 4].cint;
                    if (mem[p + WIDTHOFFSET].cint + s > w)
                        w = mem[p + WIDTHOFFSET].cint + s;
                }
                break;
            case WHATSITNODE:
                /* comment:Incorporate a whatsit node into a vbox */
                if ((mem[p].hh.b1 == /* @d8724@ */ 10) ||
                    (mem[p].hh.b1 == /* @d8725@ */ 12)) {
                    x = x + d + mem[p + 2].cint;
                    d = mem[p + 3].cint;
                    s = 0;
                    if (mem[p + 1].cint + s > w)
                        w = mem[p + 1].cint + s;
                }
                break;
            case GLUENODE:
                /* comment:Incorporate glue into the vertical totals */ {

                    x = x + d;
                    d = 0;
                    g = mem[p + 1].hh.v.LH;
                    x = x + mem[g + WIDTHOFFSET].cint;
                    o = mem[g].hh.b0;
                    totalstretch[o] = totalstretch[o] + mem[g + 2].cint;
                    o = mem[g].hh.b1;
                    totalshrink[o] = totalshrink[o] + mem[g + 3].cint;
                    if (mem[p].hh.b1 >= ALEADERS) {
                        g = mem[p + 1].hh.v.RH;
                        if (mem[g + WIDTHOFFSET].cint > w)
                            w = mem[g + WIDTHOFFSET].cint;
                    }
                }
                break;
            case KERNNODE: {
                x = x + d + mem[p + WIDTHOFFSET].cint;
                d = 0;
            } break;
            default:;
                break;
            }
        p = mem[p].hh.v.RH;
    }
    mem[r + WIDTHOFFSET].cint = w;
    if (d > l) {
        x = x + d - l;
        mem[r + DEPTHOFFSET].cint = l;
    } else
        mem[r + DEPTHOFFSET].cint = d;
    /* comment:Determine the value of |height(r)| and the appropr */
    if (m == ADDITIONAL)
        h = x + h;
    mem[r + HEIGHTOFFSET].cint = h;
    x = h - x;
    if (x == 0) {
        mem[r + LISTOFFSET].hh.b0 = NORMAL;
        mem[r + LISTOFFSET].hh.b1 = NORMAL;
        mem[r + GLUEOFFSET].gr = 0.0;
        goto labvpackage10exit;
    } else if (x > 0) /* comment:Determine vertical glue stretch setting, then
                         |ret */
    {
        /* comment:Determine the stretch order */ if (totalstretch[FILLL] != 0)
            o = FILLL;
        else if (totalstretch[FILL] != 0)
            o = FILL;
        else if (totalstretch[FIL] != 0)
            o = FIL;
        else
            o = NORMAL;
        mem[r + LISTOFFSET].hh.b1 = o;
        mem[r + LISTOFFSET].hh.b0 = STRETCHING;
        if (totalstretch[o] != 0)
            mem[r + GLUEOFFSET].gr = x / ((double)totalstretch[o]);
        else {

            mem[r + LISTOFFSET].hh.b0 = NORMAL;
            mem[r + GLUEOFFSET].gr = 0.0;
        }
        if (o == NORMAL) {

            if (mem[r + LISTOFFSET].hh.v.RH !=
                TEXNULL) /* comment:Report an underfull vbox and |goto
                                 common_ending|, */
            {
                lastbadness = badness(x, totalstretch[NORMAL]);
                if (lastbadness > eqtb[INTBASE + VBADNESSCODE].cint) {
                    println();
                    if (lastbadness > 100)
                        printnl(/* str 'Underfull' */ 1253);
                    else
                        printnl(/* str 'Loose' */ 1254);
                    print(/* str ' \vbox (badness ' */ 1265);
                    printint(lastbadness);
                    goto labvpackage50common_ending;
                }
            }
        }
        goto labvpackage10exit;
    } else /* comment:Determine vertical glue shrink setting, then |retu */ {

        /* comment:Determine the shrink order */ if (totalshrink[FILLL] != 0)
            o = FILLL;
        else if (totalshrink[FILL] != 0)
            o = FILL;
        else if (totalshrink[FIL] != 0)
            o = FIL;
        else
            o = NORMAL;
        mem[r + LISTOFFSET].hh.b1 = o;
        mem[r + LISTOFFSET].hh.b0 = SHRINKING;
        if (totalshrink[o] != 0)
            mem[r + GLUEOFFSET].gr = (-(integer)x) / ((double)totalshrink[o]);
        else {

            mem[r + LISTOFFSET].hh.b0 = NORMAL;
            mem[r + GLUEOFFSET].gr = 0.0;
        }
        if ((totalshrink[o] < -(integer)x) && (o == NORMAL) &&
            (mem[r + LISTOFFSET].hh.v.RH != TEXNULL)) {
            lastbadness = 1000000L;
            mem[r + GLUEOFFSET].gr = 1.0;
            /* comment:Report an overfull vbox and |goto common_ending|,  */
            if ((-(integer)x - totalshrink[NORMAL] >
                 eqtb[DIMENBASE + VFUZZCODE].cint) ||
                (eqtb[INTBASE + VBADNESSCODE].cint < 100)) {
                println();
                printnl(/* str 'Overfull \vbox (' */ 1266);
                printscaled(-(integer)x - totalshrink[NORMAL]);
                print(/* str 'pt too high' */ 1267);
                goto labvpackage50common_ending;
            }
        } else if (o == NORMAL) {

            if (mem[r + LISTOFFSET].hh.v.RH !=
                TEXNULL) /* comment:Report a tight vbox and |goto
                                 common_ending|, if t */
            {
                lastbadness = badness(-(integer)x, totalshrink[NORMAL]);
                if (lastbadness > eqtb[INTBASE + VBADNESSCODE].cint) {
                    println();
                    printnl(/* str 'Tight \vbox (badness ' */ 1268);
                    printint(lastbadness);
                    goto labvpackage50common_ending;
                }
            }
        }
        goto labvpackage10exit;
    }
labvpackage50common_ending
    : /* comment:Finish issuing a diagnostic message for an overful */
    if (outputactive)
        print(/* str ') has occurred while \output is active' */ 1256);
    else {

        if (packbeginline != 0) {
            print(/* str ') in alignment at lines ' */ 1258);
            printint(abs(packbeginline));
            print(/* str '--' */ 1259);
        } else
            print(/* str ') detected at line ' */ 1260);
        printint(line);
        println();
    }
    begindiagnostic();
    showbox(r);
    enddiagnostic(true);
labvpackage10exit:
    Result = r;
    return Result;
}
void zappendtovlist(halfword b) {
    appendtovlist_regmem scaled d;
    halfword p;
    if (curlist.auxfield.cint > eqtb[DIMENBASE + PDFIGNOREDDIMENCODE].cint) {
        d = mem[eqtb[GLUEBASE + BASELINESKIPCODE].hh.v.RH /* @d8822@ */ + 1]
                .cint -
            curlist.auxfield.cint - mem[b + HEIGHTOFFSET].cint;
        if (d < eqtb[DIMENBASE + LINESKIPLIMITCODE].cint)
            p = newparamglue(LINESKIPCODE);
        else {

            p = newskipparam(BASELINESKIPCODE);
            mem[tempptr + WIDTHOFFSET].cint = d;
        }
        mem[curlist.tailfield].hh.v.RH = p;
        curlist.tailfield = p;
    }
    mem[curlist.tailfield].hh.v.RH = b;
    curlist.tailfield = b;
    curlist.auxfield.cint = mem[b + DEPTHOFFSET].cint;
}
halfword newnoad(void) {
    register halfword Result;
    newnoad_regmem halfword p;
    p = getnode(NOADSIZE);
    mem[p].hh.b0 = ORDNOAD;
    mem[p].hh.b1 = NORMAL;
    mem[p + 1].hh = emptyfield;
    mem[p + 3].hh = emptyfield;
    mem[p + 2].hh = emptyfield;
    Result = p;
    return Result;
}
halfword znewstyle(smallnumber s) {
    register halfword Result;
    newstyle_regmem halfword p;
    p = getnode(STYLENODESIZE);
    mem[p].hh.b0 = STYLENODE;
    mem[p].hh.b1 = s;
    mem[p + WIDTHOFFSET].cint = 0;
    mem[p + DEPTHOFFSET].cint = 0;
    Result = p;
    return Result;
}
halfword newchoice(void) {
    register halfword Result;
    newchoice_regmem halfword p;
    p = getnode(STYLENODESIZE);
    mem[p].hh.b0 = CHOICENODE;
    mem[p].hh.b1 = 0;
    mem[p + 1].hh.v.LH = TEXNULL;
    mem[p + 1].hh.v.RH = TEXNULL;
    mem[p + 2].hh.v.LH = TEXNULL;
    mem[p + 2].hh.v.RH = TEXNULL;
    Result = p;
    return Result;
}
void showinfo(void) { showinfo_regmem shownodelist(mem[tempptr].hh.v.LH); }
halfword zfractionrule(scaled t) {
    register halfword Result;
    fractionrule_regmem halfword p;
    p = newrule();
    mem[p + HEIGHTOFFSET].cint = t;
    mem[p + DEPTHOFFSET].cint = 0;
    Result = p;
    return Result;
}
halfword zoverbar(halfword b, scaled k, scaled t) {
    register halfword Result;
    overbar_regmem halfword p, q;
    p = newkern(k);
    mem[p].hh.v.RH = b;
    q = fractionrule(t);
    mem[q].hh.v.RH = p;
    p = newkern(t);
    mem[p].hh.v.RH = q;
    Result = vpackage(p, 0, ADDITIONAL, 1073741823L);
    return Result;
}
/* comment:Declare subprocedures for |var_delimiter| */ halfword
zcharbox(internalfontnumber f, quarterword c) {
    register halfword Result;
    charbox_regmem fourquarters q;
    eightbits hd;
    halfword b, p;
    q = fontinfo[charbase[f] + effectivechar(true, f, c)].qqqq;
    hd = q.b1;
    b = newnullbox();
    mem[b + WIDTHOFFSET].cint = fontinfo[widthbase[f] + q.b0].cint +
                                fontinfo[italicbase[f] + (q.b2) / 4].cint;
    mem[b + HEIGHTOFFSET].cint = fontinfo[heightbase[f] + (hd) / 16].cint;
    mem[b + DEPTHOFFSET].cint = fontinfo[depthbase[f] + (hd) % 16].cint;
    p = getavail();
    mem[p].hh.b1 = c;
    mem[p].hh.b0 = f;
    mem[b + LISTOFFSET].hh.v.RH = p;
    Result = b;
    return Result;
}
void zstackintobox(halfword b, internalfontnumber f, quarterword c) {
    stackintobox_regmem halfword p;
    p = charbox(f, c);
    mem[p].hh.v.RH = mem[b + LISTOFFSET].hh.v.RH;
    mem[b + LISTOFFSET].hh.v.RH = p;
    mem[b + HEIGHTOFFSET].cint = mem[p + HEIGHTOFFSET].cint;
}
scaled zheightplusdepth(internalfontnumber f, quarterword c) {
    register scaled Result;
    heightplusdepth_regmem fourquarters q;
    eightbits hd;
    q = fontinfo[charbase[f] + effectivechar(true, f, c)].qqqq;
    hd = q.b1;
    Result = fontinfo[heightbase[f] + (hd) / 16].cint +
             fontinfo[depthbase[f] + (hd) % 16].cint;
    return Result;
}
halfword zvardelimiter(halfword d, smallnumber s, scaled v) {
    register halfword Result;
    vardelimiter_regmem halfword b;
    internalfontnumber f, g;
    quarterword c, x, y;
    integer m, n;
    scaled u;
    scaled w;
    fourquarters q;
    eightbits hd;
    fourquarters r;
    smallnumber z;
    boolean largeattempt;
    f = FONTBASE;
    w = 0;
    largeattempt = false;
    z = mem[d].qqqq.b0;
    x = mem[d].qqqq.b1;
    while (true) {

        /* comment:Look at the variants of |(z,x)|; set |f| and |c| w */
        if ((z != 0) || (x != MINQUARTERWORD)) {
            z = z + s + 16;
            do {
                z = z - 16;
                g = eqtb[MATHFONTBASE + z].hh.v.RH;
                if (g != FONTBASE) /* comment:Look at the list of
                                             characters starting with |x| i */
                {
                    y = x;
                    if ((y >= fontbc[g]) && (y <= fontec[g])) {
                    labvardelimiter22continue:
                        q = fontinfo[charbase[g] + y].qqqq;
                        if ((q.b0 > MINQUARTERWORD)) {
                            if (((q.b2) % 4) == EXTTAG) {
                                f = g;
                                c = y;
                                goto labvardelimiter40found;
                            }
                            hd = q.b1;
                            u = fontinfo[heightbase[g] + (hd) / 16].cint +
                                fontinfo[depthbase[g] + (hd) % 16].cint;
                            if (u > w) {
                                f = g;
                                c = y;
                                w = u;
                                if (u >= v)
                                    goto labvardelimiter40found;
                            }
                            if (((q.b2) % 4) == LISTTAG) {
                                y = q.b3;
                                goto labvardelimiter22continue;
                            }
                        }
                    }
                }
            } while (!(z < 16));
        }
        if (largeattempt)
            goto labvardelimiter40found;
        largeattempt = true;
        z = mem[d].qqqq.b2;
        x = mem[d].qqqq.b3;
    }
labvardelimiter40found:
    if (f != /* @d8868@ */
        0) /* comment:Make variable |b| point to a box for |(f,c)| */ {

        if (((q.b2) % 4) == EXTTAG) /* comment:Construct an extensible
                                                character in a new box |b| */
        {
            b = newnullbox();
            mem[b].hh.b0 = VLISTNODE;
            r = fontinfo[extenbase[f] + q.b3].qqqq;
            /* comment:Compute the minimum suitable height, |w|, and the  */ c =
                r.b3;
            u = heightplusdepth(f, c);
            w = 0;
            q = fontinfo[charbase[f] + effectivechar(true, f, c)].qqqq;
            mem[b + WIDTHOFFSET].cint =
                fontinfo[widthbase[f] + q.b0].cint +
                fontinfo[italicbase[f] + (q.b2) / 4].cint;
            c = r.b2;
            if (c != MINQUARTERWORD)
                w = w + heightplusdepth(f, c);
            c = r.b1;
            if (c != MINQUARTERWORD)
                w = w + heightplusdepth(f, c);
            c = r.b0;
            if (c != MINQUARTERWORD)
                w = w + heightplusdepth(f, c);
            n = 0;
            if (u > 0)
                while (w < v) {

                    w = w + u;
                    incr(n);
                    if (r.b1 != MINQUARTERWORD)
                        w = w + u;
                }
            c = r.b2;
            if (c != MINQUARTERWORD)
                stackintobox(b, f, c);
            c = r.b3;
            {
                register integer for_end;
                m = 1;
                for_end = n;
                if (m <= for_end)
                    do
                        stackintobox(b, f, c);
                    while (m++ < for_end);
            }
            c = r.b1;
            if (c != MINQUARTERWORD) {
                stackintobox(b, f, c);
                c = r.b3;
                {
                    register integer for_end;
                    m = 1;
                    for_end = n;
                    if (m <= for_end)
                        do
                            stackintobox(b, f, c);
                        while (m++ < for_end);
                }
            }
            c = r.b0;
            if (c != MINQUARTERWORD)
                stackintobox(b, f, c);
            mem[b + DEPTHOFFSET].cint = w - mem[b + HEIGHTOFFSET].cint;
        } else
            b = charbox(f, c);
    } else {

        b = newnullbox();
        mem[b + WIDTHOFFSET].cint =
            eqtb[DIMENBASE + NULLDELIMITERSPACECODE].cint;
    }
    mem[b + 4].cint =
        half(mem[b + HEIGHTOFFSET].cint - mem[b + DEPTHOFFSET].cint) -
        fontinfo[22 + parambase[eqtb[/* @d8889@ */ 27695 + s].hh.v.RH]].cint;
    Result = b;
    return Result;
}
halfword zrebox(halfword b, scaled w) {
    register halfword Result;
    rebox_regmem halfword p;
    internalfontnumber f;
    scaled v;
    if ((mem[b + WIDTHOFFSET].cint != w) &&
        (mem[b + LISTOFFSET].hh.v.RH != TEXNULL)) {
        if (mem[b].hh.b0 == VLISTNODE)
            b = hpack(b, 0, ADDITIONAL);
        p = mem[b + LISTOFFSET].hh.v.RH;
        if (((p >= himemmin)) && (mem[p].hh.v.RH == TEXNULL)) {
            f = mem[p].hh.b0;
            v = fontinfo[widthbase[f] +
                         fontinfo[charbase[f] +
                                  effectivechar(true, f, mem[p].hh.b1)]
                             .qqqq.b0]
                    .cint;
            if (v != mem[b + WIDTHOFFSET].cint)
                mem[p].hh.v.RH = newkern(mem[b + WIDTHOFFSET].cint - v);
        }
        freenode(b, BOXNODESIZE);
        b = newglue(/* @d8898@ */ /* @d8899@ */ /* @d8900@ */ membot + 12);
        mem[b].hh.v.RH = p;
        while (mem[p].hh.v.RH != TEXNULL)
            p = mem[p].hh.v.RH;
        mem[p].hh.v.RH =
            newglue(/* @d8901@ */ /* @d8902@ */ /* @d8903@ */ membot + 12);
        Result = hpack(b, w, EXACTLY);
    } else {

        mem[b + WIDTHOFFSET].cint = w;
        Result = b;
    }
    return Result;
}
halfword zmathglue(halfword g, scaled m) {
    register halfword Result;
    mathglue_regmem halfword p;
    integer n;
    scaled f;
    n = xovern(m, 65536L);
    f = texremainder;
    if (f < 0) {
        decr(n);
        f = f + 65536L;
    }
    p = getnode(GLUESPECSIZE);
    mem[p + WIDTHOFFSET].cint = multandadd(n, mem[g + WIDTHOFFSET].cint,
                                           xnoverd(mem[/* @d8909@ */
                                                       g + 1]
                                                       .cint,
                                                   f, 65536L),
                                           1073741823L);
    mem[p].hh.b0 = mem[g].hh.b0;
    if (mem[p].hh.b0 == NORMAL)
        mem[p + 2].cint =
            multandadd(n, mem[g + 2].cint, xnoverd(mem[g + 2].cint, f, 65536L),
                       1073741823L);
    else
        mem[p + 2].cint = mem[g + 2].cint;
    mem[p].hh.b1 = mem[g].hh.b1;
    if (mem[p].hh.b1 == NORMAL)
        mem[p + 3].cint =
            multandadd(n, mem[g + 3].cint, xnoverd(mem[g + 3].cint, f, 65536L),
                       1073741823L);
    else
        mem[p + 3].cint = mem[g + 3].cint;
    Result = p;
    return Result;
}
void zmathkern(halfword p, scaled m) {
    mathkern_regmem integer n;
    scaled f;
    if (mem[p].hh.b1 == MUGLUE) {
        n = xovern(m, 65536L);
        f = texremainder;
        if (f < 0) {
            decr(n);
            f = f + 65536L;
        }
        mem[p + WIDTHOFFSET].cint = multandadd(
            n, mem[p + WIDTHOFFSET].cint,
            xnoverd(mem[p + WIDTHOFFSET].cint, f, 65536L), 1073741823L);
        mem[p].hh.b1 = EXPLICIT;
    }
}
void flushmath(void) {
    flushmath_regmem flushnodelist(mem[curlist.headfield].hh.v.RH);
    flushnodelist(curlist.auxfield.cint);
    mem[curlist.headfield].hh.v.RH = TEXNULL;
    curlist.tailfield = curlist.headfield;
    curlist.auxfield.cint = TEXNULL;
}
halfword zcleanbox(halfword p, smallnumber s) {
    register halfword Result;
    cleanbox_regmem halfword q;
    smallnumber savestyle;
    halfword x;
    halfword r;
    switch (mem[p].hh.v.RH) {
    case MATHCHAR: {
        curmlist = newnoad();
        mem[curmlist + 1] = mem[p];
        mem[curmlist].hh.me = mem[p].hh.me;
    } break;
    case SUBBOX: {
        q = mem[p].hh.v.LH;
        goto labcleanbox40found;
    } break;
    case SUBMLIST:
        curmlist = mem[p].hh.v.LH;
        break;
    default: {
        q = newnullbox();
        goto labcleanbox40found;
    } break;
    }
    savestyle = curstyle;
    curstyle = s;
    mlistpenalties = false;
    mlisttohlist();
    q = mem[memtop - 3].hh.v.RH;
    curstyle = savestyle;
    /* comment:Set up the values of |cur_size| and |cur_mu|, base */ {

        if (curstyle < SCRIPTSTYLE)
            cursize = TEXTSIZE;
        else
            cursize = 16 * ((curstyle - TEXTSTYLE) / 2);
        curmu = xovern(
            fontinfo[6 + parambase[eqtb[/* @d8927@ */ 27695 + cursize].hh.v.RH]]
                .cint,
            18);
    }
labcleanbox40found:
    if ((q >= himemmin) || (q == TEXNULL))
        x = hpack(q, 0, ADDITIONAL);
    else if ((mem[q].hh.v.RH == TEXNULL) && (mem[q].hh.b0 <= VLISTNODE) &&
             (mem[q + 4].cint == 0))
        x = q;
    else
        x = hpack(q, 0, ADDITIONAL);
    /* comment:Simplify a trivial box */ q = mem[x + LISTOFFSET].hh.v.RH;
    if ((q >= himemmin)) {
        r = mem[q].hh.v.RH;
        if (r != TEXNULL) {

            if (mem[r].hh.v.RH == TEXNULL) {

                if (!(r >= himemmin)) {

                    if (mem[r].hh.b0 == KERNNODE) {
                        freenode(r, SMALLNODESIZE);
                        mem[q].hh.v.RH = TEXNULL;
                    }
                }
            }
        }
    }
    Result = x;
    return Result;
}
void zfetch(halfword a) {
    fetch_regmem curc = mem[a].hh.b1;
    curf = eqtb[MATHFONTBASE + mem[a].hh.b0 + cursize].hh.v.RH;
    if (curf == FONTBASE) /* comment:Complain about an undefined family
                                    and set |cur_i| */
    {
        {
            if (interaction == ERRORSTOPMODE)
                ;
            if (filelineerrorstylep)
                printfileline();
            else
                printnl(/* str '! ' */ 264);
            print(/* str '' */ 345);
        }
        printsize(cursize);
        printchar(/* str ' ' */ 32);
        printint(mem[a].hh.b0);
        print(/* str ' is undefined (character ' */ 1294);
        print(curc);
        printchar(/* str ')' */ 41);
        {
            helpptr = 4;
            helpline[3] =
                /* str 'Somewhere in the math formula just ended, you use' */
                1295;
            helpline[2] =
                /* str 'stated character from an undefined font family. F' */
                1296;
            helpline[1] =
                /* str 'plain TeX doesn't allow \it or \sl in subscripts.' */
                1297;
            helpline[0] =
                /* str 'and I'll try to forget that I needed that charact' */
                1298;
        }
        error();
        curi = nullcharacter;
        mem[a].hh.v.RH = EMPTY;
    } else {

        if ((curc >= fontbc[curf]) && (curc <= fontec[curf]))
            curi = fontinfo[charbase[curf] + curc].qqqq;
        else
            curi = nullcharacter;
        if (!((curi.b0 > MINQUARTERWORD))) {
            charwarning(curf, curc);
            mem[a].hh.v.RH = EMPTY;
        }
    }
}
/* comment:Declare math construction procedures */ void zmakeover(halfword q) {
    makeover_regmem mem[q + 1].hh.v.LH = overbar(
        cleanbox(q + 1, 2 * (curstyle / 2) /* @d8953@ */
                            + 1),
        3 * fontinfo[8 + parambase[eqtb[/* @d8954@ */ 27696 + cursize].hh.v.RH]]
                .cint,
        fontinfo[8 + parambase[eqtb[/* @d8955@ */ 27696 + cursize].hh.v.RH]]
            .cint);
    mem[q + 1].hh.v.RH = SUBBOX;
}
void zmakeunder(halfword q) {
    makeunder_regmem halfword p, x, y;
    scaled delta;
    x = cleanbox(q + 1, curstyle);
    p = newkern(
        3 * fontinfo[8 + parambase[eqtb[/* @d8957@ */ 27696 + cursize].hh.v.RH]]
                .cint);
    mem[x].hh.v.RH = p;
    mem[p].hh.v.RH = fractionrule(
        fontinfo[8 + parambase[eqtb[/* @d8958@ */ 27696 + cursize].hh.v.RH]]
            .cint);
    y = vpackage(x, 0, ADDITIONAL, 1073741823L);
    delta = mem[y + HEIGHTOFFSET].cint + mem[y + DEPTHOFFSET].cint +
            fontinfo[8 + parambase[eqtb[/* @d8962@ */ 27696 + cursize].hh.v.RH]]
                .cint;
    mem[y + HEIGHTOFFSET].cint = mem[x + HEIGHTOFFSET].cint;
    mem[y + DEPTHOFFSET].cint = delta - mem[y + HEIGHTOFFSET].cint;
    mem[q + 1].hh.v.LH = y;
    mem[q + 1].hh.v.RH = SUBBOX;
}
void zmakevcenter(halfword q) {
    makevcenter_regmem halfword v;
    scaled delta;
    v = mem[q + 1].hh.v.LH;
    if (mem[v].hh.b0 != VLISTNODE)
        confusion(/* str 'vcenter' */ 619);
    delta = mem[v + HEIGHTOFFSET].cint + mem[v + DEPTHOFFSET].cint;
    mem[v + HEIGHTOFFSET].cint =
        fontinfo[22 + parambase[eqtb[/* @d8973@ */ 27695 + cursize].hh.v.RH]]
            .cint +
        half(delta);
    mem[v + DEPTHOFFSET].cint = delta - mem[v + HEIGHTOFFSET].cint;
}
void zmakeradical(halfword q) {
    makeradical_regmem halfword x, y;
    scaled delta, clr;
    x = cleanbox(q + 1, 2 * (curstyle / 2) /* @d8976@ */ + 1);
    if (curstyle < TEXTSTYLE)
        clr =
            fontinfo[8 + parambase[eqtb[/* @d8978@ */ 27696 + cursize].hh.v.RH]]
                .cint +
            (abs(fontinfo[5 + parambase[eqtb[/* @d8979@ */ 27695 + cursize]
                                            .hh.v.RH]]
                     .cint) /
             4);
    else {

        clr =
            fontinfo[8 + parambase[eqtb[/* @d8980@ */ 27696 + cursize].hh.v.RH]]
                .cint;
        clr = clr + (abs(clr) / 4);
    }
    y = vardelimiter(
        q + 4, cursize,
        mem[x + HEIGHTOFFSET].cint + mem[x + DEPTHOFFSET].cint + clr +
            fontinfo[8 + parambase[eqtb[/* @d8983@ */ 27696 + cursize].hh.v.RH]]
                .cint);
    delta = mem[y + DEPTHOFFSET].cint -
            (mem[x + HEIGHTOFFSET].cint + mem[x + DEPTHOFFSET].cint + clr);
    if (delta > 0)
        clr = clr + half(delta);
    mem[y + 4].cint = -(integer)(mem[x + HEIGHTOFFSET].cint + clr);
    mem[y].hh.v.RH = overbar(x, clr, mem[y + HEIGHTOFFSET].cint);
    mem[q + 1].hh.v.LH = hpack(y, 0, ADDITIONAL);
    mem[q + 1].hh.v.RH = SUBBOX;
}
void zmakemathaccent(halfword q) {
    makemathaccent_regmem halfword p, x, y;
    integer a;
    quarterword c;
    internalfontnumber f;
    fourquarters i;
    scaled s;
    scaled h;
    scaled delta;
    scaled w;
    fetch(q + 4);
    if ((curi.b0 > MINQUARTERWORD)) {
        i = curi;
        c = curc;
        f = curf;
        /* comment:Compute the amount of skew */ s = 0;
        if (mem[q + 1].hh.v.RH == MATHCHAR) {
            fetch(q + 1);
            if (((curi.b2) % 4) == LIGTAG) {
                a = ligkernbase[curf] + curi.b3;
                curi = fontinfo[a].qqqq;
                if (curi.b0 > 128) {
                    a = ligkernbase[curf] + 256 * curi.b2 + curi.b3 + 32768L -
                        256 * (/* @d8997@ */ 128);
                    curi = fontinfo[a].qqqq;
                }
                while (true) {

                    if (curi.b1 == skewchar[curf]) {
                        if (curi.b2 >= 128) {

                            if (curi.b0 <= 128)
                                s = fontinfo[kernbase[curf] + 256 * curi.b2 +
                                             curi.b3]
                                        .cint;
                        }
                        goto labmakemathaccent31done1;
                    }
                    if (curi.b0 >= 128)
                        goto labmakemathaccent31done1;
                    a = a + curi.b0 + 1;
                    curi = fontinfo[a].qqqq;
                }
            }
        }
    labmakemathaccent31done1:;
        x = cleanbox(q + 1, 2 * (curstyle / 2) /* @d9001@ */ + 1);
        w = mem[x + WIDTHOFFSET].cint;
        h = mem[x + HEIGHTOFFSET].cint;
        /* comment:Switch to a larger accent if available and appropr */ while (
            true) {

            if (((i.b2) % 4) != LISTTAG)
                goto labmakemathaccent30done;
            y = i.b3;
            i = fontinfo[charbase[f] + y].qqqq;
            if (!(i.b0 > MINQUARTERWORD))
                goto labmakemathaccent30done;
            if (fontinfo[widthbase[f] + i.b0].cint > w)
                goto labmakemathaccent30done;
            c = y;
        }
    labmakemathaccent30done:;
        if (h < fontinfo[XHEIGHTCODE + parambase[f]].cint)
            delta = h;
        else
            delta = fontinfo[XHEIGHTCODE + parambase[f]].cint;
        if ((mem[q + 2].hh.v.RH != EMPTY) || (mem[q + 3].hh.v.RH != EMPTY)) {

            if (mem[q + 1].hh.v.RH ==
                MATHCHAR) /* comment:Swap the subscript and superscript
                                    into box |x| */
            {
                flushnodelist(x);
                x = newnoad();
                mem[x + 1] = mem[q + 1];
                mem[x + 2] = mem[q + 2];
                mem[x + 3] = mem[q + 3];
                mem[q + 2].hh = emptyfield;
                mem[q + 3].hh = emptyfield;
                mem[q + 1].hh.v.RH = SUBMLIST;
                mem[q + 1].hh.v.LH = x;
                x = cleanbox(q + 1, curstyle);
                delta = delta + mem[x + HEIGHTOFFSET].cint - h;
                h = mem[x + HEIGHTOFFSET].cint;
            }
        }
        y = charbox(f, c);
        mem[y + 4].cint = s + half(w - mem[y + WIDTHOFFSET].cint);
        mem[y + WIDTHOFFSET].cint = 0;
        p = newkern(-(integer)delta);
        mem[p].hh.v.RH = x;
        mem[y].hh.v.RH = p;
        y = vpackage(y, 0, ADDITIONAL, 1073741823L);
        mem[y + WIDTHOFFSET].cint = mem[x + WIDTHOFFSET].cint;
        if (mem[y + HEIGHTOFFSET].cint <
            h) /* comment:Make the height of box |y| equal to |h| */
        {
            p = newkern(h - mem[y + HEIGHTOFFSET].cint);
            mem[p].hh.v.RH = mem[y + LISTOFFSET].hh.v.RH;
            mem[y + LISTOFFSET].hh.v.RH = p;
            mem[y + HEIGHTOFFSET].cint = h;
        }
        mem[q + 1].hh.v.LH = y;
        mem[q + 1].hh.v.RH = SUBBOX;
    }
}
void zmakefraction(halfword q) {
    makefraction_regmem halfword p, v, x, y, z;
    scaled delta, delta1, delta2, shiftup, shiftdown, clr;
    if (mem[q + WIDTHOFFSET].cint == 1073741824L)
        mem[q + WIDTHOFFSET].cint =
            fontinfo[8 + parambase[eqtb[/* @d9034@ */ 27696 + cursize].hh.v.RH]]
                .cint;
    /* comment:Create equal-width boxes |x| and |z| for the numer */ x =
        cleanbox(q + 2, curstyle + 2 - 2 * (curstyle / 6));
    z = cleanbox(q + 3,
                 2 * (curstyle / 2) /* @d9036@ */ + 3 - 2 * (curstyle / 6));
    if (mem[x + WIDTHOFFSET].cint < mem[z + WIDTHOFFSET].cint)
        x = rebox(x, mem[z + WIDTHOFFSET].cint);
    else
        z = rebox(z, mem[x + WIDTHOFFSET].cint);
    if (curstyle < TEXTSTYLE) {
        shiftup =
            fontinfo[8 + parambase[eqtb[/* @d9042@ */ 27695 + cursize].hh.v.RH]]
                .cint;
        shiftdown =
            fontinfo[11 +
                     parambase[eqtb[/* @d9043@ */ 27695 + cursize].hh.v.RH]]
                .cint;
    } else {

        shiftdown =
            fontinfo[12 +
                     parambase[eqtb[/* @d9044@ */ 27695 + cursize].hh.v.RH]]
                .cint;
        if (mem[q + WIDTHOFFSET].cint != 0)
            shiftup =
                fontinfo[9 +
                         parambase[eqtb[/* @d9046@ */ 27695 + cursize].hh.v.RH]]
                    .cint;
        else
            shiftup =
                fontinfo[10 +
                         parambase[eqtb[/* @d9047@ */ 27695 + cursize].hh.v.RH]]
                    .cint;
    }
    if (mem[q + WIDTHOFFSET].cint ==
        0) /* comment:Adjust \(s)|shift_up| and |shift_down| for the cas */
    {
        if (curstyle < TEXTSTYLE)
            clr =
                7 *
                fontinfo[8 +
                         parambase[eqtb[/* @d9051@ */ 27696 + cursize].hh.v.RH]]
                    .cint;
        else
            clr =
                3 *
                fontinfo[8 +
                         parambase[eqtb[/* @d9052@ */ 27696 + cursize].hh.v.RH]]
                    .cint;
        delta = half(clr - ((shiftup - mem[x + DEPTHOFFSET].cint) -
                            (mem[z + HEIGHTOFFSET].cint - shiftdown)));
        if (delta > 0) {
            shiftup = shiftup + delta;
            shiftdown = shiftdown + delta;
        }
    } else /* comment:Adjust \(s)|shift_up| and |shift_down| for the cas */ {

        if (curstyle < TEXTSTYLE)
            clr = 3 * mem[q + WIDTHOFFSET].cint;
        else
            clr = mem[q + WIDTHOFFSET].cint;
        delta = half(mem[q + WIDTHOFFSET].cint);
        delta1 =
            clr -
            ((shiftup - mem[x + DEPTHOFFSET].cint) -
             (fontinfo[22 +
                       parambase[eqtb[/* @d9061@ */ 27695 + cursize].hh.v.RH]]
                  .cint +
              delta));
        delta2 =
            clr -
            ((fontinfo[22 +
                       parambase[eqtb[/* @d9062@ */ 27695 + cursize].hh.v.RH]]
                  .cint -
              delta) -
             (mem[z + HEIGHTOFFSET].cint - shiftdown));
        if (delta1 > 0)
            shiftup = shiftup + delta1;
        if (delta2 > 0)
            shiftdown = shiftdown + delta2;
    }
    /* comment:Construct a vlist box for the fraction, according  */ v =
        newnullbox();
    mem[v].hh.b0 = VLISTNODE;
    mem[v + HEIGHTOFFSET].cint = shiftup + mem[x + HEIGHTOFFSET].cint;
    mem[v + DEPTHOFFSET].cint = mem[z + DEPTHOFFSET].cint + shiftdown;
    mem[v + WIDTHOFFSET].cint = mem[x + WIDTHOFFSET].cint;
    if (mem[q + WIDTHOFFSET].cint == 0) {
        p = newkern((shiftup - mem[x + DEPTHOFFSET].cint) -
                    (mem[z + HEIGHTOFFSET].cint - shiftdown));
        mem[p].hh.v.RH = z;
    } else {

        y = fractionrule(mem[q + WIDTHOFFSET].cint);
        p = newkern(
            (fontinfo[22 +
                      parambase[eqtb[/* @d9076@ */ 27695 + cursize].hh.v.RH]]
                 .cint -
             delta) -
            (mem[z + HEIGHTOFFSET].cint - shiftdown));
        mem[y].hh.v.RH = p;
        mem[p].hh.v.RH = z;
        p = newkern(
            (shiftup - mem[x + DEPTHOFFSET].cint) -
            (fontinfo[22 +
                      parambase[eqtb[/* @d9079@ */ 27695 + cursize].hh.v.RH]]
                 .cint +
             delta));
        mem[p].hh.v.RH = y;
    }
    mem[x].hh.v.RH = p;
    mem[v + LISTOFFSET].hh.v.RH = x;
    /* comment:Put the \(f)fraction into a box with its delimiter */
    if (curstyle < TEXTSTYLE)
        delta = fontinfo[20 +
                         parambase[eqtb[/* @d9083@ */ 27695 + cursize].hh.v.RH]]
                    .cint;
    else
        delta = fontinfo[21 +
                         parambase[eqtb[/* @d9084@ */ 27695 + cursize].hh.v.RH]]
                    .cint;
    x = vardelimiter(q + 4, cursize, delta);
    mem[x].hh.v.RH = v;
    z = vardelimiter(q + 5, cursize, delta);
    mem[v].hh.v.RH = z;
    mem[q + 1].cint = hpack(x, 0, ADDITIONAL);
}
scaled zmakeop(halfword q) {
    register scaled Result;
    makeop_regmem scaled delta;
    halfword p, v, x, y, z;
    quarterword c;
    fourquarters i;
    scaled shiftup, shiftdown;
    if ((mem[q].hh.b1 == NORMAL) && (curstyle < TEXTSTYLE))
        mem[q].hh.b1 = LIMITS;
    if (mem[q + 1].hh.v.RH == MATHCHAR) {
        fetch(q + 1);
        if ((curstyle < TEXTSTYLE) && (((curi.b2) % 4) == LISTTAG)) {
            c = curi.b3;
            i = fontinfo[charbase[curf] + c].qqqq;
            if ((i.b0 > MINQUARTERWORD)) {
                curc = c;
                curi = i;
                mem[q + 1].hh.b1 = c;
            }
        }
        delta = fontinfo[italicbase[curf] + (curi.b2) / 4].cint;
        x = cleanbox(q + 1, curstyle);
        if ((mem[q + 3].hh.v.RH != EMPTY) && (mem[q].hh.b1 != LIMITS))
            mem[x + WIDTHOFFSET].cint = mem[x + WIDTHOFFSET].cint - delta;
        mem[x + 4].cint =
            half(mem[x + HEIGHTOFFSET].cint - mem[x + DEPTHOFFSET].cint) -
            fontinfo[22 +
                     parambase[eqtb[/* @d9099@ */ 27695 + cursize].hh.v.RH]]
                .cint;
        mem[q + 1].hh.v.RH = SUBBOX;
        mem[q + 1].hh.v.LH = x;
    } else
        delta = 0;
    if (mem[q].hh.b1 == LIMITS) /* comment:Construct a box with limits
                                            above and below it, sk */
    {
        x = cleanbox(q + 2,
                     2 * (curstyle / 4) /* @d9103@ */ + 4 + (curstyle % 2));
        y = cleanbox(q + 1, curstyle);
        z = cleanbox(q + 3, 2 * (curstyle / 4) /* @d9104@ */ /* @d9105@ */ + 5);
        v = newnullbox();
        mem[v].hh.b0 = VLISTNODE;
        mem[v + WIDTHOFFSET].cint = mem[y + WIDTHOFFSET].cint;
        if (mem[x + WIDTHOFFSET].cint > mem[v + WIDTHOFFSET].cint)
            mem[v + WIDTHOFFSET].cint = mem[x + WIDTHOFFSET].cint;
        if (mem[z + WIDTHOFFSET].cint > mem[v + WIDTHOFFSET].cint)
            mem[v + WIDTHOFFSET].cint = mem[z + WIDTHOFFSET].cint;
        x = rebox(x, mem[v + WIDTHOFFSET].cint);
        y = rebox(y, mem[v + WIDTHOFFSET].cint);
        z = rebox(z, mem[v + WIDTHOFFSET].cint);
        mem[x + 4].cint = half(delta);
        mem[z + 4].cint = -(integer)mem[x + 4].cint;
        mem[v + HEIGHTOFFSET].cint = mem[y + HEIGHTOFFSET].cint;
        mem[v + DEPTHOFFSET].cint = mem[y + DEPTHOFFSET].cint;
        /* comment:Attach the limits to |y| and adjust |height(v)|, | */
        if (mem[q + 2].hh.v.RH == EMPTY) {
            freenode(x, BOXNODESIZE);
            mem[v + LISTOFFSET].hh.v.RH = y;
        } else {

            shiftup =
                fontinfo[11 +
                         parambase[eqtb[/* @d9128@ */ 27696 + cursize].hh.v.RH]]
                    .cint -
                mem[x + DEPTHOFFSET].cint;
            if (shiftup <
                fontinfo[9 +
                         parambase[eqtb[/* @d9130@ */ 27696 + cursize].hh.v.RH]]
                    .cint)
                shiftup =
                    fontinfo[9 + parambase[eqtb[/* @d9131@ */ 27696 + cursize]
                                               .hh.v.RH]]
                        .cint;
            p = newkern(shiftup);
            mem[p].hh.v.RH = y;
            mem[x].hh.v.RH = p;
            p = newkern(
                fontinfo[13 +
                         parambase[eqtb[/* @d9132@ */ 27696 + cursize].hh.v.RH]]
                    .cint);
            mem[p].hh.v.RH = x;
            mem[v + LISTOFFSET].hh.v.RH = p;
            mem[v + HEIGHTOFFSET].cint =
                mem[v + HEIGHTOFFSET].cint +
                fontinfo[13 +
                         parambase[eqtb[/* @d9136@ */ 27696 + cursize].hh.v.RH]]
                    .cint +
                mem[x + HEIGHTOFFSET].cint + mem[x + DEPTHOFFSET].cint +
                shiftup;
        }
        if (mem[q + 3].hh.v.RH == EMPTY)
            freenode(z, BOXNODESIZE);
        else {

            shiftdown =
                fontinfo[12 +
                         parambase[eqtb[/* @d9141@ */ 27696 + cursize].hh.v.RH]]
                    .cint -
                mem[z + HEIGHTOFFSET].cint;
            if (shiftdown <
                fontinfo[10 +
                         parambase[eqtb[/* @d9143@ */ 27696 + cursize].hh.v.RH]]
                    .cint)
                shiftdown =
                    fontinfo[10 + parambase[eqtb[/* @d9144@ */ 27696 + cursize]
                                                .hh.v.RH]]
                        .cint;
            p = newkern(shiftdown);
            mem[y].hh.v.RH = p;
            mem[p].hh.v.RH = z;
            p = newkern(
                fontinfo[13 +
                         parambase[eqtb[/* @d9145@ */ 27696 + cursize].hh.v.RH]]
                    .cint);
            mem[z].hh.v.RH = p;
            mem[v + DEPTHOFFSET].cint =
                mem[v + DEPTHOFFSET].cint +
                fontinfo[13 +
                         parambase[eqtb[/* @d9148@ */ 27696 + cursize].hh.v.RH]]
                    .cint +
                mem[z + HEIGHTOFFSET].cint + mem[z + DEPTHOFFSET].cint +
                shiftdown;
        }
        mem[q + 1].cint = v;
    }
    Result = delta;
    return Result;
}
void zmakeord(halfword q) {
    makeord_regmem integer a;
    halfword p, r;
labmakeord20restart:
    if (mem[q + 3].hh.v.RH == EMPTY) {

        if (mem[q + 2].hh.v.RH == EMPTY) {

            if (mem[q + 1].hh.v.RH == MATHCHAR) {
                p = mem[q].hh.v.RH;
                if (p != TEXNULL) {

                    if ((mem[p].hh.b0 >= ORDNOAD) &&
                        (mem[p].hh.b0 <= PUNCTNOAD)) {

                        if (mem[p + 1].hh.v.RH == MATHCHAR) {

                            if (mem[p + 1].hh.b0 == mem[q + 1].hh.b0) {
                                mem[q + 1].hh.v.RH = MATHTEXTCHAR;
                                fetch(q + 1);
                                if (((curi.b2) % 4) == LIGTAG) {
                                    a = ligkernbase[curf] + curi.b3;
                                    curc = mem[p + 1].hh.b1;
                                    curi = fontinfo[a].qqqq;
                                    if (curi.b0 > 128) {
                                        a = ligkernbase[curf] + 256 * curi.b2 +
                                            curi.b3 + 32768L -
                                            256 * (/* @d9162@ */ 128);
                                        curi = fontinfo[a].qqqq;
                                    }
                                    while (true) {

                                        /* comment:If instruction |cur_i| is a
                                         * kern with |cur_c|, att */
                                        if (curi.b1 == curc) {

                                            if (curi.b0 <= 128) {

                                                if (curi.b2 >= 128) {
                                                    p = newkern(
                                                        fontinfo
                                                            [kernbase[curf] +
                                                             256 * curi.b2 +
                                                             curi.b3]
                                                                .cint);
                                                    mem[p].hh.v.RH =
                                                        mem[q].hh.v.RH;
                                                    mem[q].hh.v.RH = p;
                                                    return;
                                                } else {

                                                    {
                                                        if (interrupt != 0)
                                                            pauseforinstructions();
                                                    }
                                                    switch (curi.b2) {
                                                    case 1:
                                                    case 5:
                                                        mem[q + 1].hh.b1 =
                                                            curi.b3;
                                                        break;
                                                    case 2:
                                                    case 6:
                                                        mem[p + 1].hh.b1 =
                                                            curi.b3;
                                                        break;
                                                    case 3:
                                                    case 7:
                                                    case 11: {
                                                        r = newnoad();
                                                        mem[r + 1].hh.b1 =
                                                            curi.b3;
                                                        mem[r + 1].hh.b0 =
                                                            mem[q + 1].hh.b0;
                                                        mem[q].hh.v.RH = r;
                                                        mem[r].hh.v.RH = p;
                                                        if (curi.b2 < 11)
                                                            mem[r + 1].hh.v.RH =
                                                                MATHCHAR;
                                                        else
                                                            mem[r + 1].hh.v.RH =
                                                                MATHTEXTCHAR;
                                                    } break;
                                                    default: {
                                                        mem[q].hh.v.RH =
                                                            mem[p].hh.v.RH;
                                                        mem[q + 1].hh.b1 =
                                                            curi.b3;
                                                        mem[q + 3] = mem[p + 3];
                                                        mem[q + 2] = mem[p + 2];
                                                        freenode(p, NOADSIZE);
                                                    } break;
                                                    }
                                                    if (curi.b2 > 3)
                                                        return;
                                                    mem[q + 1].hh.v.RH =
                                                        MATHCHAR;
                                                    goto labmakeord20restart;
                                                }
                                            }
                                        }
                                        if (curi.b0 >= 128)
                                            return;
                                        a = a + curi.b0 + 1;
                                        curi = fontinfo[a].qqqq;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
void zmakescripts(halfword q, scaled delta) {
    makescripts_regmem halfword p, x, y, z;
    scaled shiftup, shiftdown, clr;
    smallnumber t;
    p = mem[q + 1].cint;
    if ((p >= himemmin)) {
        shiftup = 0;
        shiftdown = 0;
    } else {

        z = hpack(p, 0, ADDITIONAL);
        if (curstyle < SCRIPTSTYLE)
            t = SCRIPTSIZE;
        else
            t = SCRIPTSCRIPTSIZE;
        shiftup =
            mem[z + HEIGHTOFFSET].cint -
            fontinfo[18 + parambase[eqtb[/* @d9178@ */ 27695 + t].hh.v.RH]]
                .cint;
        shiftdown =
            mem[z + DEPTHOFFSET].cint +
            fontinfo[19 + parambase[eqtb[/* @d9180@ */ 27695 + t].hh.v.RH]]
                .cint;
        freenode(z, BOXNODESIZE);
    }
    if (mem[q + 2].hh.v.RH == EMPTY) /* comment:Construct a subscript box |x|
                                        when there is no sup */
    {
        x = cleanbox(q + 3, 2 * (curstyle / 4) /* @d9184@ */ /* @d9185@ */ + 5);
        mem[x + WIDTHOFFSET].cint =
            mem[x + WIDTHOFFSET].cint + eqtb[DIMENBASE + SCRIPTSPACECODE].cint;
        if (shiftdown <
            fontinfo[16 +
                     parambase[eqtb[/* @d9190@ */ 27695 + cursize].hh.v.RH]]
                .cint)
            shiftdown =
                fontinfo[16 +
                         parambase[eqtb[/* @d9191@ */ 27695 + cursize].hh.v.RH]]
                    .cint;
        clr = mem[x + HEIGHTOFFSET].cint -
              (abs(fontinfo[5 + parambase[eqtb[/* @d9193@ */
                                               27695 + cursize]
                                              .hh.v.RH]]
                       .cint *
                   4) /
               5);
        if (shiftdown < clr)
            shiftdown = clr;
        mem[x + 4].cint = shiftdown;
    } else {

        /* comment:Construct a superscript box |x| */ {

            x = cleanbox(q + 2,
                         2 * (curstyle / 4) /* @d9195@ */ + 4 + (curstyle % 2));
            mem[x + WIDTHOFFSET].cint = mem[x + WIDTHOFFSET].cint +
                                        eqtb[DIMENBASE + SCRIPTSPACECODE].cint;
            if (odd(curstyle))
                clr =
                    fontinfo[15 + parambase[eqtb[/* @d9200@ */ 27695 + cursize]
                                                .hh.v.RH]]
                        .cint;
            else if (curstyle < TEXTSTYLE)
                clr =
                    fontinfo[13 + parambase[eqtb[/* @d9202@ */ 27695 + cursize]
                                                .hh.v.RH]]
                        .cint;
            else
                clr =
                    fontinfo[14 + parambase[eqtb[/* @d9203@ */ 27695 + cursize]
                                                .hh.v.RH]]
                        .cint;
            if (shiftup < clr)
                shiftup = clr;
            clr = mem[x + DEPTHOFFSET].cint +
                  (abs(fontinfo[5 + parambase[eqtb[/* @d9205@ */
                                                   27695 + cursize]
                                                  .hh.v.RH]]
                           .cint) /
                   4);
            if (shiftup < clr)
                shiftup = clr;
        }
        if (mem[q + 3].hh.v.RH == EMPTY)
            mem[x + 4].cint = -(integer)shiftup;
        else /* comment:Construct a subsuperscript combination box |x|, w */ {

            y = cleanbox(q + 3,
                         2 * (curstyle / 4) /* @d9208@ */ /* @d9209@ */ + 5);
            mem[y + WIDTHOFFSET].cint = mem[y + WIDTHOFFSET].cint +
                                        eqtb[DIMENBASE + SCRIPTSPACECODE].cint;
            if (shiftdown <
                fontinfo[17 +
                         parambase[eqtb[/* @d9214@ */ 27695 + cursize].hh.v.RH]]
                    .cint)
                shiftdown =
                    fontinfo[17 + parambase[eqtb[/* @d9215@ */ 27695 + cursize]
                                                .hh.v.RH]]
                        .cint;
            clr = 4 * fontinfo[8 + parambase[eqtb[/* @d9216@ */ 27696 + cursize]
                                                 .hh.v.RH]]
                          .cint -
                  ((shiftup - mem[x + DEPTHOFFSET].cint) -
                   (mem[y + HEIGHTOFFSET].cint - shiftdown));
            if (clr > 0) {
                shiftdown = shiftdown + clr;
                clr =
                    (abs(fontinfo[5 +
                                  parambase[eqtb[/* @d9219@ */ 27695 + cursize]
                                                .hh.v.RH]]
                             .cint *
                         4) /
                     5) -
                    (shiftup - mem[x + DEPTHOFFSET].cint);
                if (clr > 0) {
                    shiftup = shiftup + clr;
                    shiftdown = shiftdown - clr;
                }
            }
            mem[x + 4].cint = delta;
            p = newkern((shiftup - mem[x + DEPTHOFFSET].cint) -
                        (mem[y + HEIGHTOFFSET].cint - shiftdown));
            mem[x].hh.v.RH = p;
            mem[p].hh.v.RH = y;
            x = vpackage(x, 0, ADDITIONAL, 1073741823L);
            mem[x + 4].cint = shiftdown;
        }
    }
    if (mem[q + 1].cint == TEXNULL)
        mem[q + 1].cint = x;
    else {

        p = mem[q + 1].cint;
        while (mem[p].hh.v.RH != TEXNULL)
            p = mem[p].hh.v.RH;
        mem[p].hh.v.RH = x;
    }
}
smallnumber zmakeleftright(halfword q, smallnumber style, scaled maxd,
                           scaled maxh) {
    register smallnumber Result;
    makeleftright_regmem scaled delta, delta1, delta2;
    curstyle = style;
    /* comment:Set up the values of |cur_size| and |cur_mu|, base */ {

        if (curstyle < SCRIPTSTYLE)
            cursize = TEXTSIZE;
        else
            cursize = 16 * ((curstyle - TEXTSTYLE) / 2);
        curmu = xovern(
            fontinfo[6 + parambase[eqtb[/* @d9228@ */ 27695 + cursize].hh.v.RH]]
                .cint,
            18);
    }
    delta2 =
        maxd +
        fontinfo[22 + parambase[eqtb[/* @d9229@ */ 27695 + cursize].hh.v.RH]]
            .cint;
    delta1 = maxh + maxd - delta2;
    if (delta2 > delta1)
        delta1 = delta2;
    delta = (delta1 / 500) * eqtb[INTBASE + DELIMITERFACTORCODE].cint;
    delta2 = delta1 + delta1 - eqtb[DIMENBASE + DELIMITERSHORTFALLCODE].cint;
    if (delta < delta2)
        delta = delta2;
    mem[q + 1].cint = vardelimiter(q + 1, cursize, delta);
    Result = mem[q].hh.b0 - (/* @d9234@ */ /* @d9235@ */ 10);
    return Result;
}
void mlisttohlist(void) {
    /* @d9236@ */ /* @d9237@ */ /* @d9238@ */ /* @d9239@ */ /* @d9240@ */
    mlisttohlist_regmem halfword mlist;
    boolean penalties;
    smallnumber style;
    smallnumber savestyle;
    halfword q;
    halfword r;
    smallnumber rtype;
    smallnumber t;
    halfword p, x, y, z;
    integer pen;
    smallnumber s;
    scaled maxh, maxd;
    scaled delta;
    mlist = curmlist;
    penalties = mlistpenalties;
    style = curstyle;
    q = mlist;
    r = TEXNULL;
    rtype = OPNOAD;
    maxh = 0;
    maxd = 0;
    /* comment:Set up the values of |cur_size| and |cur_mu|, base */ {

        if (curstyle < SCRIPTSTYLE)
            cursize = TEXTSIZE;
        else
            cursize = 16 * ((curstyle - TEXTSTYLE) / 2);
        curmu = xovern(
            fontinfo[6 + parambase[eqtb[/* @d9247@ */ 27695 + cursize].hh.v.RH]]
                .cint,
            18);
    }
    while (q != TEXNULL) /* comment:Process node-or-noad |q| as much as
                                 possible in pr */
    {

    /* comment:Do first-pass processing based on |type(q)|; |goto */
    labmlisttohlist21reswitch:
        delta = 0;
        switch (mem[q].hh.b0) {
        case BINNOAD:
            switch (rtype) {
            case BINNOAD:
            case OPNOAD:
            case RELNOAD:
            case OPENNOAD:
            case PUNCTNOAD:
            case LEFTNOAD: {
                mem[q].hh.b0 = ORDNOAD;
                goto labmlisttohlist21reswitch;
            } break;
            default:;
                break;
            }
            break;
        case RELNOAD:
        case CLOSENOAD:
        case PUNCTNOAD:
        case RIGHTNOAD: {
            /* comment:Convert \(a)a final |bin_noad| to an |ord_noad| */
            if (rtype == BINNOAD)
                mem[r].hh.b0 = ORDNOAD;
            if (mem[q].hh.b0 == RIGHTNOAD)
                goto labmlisttohlist80done_with_noad;
        } break;
        /* comment:Cases for noads that can follow a |bin_noad| */ case LEFTNOAD
            :
            goto labmlisttohlist80done_with_noad;
            break;
        case FRACTIONNOAD: {
            makefraction(q);
            goto labmlisttohlist82check_dimensions;
        } break;
        case OPNOAD: {
            delta = makeop(q);
            if (mem[q].hh.b1 == LIMITS)
                goto labmlisttohlist82check_dimensions;
        } break;
        case ORDNOAD:
            makeord(q);
            break;
        case OPENNOAD:
        case INNERNOAD:;
            break;
        case RADICALNOAD:
            makeradical(q);
            break;
        case OVERNOAD:
            makeover(q);
            break;
        case UNDERNOAD:
            makeunder(q);
            break;
        case ACCENTNOAD:
            makemathaccent(q);
            break;
        case VCENTERNOAD:
            makevcenter(q);
            break;
        /* comment:Cases for nodes that can appear in an mlist, after */
        case STYLENODE: {
            curstyle = mem[q].hh.b1;
            /* comment:Set up the values of |cur_size| and |cur_mu|, base */ {

                if (curstyle < SCRIPTSTYLE)
                    cursize = TEXTSIZE;
                else
                    cursize = 16 * ((curstyle - TEXTSTYLE) / 2);
                curmu = xovern(
                    fontinfo[6 + parambase[eqtb[/* @d9291@ */ 27695 + cursize]
                                               .hh.v.RH]]
                        .cint,
                    18);
            }
            goto labmlisttohlist81done_with_node;
        } break;
        case CHOICENODE:
            /* comment:Change this node to a style node followed by the c */ {

                switch (curstyle / 2) {
                case 0: {
                    p = mem[q + 1].hh.v.LH;
                    mem[q + 1].hh.v.LH = TEXNULL;
                } break;
                case 1: {
                    p = mem[q + 1].hh.v.RH;
                    mem[q + 1].hh.v.RH = TEXNULL;
                } break;
                case 2: {
                    p = mem[q + 2].hh.v.LH;
                    mem[q + 2].hh.v.LH = TEXNULL;
                } break;
                case 3: {
                    p = mem[q + 2].hh.v.RH;
                    mem[q + 2].hh.v.RH = TEXNULL;
                } break;
                }
                flushnodelist(mem[q + 1].hh.v.LH);
                flushnodelist(mem[q + 1].hh.v.RH);
                flushnodelist(mem[q + 2].hh.v.LH);
                flushnodelist(mem[q + 2].hh.v.RH);
                mem[q].hh.b0 = STYLENODE;
                mem[q].hh.b1 = curstyle;
                mem[q + WIDTHOFFSET].cint = 0;
                mem[q + DEPTHOFFSET].cint = 0;
                if (p != TEXNULL) {
                    z = mem[q].hh.v.RH;
                    mem[q].hh.v.RH = p;
                    while (mem[p].hh.v.RH != TEXNULL)
                        p = mem[p].hh.v.RH;
                    mem[p].hh.v.RH = z;
                }
                goto labmlisttohlist81done_with_node;
            }
            break;
        case INSNODE:
        case MARKNODE:
        case ADJUSTNODE:
        case WHATSITNODE:
        case PENALTYNODE:
        case DISCNODE:
            goto labmlisttohlist81done_with_node;
            break;
        case RULENODE: {
            if (mem[q + HEIGHTOFFSET].cint > maxh)
                maxh = mem[q + HEIGHTOFFSET].cint;
            if (mem[q + DEPTHOFFSET].cint > maxd)
                maxd = mem[q + DEPTHOFFSET].cint;
            goto labmlisttohlist81done_with_node;
        } break;
        case GLUENODE: {
            /* comment:Convert \(m)math glue to ordinary glue */
            if (mem[q].hh.b1 == MUGLUE) {
                x = mem[q + 1].hh.v.LH;
                y = mathglue(x, curmu);
                deleteglueref(x);
                mem[q + 1].hh.v.LH = y;
                mem[q].hh.b1 = NORMAL;
            } else if ((cursize != TEXTSIZE) &&
                       (mem[q].hh.b1 == CONDMATHGLUE)) {
                p = mem[q].hh.v.RH;
                if (p != TEXNULL) {

                    if ((mem[p].hh.b0 == GLUENODE) ||
                        (mem[p].hh.b0 == KERNNODE)) {
                        mem[q].hh.v.RH = mem[p].hh.v.RH;
                        mem[p].hh.v.RH = TEXNULL;
                        flushnodelist(p);
                    }
                }
            }
            goto labmlisttohlist81done_with_node;
        } break;
        case KERNNODE: {
            mathkern(q, curmu);
            goto labmlisttohlist81done_with_node;
        } break;
        default:
            confusion(/* str 'mlist1' */ 1299);
            break;
        }
        /* comment:Convert \(n)|nucleus(q)| to an hlist and attach th */
        switch (mem[q + 1].hh.v.RH) {
        case MATHCHAR:
        case MATHTEXTCHAR:
            /* comment:Create a character node |p| for |nucleus(q)|, poss */ {

                fetch(q + 1);
                if ((curi.b0 > MINQUARTERWORD)) {
                    delta = fontinfo[italicbase[curf] + (curi.b2) / 4].cint;
                    p = newcharacter(curf, curc);
                    mem[p].hh.me = mem[q].hh.me;
                    if ((mem[q + 1].hh.v.RH == MATHTEXTCHAR) &&
                        (fontinfo[SPACECODE + parambase[curf]].cint != 0))
                        delta = 0;
                    if ((mem[q + 3].hh.v.RH == EMPTY) && (delta != 0)) {
                        mem[p].hh.v.RH = newkern(delta);
                        delta = 0;
                    }
                } else
                    p = TEXNULL;
            }
            break;
        case EMPTY:
            p = TEXNULL;
            break;
        case SUBBOX:
            p = mem[q + 1].hh.v.LH;
            break;
        case SUBMLIST: {
            curmlist = mem[q + 1].hh.v.LH;
            savestyle = curstyle;
            mlistpenalties = false;
            mlisttohlist();
            curstyle = savestyle;
            /* comment:Set up the values of |cur_size| and |cur_mu|, base */ {

                if (curstyle < SCRIPTSTYLE)
                    cursize = TEXTSIZE;
                else
                    cursize = 16 * ((curstyle - TEXTSTYLE) / 2);
                curmu = xovern(
                    fontinfo[6 + parambase[eqtb[/* @d9339@ */ 27695 + cursize]
                                               .hh.v.RH]]
                        .cint,
                    18);
            }
            p = hpack(mem[memtop - 3].hh.v.RH, 0, ADDITIONAL);
        } break;
        default:
            confusion(/* str 'mlist2' */ 1300);
            break;
        }
        mem[q + 1].cint = p;
        if ((mem[q + 3].hh.v.RH == EMPTY) && (mem[q + 2].hh.v.RH == EMPTY))
            goto labmlisttohlist82check_dimensions;
        makescripts(q, delta);
    labmlisttohlist82check_dimensions:
        z = hpack(mem[q + 1].cint, 0, ADDITIONAL);
        if (mem[z + HEIGHTOFFSET].cint > maxh)
            maxh = mem[z + HEIGHTOFFSET].cint;
        if (mem[z + DEPTHOFFSET].cint > maxd)
            maxd = mem[z + DEPTHOFFSET].cint;
        freenode(z, BOXNODESIZE);
    labmlisttohlist80done_with_noad:
        r = q;
        rtype = mem[r].hh.b0;
        if (rtype == RIGHTNOAD) {
            rtype = LEFTNOAD;
            curstyle = style;
            /* comment:Set up the values of |cur_size| and |cur_mu|, base */ {

                if (curstyle < SCRIPTSTYLE)
                    cursize = TEXTSIZE;
                else
                    cursize = 16 * ((curstyle - TEXTSTYLE) / 2);
                curmu = xovern(
                    fontinfo[6 + parambase[eqtb[/* @d9359@ */ 27695 + cursize]
                                               .hh.v.RH]]
                        .cint,
                    18);
            }
        }
    labmlisttohlist81done_with_node:
        q = mem[q].hh.v.RH;
    }
    /* comment:Convert \(a)a final |bin_noad| to an |ord_noad| */
    if (rtype == BINNOAD)
        mem[r].hh.b0 = ORDNOAD;
    /* comment:Make a second pass over the mlist, removing all no */ p =
        memtop - 3;
    mem[p].hh.v.RH = TEXNULL;
    q = mlist;
    rtype = 0;
    curstyle = style;
    /* comment:Set up the values of |cur_size| and |cur_mu|, base */ {

        if (curstyle < SCRIPTSTYLE)
            cursize = TEXTSIZE;
        else
            cursize = 16 * ((curstyle - TEXTSTYLE) / 2);
        curmu = xovern(
            fontinfo[6 + parambase[eqtb[/* @d9369@ */ 27695 + cursize].hh.v.RH]]
                .cint,
            18);
    }
    while (q != TEXNULL) {

        /* comment:If node |q| is a style node, change the style and  */ t =
            ORDNOAD;
        s = NOADSIZE;
        pen = INFPENALTY;
        switch (mem[q].hh.b0) {
        case OPNOAD:
        case OPENNOAD:
        case CLOSENOAD:
        case PUNCTNOAD:
        case INNERNOAD:
            t = mem[q].hh.b0;
            break;
        case BINNOAD: {
            t = BINNOAD;
            pen = eqtb[INTBASE + BINOPPENALTYCODE].cint;
        } break;
        case RELNOAD: {
            t = RELNOAD;
            pen = eqtb[INTBASE + RELPENALTYCODE].cint;
        } break;
        case ORDNOAD:
        case VCENTERNOAD:
        case OVERNOAD:
        case UNDERNOAD:;
            break;
        case RADICALNOAD:
            s = RADICALNOADSIZE;
            break;
        case ACCENTNOAD:
            s = ACCENTNOADSIZE;
            break;
        case FRACTIONNOAD: {
            t = INNERNOAD;
            s = FRACTIONNOADSIZE;
        } break;
        case LEFTNOAD:
        case RIGHTNOAD:
            t = makeleftright(q, style, maxd, maxh);
            break;
        case STYLENODE:
            /* comment:Change the current style and |goto delete_q| */ {

                curstyle = mem[q].hh.b1;
                s = STYLENODESIZE;
                /* comment:Set up the values of |cur_size| and |cur_mu|, base */
                {

                    if (curstyle < SCRIPTSTYLE)
                        cursize = TEXTSIZE;
                    else
                        cursize = 16 * ((curstyle - TEXTSTYLE) / 2);
                    curmu = xovern(
                        fontinfo[6 +
                                 parambase[eqtb[/* @d9407@ */ 27695 + cursize]
                                               .hh.v.RH]]
                            .cint,
                        18);
                }
                goto labmlisttohlist83delete_q;
            }
            break;
        case WHATSITNODE:
        case PENALTYNODE:
        case RULENODE:
        case DISCNODE:
        case ADJUSTNODE:
        case INSNODE:
        case MARKNODE:
        case GLUENODE:
        case KERNNODE: {
            mem[p].hh.v.RH = q;
            p = q;
            q = mem[q].hh.v.RH;
            mem[p].hh.v.RH = TEXNULL;
            goto labmlisttohlist30done;
        } break;
        default:
            confusion(/* str 'mlist3' */ 1301);
            break;
        }
        /* comment:Append inter-element spacing based on |r_type| and */
        if (rtype > 0) {
            switch (strpool[rtype * 8 + t + magicoffset]) { /* str '0' */
            case 48:
                x = 0;
                break;
            /* str '1' */ case 49:
                if (curstyle < SCRIPTSTYLE)
                    x = THINMUSKIPCODE;
                else
                    x = 0;
                break;
            /* str '2' */ case 50:
                x = THINMUSKIPCODE;
                break;
            /* str '3' */ case 51:
                if (curstyle < SCRIPTSTYLE)
                    x = MEDMUSKIPCODE;
                else
                    x = 0;
                break;
            /* str '4' */ case 52:
                if (curstyle < SCRIPTSTYLE)
                    x = THICKMUSKIPCODE;
                else
                    x = 0;
                break;
            default:
                confusion(/* str 'mlist4' */ 1303);
                break;
            }
            if (x != 0) {
                y = mathglue(eqtb[GLUEBASE + x].hh.v.RH, curmu);
                z = newglue(y);
                mem[y].hh.v.RH = TEXNULL;
                mem[p].hh.v.RH = z;
                p = z;
                mem[z].hh.b1 = x + 1;
            }
        }
        /* comment:Append any |new_hlist| entries for |q|, and any ap */
        if (mem[q + 1].cint != TEXNULL) {
            mem[p].hh.v.RH = mem[q + 1].cint;
            do {
                p = mem[p].hh.v.RH;
            } while (!(mem[p].hh.v.RH == TEXNULL));
        }
        if (penalties) {

            if (mem[q].hh.v.RH != TEXNULL) {

                if (pen < INFPENALTY) {
                    rtype = mem[mem[q].hh.v.RH].hh.b0;
                    if (rtype != PENALTYNODE) {

                        if (rtype != RELNOAD) {
                            z = newpenalty(pen);
                            mem[p].hh.v.RH = z;
                            p = z;
                        }
                    }
                }
            }
        }
        if (mem[q].hh.b0 == RIGHTNOAD)
            t = OPENNOAD;
        rtype = t;
    labmlisttohlist83delete_q:
        r = q;
        q = mem[q].hh.v.RH;
        freenode(r, s);
    labmlisttohlist30done:;
    }
}





/* comment:Declare subprocedures for |line_break| */ halfword
zfiniteshrink(halfword p) {
    register halfword Result;
    finiteshrink_regmem halfword q;
    if (noshrinkerroryet) {
        noshrinkerroryet = false;
        {
            if (interaction == ERRORSTOPMODE)
                ;
            if (filelineerrorstylep)
                printfileline();
            else
                printnl(/* str '! ' */ 264);
            print(
                /* str 'Infinite glue shrinkage found in a paragraph' */ 1327);
        }
        {
            helpptr = 5;
            helpline[4] =
                /* str 'The paragraph just ended includes some glue that ' */
                1328;
            helpline[3] =
                /* str 'infinite shrinkability, e.g., `\hskip 0pt minus 1' */
                1329;
            helpline[2] =
                /* str 'Such glue doesn't belong there---it allows a para' */
                1330;
            helpline[1] =
                /* str 'of any length to fit on one line. But it's safe t' */
                1331;
            helpline[0] =
                /* str 'since the offensive shrinkability has been made f' */
                1332;
        }
        error();
    }
    q = newspec(p);
    mem[q].hh.b1 = NORMAL;
    deleteglueref(p);
    Result = q;
    return Result;
}
void zpushnode(halfword p) {
    pushnode_regmem if (hliststacklevel > MAXHLISTSTACK)
        pdferror(/* str 'push_node' */ 1333, /* str 'stack overflow' */ 1334);
    hliststack[hliststacklevel] = p;
    hliststacklevel = hliststacklevel + 1;
}
halfword popnode(void) {
    register halfword Result;
    popnode_regmem hliststacklevel = hliststacklevel - 1;
    if (hliststacklevel < 0)
        pdferror(/* str 'pop_node' */ 1335,
                 /* str 'stack underflow (internal error)' */ 1336);
    Result = hliststack[hliststacklevel];
    return Result;
}
halfword zfindprotcharleft(halfword l, boolean d) {
    register halfword Result;
    findprotcharleft_regmem halfword t;
    boolean run;
    if ((mem[l].hh.v.RH != TEXNULL) && (mem[l].hh.b0 == HLISTNODE) &&
        (mem[l + WIDTHOFFSET].cint == 0) && (mem[l + HEIGHTOFFSET].cint == 0) &&
        (mem[l + DEPTHOFFSET].cint == 0) &&
        (mem[l + LISTOFFSET].hh.v.RH == TEXNULL))
        l = mem[l].hh.v.RH;
    else if (d)
        while ((mem[l].hh.v.RH != TEXNULL) &&
               (!((l >= himemmin) || (mem[l].hh.b0 < MATHNODE))))
            l = mem[l].hh.v.RH;
    hliststacklevel = 0;
    run = true;
    do {
        t = l;
        while (run && (mem[l].hh.b0 == HLISTNODE) &&
               (mem[l + LISTOFFSET].hh.v.RH != TEXNULL)) {

            pushnode(l);
            l = mem[l + LISTOFFSET].hh.v.RH;
        }
        while (
            run &&
            (!(l >= himemmin) &&
             ((mem[l].hh.b0 == INSNODE) || (mem[l].hh.b0 == MARKNODE) ||
              (mem[l].hh.b0 == ADJUSTNODE) || (mem[l].hh.b0 == PENALTYNODE) ||
              ((mem[l].hh.b0 == WHATSITNODE) &&
               (mem[l].hh.b1 != /* @d9846@ */ 12) &&
               (mem[l].hh.b1 != /* @d9847@ */ 10)) ||
              ((mem[l].hh.b0 == DISCNODE) && (mem[l + 1].hh.v.LH == TEXNULL) &&
               (mem[l + 1].hh.v.RH == TEXNULL) && (mem[l].hh.b1 == 0)) ||
              ((mem[l].hh.b0 == MATHNODE) && (mem[/* @d9850@ */
                                                  l + 1]
                                                  .cint == 0)) ||
              ((mem[l].hh.b0 == KERNNODE) &&
               ((mem[l + WIDTHOFFSET].cint == 0) ||
                (mem[l].hh.b1 == NORMAL))) ||
              ((mem[l].hh.b0 == /* @d9854@ */
                10) &&
               (mem[l + 1].hh.v.LH == membot)) ||
              ((mem[l].hh.b0 == /* @d9855@ */
                0) &&
               (mem[l + WIDTHOFFSET].cint == 0) &&
               (mem[l + HEIGHTOFFSET].cint == 0) &&
               (mem[l + DEPTHOFFSET].cint == 0) &&
               (mem[l + LISTOFFSET].hh.v.RH == TEXNULL))))) {

            while ((mem[l].hh.v.RH == TEXNULL) && (hliststacklevel > 0)) {

                l = popnode();
            }
            if (mem[l].hh.v.RH != TEXNULL)
                l = mem[l].hh.v.RH;
            else if (hliststacklevel == 0)
                run = false;
        }
    } while (!(t == l));
    Result = l;
    return Result;
}
halfword zfindprotcharright(halfword l, halfword r) {
    register halfword Result;
    findprotcharright_regmem halfword t;
    boolean run;
    Result = TEXNULL;
    if (r == TEXNULL)
        return Result;
    hliststacklevel = 0;
    run = true;
    do {
        t = r;
        while (run && (mem[r].hh.b0 == HLISTNODE) &&
               (mem[r + LISTOFFSET].hh.v.RH != TEXNULL)) {

            pushnode(l);
            pushnode(r);
            l = mem[r + LISTOFFSET].hh.v.RH;
            r = l;
            while (mem[r].hh.v.RH != TEXNULL)
                r = mem[r].hh.v.RH;
        }
        while (
            run &&
            (!(r >= himemmin) &&
             ((mem[r].hh.b0 == INSNODE) || (mem[r].hh.b0 == MARKNODE) ||
              (mem[r].hh.b0 == ADJUSTNODE) || (mem[r].hh.b0 == PENALTYNODE) ||
              ((mem[r].hh.b0 == WHATSITNODE) &&
               (mem[r].hh.b1 != /* @d9869@ */ 12) &&
               (mem[r].hh.b1 != /* @d9870@ */ 10)) ||
              ((mem[r].hh.b0 == DISCNODE) && (mem[r + 1].hh.v.LH == TEXNULL) &&
               (mem[r + 1].hh.v.RH == TEXNULL) && (mem[r].hh.b1 == 0)) ||
              ((mem[r].hh.b0 == MATHNODE) && (mem[/* @d9873@ */
                                                  r + 1]
                                                  .cint == 0)) ||
              ((mem[r].hh.b0 == KERNNODE) &&
               ((mem[r + WIDTHOFFSET].cint == 0) ||
                (mem[r].hh.b1 == NORMAL))) ||
              ((mem[r].hh.b0 == /* @d9877@ */
                10) &&
               (mem[r + 1].hh.v.LH == membot)) ||
              ((mem[r].hh.b0 == /* @d9878@ */
                0) &&
               (mem[r + WIDTHOFFSET].cint == 0) &&
               (mem[r + HEIGHTOFFSET].cint == 0) &&
               (mem[r + DEPTHOFFSET].cint == 0) &&
               (mem[r + LISTOFFSET].hh.v.RH == TEXNULL))))) {

            while ((r == l) && (hliststacklevel > 0)) {

                r = popnode();
                l = popnode();
            }
            if ((r != l) && (r != TEXNULL))
                r = prevrightmost(l, r);
            else if ((r == l) && (hliststacklevel == 0))
                run = false;
        }
    } while (!(t == r));
    Result = r;
    return Result;
}
scaled ztotalpw(halfword q, halfword p) {
    register scaled Result;
    totalpw_regmem halfword l, r;
    integer n;
    if (mem[q + 1].hh.v.RH == TEXNULL)
        l = firstp;
    else
        l = mem[mem[q + 1].hh.v.RH + 1].hh.v.RH;
    r = prevrightmost(prevp, p);
    if ((p != TEXNULL) && (mem[p].hh.b0 == DISCNODE) &&
        (mem[p + 1].hh.v.LH != TEXNULL)) {
        r = mem[p + 1].hh.v.LH;
        while (mem[r].hh.v.RH != TEXNULL)
            r = mem[r].hh.v.RH;
    } else
        r = findprotcharright(l, r);
    if ((l != TEXNULL) && (mem[l].hh.b0 == DISCNODE)) {
        if (mem[l + 1].hh.v.RH != TEXNULL) {
            l = mem[l + 1].hh.v.RH;
            goto labtotalpw30done;
        } else {

            n = mem[l].hh.b1;
            l = mem[l].hh.v.RH;
            while (n > 0) {

                if (mem[l].hh.v.RH != TEXNULL)
                    l = mem[l].hh.v.RH;
                decr(n);
            }
        }
    }
    l = findprotcharleft(l, true);
labtotalpw30done:
    Result = charpw(l, 0) + charpw(r, 1);
    return Result;
}
void ztrybreak(integer pi, smallnumber breaktype) {
    /* @d9888@ */ /* @d9889@ */ /* @d9890@ */ /* @d9891@ */ /* @d9892@ */
    trybreak_regmem halfword r;
    scaled marginkernstretch;
    scaled marginkernshrink;
    halfword lp, rp, cp;
    halfword prevr;
    halfword oldl;
    boolean nobreakyet;
    /* comment:Other local variables for |try_break| */ halfword prevprevr;
    halfword s;
    halfword q;
    halfword v;
    integer t;
    internalfontnumber f;
    halfword l;
    boolean noderstaysactive;
    scaled linewidth;
    unsigned char fitclass;
    halfword b;
    integer d;
    boolean artificialdemerits;
    halfword savelink;
    scaled shortfall;
    scaled g;
    /* comment:Make sure that |pi| is in the proper range */
    if (abs(pi) >= INFPENALTY) {

        if (pi > 0)
            goto labtrybreak10exit;
        else
            pi = /* @d9901@ */ -10000;
    }
    nobreakyet = true;
    prevr = memtop - 7;
    oldl = 0;
    curactivewidth[1] = activewidth[1];
    curactivewidth[2] = activewidth[2];
    curactivewidth[3] = activewidth[3];
    curactivewidth[4] = activewidth[4];
    curactivewidth[5] = activewidth[5];
    curactivewidth[6] = activewidth[6];
    if (eqtb[INTBASE + PDFADJUSTSPACINGCODE].cint > 1) {
        curactivewidth[7] = activewidth[7];
        curactivewidth[8] = activewidth[8];
    }
    while (true) {

    labtrybreak22continue:
        r = mem[prevr].hh.v.RH;
        /* comment:If node |r| is of type |delta_node|, update |cur_a */
        if (mem[r].hh.b0 == DELTANODE) {
            curactivewidth[1] = curactivewidth[1] + mem[r + 1].cint;
            curactivewidth[2] = curactivewidth[2] + mem[r + 2].cint;
            curactivewidth[3] = curactivewidth[3] + mem[r + 3].cint;
            curactivewidth[4] = curactivewidth[4] + mem[r + 4].cint;
            curactivewidth[5] = curactivewidth[5] + mem[r + 5].cint;
            curactivewidth[6] = curactivewidth[6] + mem[r + 6].cint;
            if (eqtb[INTBASE + PDFADJUSTSPACINGCODE].cint > 1) {
                curactivewidth[7] = curactivewidth[7] + mem[r + 7].cint;
                curactivewidth[8] = curactivewidth[8] + mem[r + 8].cint;
            }
            prevprevr = prevr;
            prevr = r;
            goto labtrybreak22continue;
        }
        /* comment:If a line number class has ended, create new activ */ {

            l = mem[r + 1].hh.v.LH;
            if (l > oldl) {
                if ((minimumdemerits < 1073741823L) &&
                    ((oldl != easyline) ||
                     (r == memtop - 7))) /* comment:Create new active nodes for
                                            the best feasible brea */
                {
                    if (nobreakyet) /* comment:Compute the values of
                                       |break_width| */
                    {
                        nobreakyet = false;
                        breakwidth[1] = background[1];
                        breakwidth[2] = background[2];
                        breakwidth[3] = background[3];
                        breakwidth[4] = background[4];
                        breakwidth[5] = background[5];
                        breakwidth[6] = background[6];
                        if (eqtb[INTBASE + PDFADJUSTSPACINGCODE].cint > 1) {
                            breakwidth[7] = background[7];
                            breakwidth[8] = background[8];
                        }
                        s = curp;
                        if (breaktype > UNHYPHENATED) {

                            if (curp != TEXNULL) /* comment:Compute the
                                                         discretionary
                                                         |break_width| values */
                            {
                                t = mem[curp].hh.b1;
                                v = curp;
                                s = mem[curp + 1].hh.v.RH;
                                while (t > 0) {

                                    decr(t);
                                    v = mem[v].hh.v.RH;
                                    /* comment:Subtract the width of node |v|
                                     * from |break_width| */
                                    if ((v >= himemmin)) {
                                        f = mem[v].hh.b0;
                                        breakwidth[1] =
                                            breakwidth[1] -
                                            fontinfo[widthbase[f] +
                                                     fontinfo[charbase[f] +
                                                              effectivechar(
                                                                  true, f,
                                                                  mem[v].hh.b1)]
                                                         .qqqq.b0]
                                                .cint;
                                        if ((eqtb[/* @d9918@ */ /* @d9919@ */
                                                  29356]
                                                 .cint > 1) &&
                                            checkexpandpars(f)) {
                                            prevcharp = v;
                                            breakwidth[7] =
                                                breakwidth[7] -
                                                charstretch(f, mem[v].hh.b1);
                                            breakwidth[8] =
                                                breakwidth[8] -
                                                charshrink(f, mem[v].hh.b1);
                                        }
                                    } else
                                        switch (mem[v].hh.b0) {
                                        case LIGATURENODE: {
                                            f = mem[v + 1].hh.b0;
                                            breakwidth[1] =
                                                breakwidth[1] -
                                                fontinfo
                                                    [widthbase[f] +
                                                     fontinfo[charbase[f] +
                                                              effectivechar(
                                                                  true, f,
                                                                  mem[v + 1]
                                                                      .hh.b1)]
                                                         .qqqq.b0]
                                                        .cint;
                                            if ((eqtb[/* @d9921@ */
                                                      /* @d9922@ */ 29356]
                                                     .cint > 1) &&
                                                checkexpandpars(f)) {
                                                prevcharp = v;
                                                breakwidth[7] =
                                                    breakwidth[7] -
                                                    charstretch(
                                                        f, mem[v + 1].hh.b1);
                                                breakwidth[8] =
                                                    breakwidth[8] -
                                                    charshrink(
                                                        f, mem[v + 1].hh.b1);
                                            }
                                        } break;
                                        case HLISTNODE:
                                        case VLISTNODE:
                                        case RULENODE:
                                        case KERNNODE: {
                                            breakwidth[1] =
                                                breakwidth[1] -
                                                mem[v + WIDTHOFFSET].cint;
                                            if ((mem[v].hh.b0 == KERNNODE) &&
                                                (eqtb[/* @d9929@ */
                                                      /* @d9930@ */ 29356]
                                                     .cint > 1) &&
                                                (mem[v].hh.b1 == NORMAL)) {
                                                breakwidth[7] = breakwidth[7] -
                                                                kernstretch(v);
                                                breakwidth[8] = breakwidth[8] -
                                                                kernshrink(v);
                                            }
                                        } break;
                                        default:
                                            confusion(/* str 'disc1' */ 1337);
                                            break;
                                        }
                                }
                                while (s != TEXNULL) {

                                    /* comment:Add the width of node |s| to
                                     * |break_width| */
                                    if ((s >= himemmin)) {
                                        f = mem[s].hh.b0;
                                        breakwidth[1] =
                                            breakwidth[1] +
                                            fontinfo[widthbase[f] +
                                                     fontinfo[charbase[f] +
                                                              effectivechar(
                                                                  true, f,
                                                                  mem[s].hh.b1)]
                                                         .qqqq.b0]
                                                .cint;
                                        if ((eqtb[/* @d9934@ */ /* @d9935@ */
                                                  29356]
                                                 .cint > 1) &&
                                            checkexpandpars(f)) {
                                            prevcharp = s;
                                            breakwidth[7] =
                                                breakwidth[7] +
                                                charstretch(f, mem[s].hh.b1);
                                            breakwidth[8] =
                                                breakwidth[8] +
                                                charshrink(f, mem[s].hh.b1);
                                        }
                                    } else
                                        switch (mem[s].hh.b0) {
                                        case LIGATURENODE: {
                                            f = mem[s + 1].hh.b0;
                                            breakwidth[1] =
                                                breakwidth[1] +
                                                fontinfo
                                                    [widthbase[f] +
                                                     fontinfo[charbase[f] +
                                                              effectivechar(
                                                                  true, f,
                                                                  mem[s + 1]
                                                                      .hh.b1)]
                                                         .qqqq.b0]
                                                        .cint;
                                            if ((eqtb[/* @d9937@ */
                                                      /* @d9938@ */ 29356]
                                                     .cint > 1) &&
                                                checkexpandpars(f)) {
                                                prevcharp = s;
                                                breakwidth[7] =
                                                    breakwidth[7] +
                                                    charstretch(
                                                        f, mem[s + 1].hh.b1);
                                                breakwidth[8] =
                                                    breakwidth[8] +
                                                    charshrink(
                                                        f, mem[s + 1].hh.b1);
                                            }
                                        } break;
                                        case HLISTNODE:
                                        case VLISTNODE:
                                        case RULENODE:
                                        case KERNNODE: {
                                            breakwidth[1] =
                                                breakwidth[1] +
                                                mem[s + WIDTHOFFSET].cint;
                                            if ((mem[s].hh.b0 == KERNNODE) &&
                                                (eqtb[/* @d9945@ */
                                                      /* @d9946@ */ 29356]
                                                     .cint > 1) &&
                                                (mem[s].hh.b1 == NORMAL)) {
                                                breakwidth[7] = breakwidth[7] +
                                                                kernstretch(s);
                                                breakwidth[8] = breakwidth[8] +
                                                                kernshrink(s);
                                            }
                                        } break;
                                        default:
                                            confusion(/* str 'disc2' */ 1338);
                                            break;
                                        }
                                    s = mem[s].hh.v.RH;
                                }
                                breakwidth[1] = breakwidth[1] + discwidth[1];
                                if (eqtb[INTBASE + PDFADJUSTSPACINGCODE].cint >
                                    1) {
                                    breakwidth[7] =
                                        breakwidth[7] + discwidth[7];
                                    breakwidth[8] =
                                        breakwidth[8] + discwidth[8];
                                }
                                if (mem[curp + 1].hh.v.RH == TEXNULL)
                                    s = mem[v].hh.v.RH;
                            }
                        }
                        while (s != TEXNULL) {

                            if ((s >= himemmin))
                                goto labtrybreak30done;
                            switch (mem[s].hh.b0) {
                            case GLUENODE:
                                /* comment:Subtract glue from |break_width| */ {

                                    v = mem[s + 1].hh.v.LH;
                                    breakwidth[1] = breakwidth[1] -
                                                    mem[v + WIDTHOFFSET].cint;
                                    breakwidth[2 + mem[v].hh.b0] =
                                        breakwidth[2 + mem[v].hh.b0] -
                                        mem[v + 2].cint;
                                    breakwidth[6] =
                                        breakwidth[6] - mem[v + 3].cint;
                                }
                                break;
                            case PENALTYNODE:;
                                break;
                            case MATHNODE:
                                breakwidth[1] =
                                    breakwidth[1] - mem[s + WIDTHOFFSET].cint;
                                break;
                            case KERNNODE:
                                if (mem[s].hh.b1 != EXPLICIT)
                                    goto labtrybreak30done;
                                else
                                    breakwidth[1] = breakwidth[1] -
                                                    mem[s + WIDTHOFFSET].cint;
                                break;
                            default:
                                goto labtrybreak30done;
                                break;
                            }
                            s = mem[s].hh.v.RH;
                        }
                    labtrybreak30done:;
                    }
                    /* comment:Insert a delta node to prepare for breaks at
                     * |cur_ */
                    if (mem[prevr].hh.b0 == DELTANODE) {
                        mem[prevr + 1].cint = mem[prevr + 1].cint -
                                              curactivewidth[1] + breakwidth[1];
                        mem[prevr + 2].cint = mem[prevr + 2].cint -
                                              curactivewidth[2] + breakwidth[2];
                        mem[prevr + 3].cint = mem[prevr + 3].cint -
                                              curactivewidth[3] + breakwidth[3];
                        mem[prevr + 4].cint = mem[prevr + 4].cint -
                                              curactivewidth[4] + breakwidth[4];
                        mem[prevr + 5].cint = mem[prevr + 5].cint -
                                              curactivewidth[5] + breakwidth[5];
                        mem[prevr + 6].cint = mem[prevr + 6].cint -
                                              curactivewidth[6] + breakwidth[6];
                        if (eqtb[INTBASE + PDFADJUSTSPACINGCODE].cint > 1) {
                            mem[prevr + 7].cint = mem[prevr + 7].cint -
                                                  curactivewidth[7] +
                                                  breakwidth[7];
                            mem[prevr + 8].cint = mem[prevr + 8].cint -
                                                  curactivewidth[8] +
                                                  breakwidth[8];
                        }
                    } else if (prevr == memtop - 7) {
                        activewidth[1] = breakwidth[1];
                        activewidth[2] = breakwidth[2];
                        activewidth[3] = breakwidth[3];
                        activewidth[4] = breakwidth[4];
                        activewidth[5] = breakwidth[5];
                        activewidth[6] = breakwidth[6];
                        if (eqtb[INTBASE + PDFADJUSTSPACINGCODE].cint > 1) {
                            activewidth[7] = breakwidth[7];
                            activewidth[8] = breakwidth[8];
                        }
                    } else {

                        q = getnode(DELTANODESIZE);
                        mem[q].hh.v.RH = r;
                        mem[q].hh.b0 = DELTANODE;
                        mem[q].hh.b1 = 0;
                        mem[q + 1].cint = breakwidth[1] - curactivewidth[1];
                        mem[q + 2].cint = breakwidth[2] - curactivewidth[2];
                        mem[q + 3].cint = breakwidth[3] - curactivewidth[3];
                        mem[q + 4].cint = breakwidth[4] - curactivewidth[4];
                        mem[q + 5].cint = breakwidth[5] - curactivewidth[5];
                        mem[q + 6].cint = breakwidth[6] - curactivewidth[6];
                        if (eqtb[INTBASE + PDFADJUSTSPACINGCODE].cint > 1) {
                            mem[q + 7].cint = breakwidth[7] - curactivewidth[7];
                            mem[q + 8].cint = breakwidth[8] - curactivewidth[8];
                        }
                        mem[prevr].hh.v.RH = q;
                        prevprevr = prevr;
                        prevr = q;
                    }
                    if (abs(eqtb[INTBASE + ADJDEMERITSCODE].cint) >=
                        1073741823L - minimumdemerits)
                        minimumdemerits = 1073741822L;
                    else
                        minimumdemerits =
                            minimumdemerits +
                            abs(eqtb[INTBASE + ADJDEMERITSCODE].cint);
                    {
                        register integer for_end;
                        fitclass = VERYLOOSEFIT;
                        for_end = TIGHTFIT;
                        if (fitclass <= for_end)
                            do {
                                if (minimaldemerits[fitclass] <=
                                    minimumdemerits) /* comment:Insert a new
                                                        active node from
                                                        |best_place[fit_clas */
                                {
                                    q = getnode(PASSIVENODESIZE);
                                    mem[q].hh.v.RH = passive;
                                    passive = q;
                                    mem[q + 1].hh.v.RH = curp;
                                    ;
#ifdef STAT
                                    incr(passnumber);
                                    mem[q].hh.v.LH = passnumber;
#endif /* STAT */
                                    mem[q + 1].hh.v.LH = bestplace[fitclass];
                                    q = getnode(activenodesize);
                                    mem[q + 1].hh.v.RH = passive;
                                    mem[q + 1].hh.v.LH =
                                        bestplline[fitclass] + 1;
                                    mem[q].hh.b1 = fitclass;
                                    mem[q].hh.b0 = breaktype;
                                    mem[q + 2].cint = minimaldemerits[fitclass];
                                    if (dolastlinefit) /* comment:Store
                                                          \(a)additional data in
                                                          the new active node */
                                    {
                                        mem[q + 3].cint = bestplshort[fitclass];
                                        mem[q + 4].cint = bestplglue[fitclass];
                                    }
                                    mem[q].hh.v.RH = r;
                                    mem[prevr].hh.v.RH = q;
                                    prevr = q;
                                    ;
#ifdef STAT
                                    if (eqtb[INTBASE + TRACINGPARAGRAPHSCODE]
                                            .cint >
                                        0) /* comment:Print a symbolic
                                              description of the new break node
                                            */
                                    {
                                        printnl(/* str '@@@@' */ 1339);
                                        printint(mem[passive].hh.v.LH);
                                        print(/* str '' */ 1340);
                                        printint(mem[q + 1].hh.v.LH - 1);
                                        printchar(/* str '.' */ 46);
                                        printint(fitclass);
                                        if (breaktype == HYPHENATED)
                                            printchar(/* str '-' */ 45);
                                        print(/* str ' t=' */ 1341);
                                        printint(mem[q + 2].cint);
                                        if (dolastlinefit) /* comment:Print
                                                              additional data in
                                                              the new active
                                                              node */
                                        {
                                            print(/* str ' s=' */ 2067);
                                            printscaled(mem[q + 3].cint);
                                            if (curp == TEXNULL)
                                                print(/* str ' a=' */ 2068);
                                            else
                                                print(/* str ' g=' */ 1411);
                                            printscaled(mem[q + 4].cint);
                                        }
                                        print(/* str ' -> @@@@' */ 1342);
                                        if (mem[passive + 1].hh.v.LH == TEXNULL)
                                            printchar(/* str '0' */ 48);
                                        else
                                            printint(
                                                mem[mem[passive + 1].hh.v.LH]
                                                    .hh.v.LH);
                                    }
#endif /* STAT */
                                }
                                minimaldemerits[fitclass] = 1073741823L;
                            } while (fitclass++ < for_end);
                    }
                    minimumdemerits = 1073741823L;
                    /* comment:Insert a delta node to prepare for the next
                     * active */
                    if (r != memtop - 7) {
                        q = getnode(DELTANODESIZE);
                        mem[q].hh.v.RH = r;
                        mem[q].hh.b0 = DELTANODE;
                        mem[q].hh.b1 = 0;
                        mem[q + 1].cint = curactivewidth[1] - breakwidth[1];
                        mem[q + 2].cint = curactivewidth[2] - breakwidth[2];
                        mem[q + 3].cint = curactivewidth[3] - breakwidth[3];
                        mem[q + 4].cint = curactivewidth[4] - breakwidth[4];
                        mem[q + 5].cint = curactivewidth[5] - breakwidth[5];
                        mem[q + 6].cint = curactivewidth[6] - breakwidth[6];
                        if (eqtb[INTBASE + PDFADJUSTSPACINGCODE].cint > 1) {
                            mem[q + 7].cint = curactivewidth[7] - breakwidth[7];
                            mem[q + 8].cint = curactivewidth[8] - breakwidth[8];
                        }
                        mem[prevr].hh.v.RH = q;
                        prevprevr = prevr;
                        prevr = q;
                    }
                }
                if (r == memtop - 7)
                    goto labtrybreak10exit;
                /* comment:Compute the new line width */ if (l > easyline) {
                    linewidth = secondwidth;
                    oldl = 2147483646L;
                } else {

                    oldl = l;
                    if (l > lastspecialline)
                        linewidth = secondwidth;
                    else if (eqtb[PARSHAPELOC].hh.v.RH == TEXNULL)
                        linewidth = firstwidth;
                    else
                        linewidth = mem[eqtb[PARSHAPELOC].hh.v.RH + 2 * l].cint;
                }
            }
        }
        /* comment:Consider the demerits for a line from |r| to |cur_ */ {

            artificialdemerits = false;
            shortfall = linewidth - curactivewidth[1];
            if (eqtb[INTBASE + PDFPROTRUDECHARSCODE].cint > 1)
                shortfall = shortfall + totalpw(r, curp);
            if ((eqtb[INTBASE + PDFADJUSTSPACINGCODE].cint > 1) &&
                (shortfall != 0)) {
                marginkernstretch = 0;
                marginkernshrink = 0;
                if (eqtb[INTBASE + PDFPROTRUDECHARSCODE].cint >
                    1) /* comment:Calculate variations of marginal kerns */
                {
                    lp = lastleftmostchar;
                    rp = lastrightmostchar;
                    {
                        cp = avail;
                        if (cp == TEXNULL)
                            cp = getavail();
                        else {

                            avail = mem[cp].hh.v.RH;
                            mem[cp].hh.v.RH = TEXNULL;
                            mem[cp].hh.me = curchrsig;
                            ;
#ifdef STAT
                            incr(dynused);
#endif /* STAT */
                        }
                    }
                    if (lp != TEXNULL) {
                        mem[cp].hh.b1 = mem[lp].hh.b1;
                        mem[cp].hh.b0 = mem[lp].hh.b0;
                        dosubstfont(cp, 1000);
                        if (mem[cp].hh.b0 != mem[lp].hh.b0)
                            marginkernstretch = marginkernstretch +
                                                charpw(lp, 0) - charpw(cp, 0);
                        mem[cp].hh.b0 = mem[lp].hh.b0;
                        dosubstfont(cp, -1000);
                        if (mem[cp].hh.b0 != mem[lp].hh.b0)
                            marginkernshrink = marginkernshrink +
                                               charpw(cp, 0) - charpw(lp, 0);
                    }
                    if (rp != TEXNULL) {
                        mem[cp].hh.b1 = mem[rp].hh.b1;
                        mem[cp].hh.b0 = mem[rp].hh.b0;
                        dosubstfont(cp, 1000);
                        if (mem[cp].hh.b0 != mem[rp].hh.b0)
                            marginkernstretch = marginkernstretch +
                                                charpw(rp, 0) - charpw(cp, 0);
                        mem[cp].hh.b0 = mem[rp].hh.b0;
                        dosubstfont(cp, -1000);
                        if (mem[cp].hh.b0 != mem[rp].hh.b0)
                            marginkernshrink = marginkernshrink +
                                               charpw(cp, 0) - charpw(rp, 0);
                    }
                    {
                        mem[cp].hh.v.RH = avail;
                        avail = cp;
                        mem[cp].hh.me = 0;
                        ;
#ifdef STAT
                        decr(dynused);
#endif /* STAT */
                    }
                }
                if ((shortfall > 0) &&
                    ((curactivewidth[7] + marginkernstretch) > 0)) {
                    if ((curactivewidth[7] + marginkernstretch) > shortfall)
                        shortfall = ((curactivewidth[7] + marginkernstretch) /
                                     (maxstretchratio / curfontstep)) /
                                    2;
                    else
                        shortfall =
                            shortfall - (curactivewidth[7] + marginkernstretch);
                } else if ((shortfall < 0) &&
                           ((curactivewidth[8] + marginkernshrink) > 0)) {
                    if ((curactivewidth[8] + marginkernshrink) >
                        -(integer)shortfall)
                        shortfall =
                            -(integer)((curactivewidth[8] + marginkernshrink) /
                                       (maxshrinkratio / curfontstep)) /
                            2;
                    else
                        shortfall =
                            shortfall + (curactivewidth[8] + marginkernshrink);
                }
            }
            if (shortfall > 0) /* comment:Set the value of |b| to the badness
                                  for stretching */
            {

                if ((curactivewidth[3] != 0) || (curactivewidth[4] != 0) ||
                    (curactivewidth[5] != 0)) {
                    if (dolastlinefit) {
                        if (curp ==
                            TEXNULL) /* comment:Perform computations for
                                             last line and |goto found */
                        {
                            if ((mem[r + 3].cint == 0) ||
                                (mem[r + 4].cint <= 0))
                                goto labtrybreak45not_found;
                            if ((curactivewidth[3] != fillwidth[0]) ||
                                (curactivewidth[4] != fillwidth[1]) ||
                                (curactivewidth[5] != fillwidth[2]))
                                goto labtrybreak45not_found;
                            if (mem[r + 3].cint > 0)
                                g = curactivewidth[2];
                            else
                                g = curactivewidth[6];
                            if (g <= 0)
                                goto labtrybreak45not_found;
                            aritherror = false;
                            g = fract(g, mem[r + 3].cint, mem[r + 4].cint,
                                      1073741823L);
                            if (eqtb[INTBASE + LASTLINEFITCODE].cint < 1000)
                                g = fract(g,
                                          eqtb[INTBASE + LASTLINEFITCODE].cint,
                                          1000, 1073741823L);
                            if (aritherror) {

                                if (mem[r + 3].cint > 0)
                                    g = 1073741823L;
                                else
                                    g = -1073741823L;
                            }
                            if (g > 0) /* comment:Set the value of |b| to the
                                          badness of the last li */
                            {
                                if (g > shortfall)
                                    g = shortfall;
                                if (g > 7230584L) {

                                    if (curactivewidth[2] < 1663497L) {
                                        b = INFBAD;
                                        fitclass = VERYLOOSEFIT;
                                        goto labtrybreak40found;
                                    }
                                }
                                b = badness(g, curactivewidth[2]);
                                if (b > 12) {

                                    if (b > 99)
                                        fitclass = VERYLOOSEFIT;
                                    else
                                        fitclass = LOOSEFIT;
                                } else
                                    fitclass = DECENTFIT;
                                goto labtrybreak40found;
                            } else if (g < 0) /* comment:Set the value of |b| to
                                                 the badness of the last li */
                            {
                                if (-(integer)g > curactivewidth[6])
                                    g = -(integer)curactivewidth[6];
                                b = badness(-(integer)g, curactivewidth[6]);
                                if (b > 12)
                                    fitclass = TIGHTFIT;
                                else
                                    fitclass = DECENTFIT;
                                goto labtrybreak40found;
                            }
                        labtrybreak45not_found:;
                        }
                        shortfall = 0;
                    }
                    b = 0;
                    fitclass = DECENTFIT;
                } else {

                    if (shortfall > 7230584L) {

                        if (curactivewidth[2] < 1663497L) {
                            b = INFBAD;
                            fitclass = VERYLOOSEFIT;
                            goto labtrybreak31done1;
                        }
                    }
                    b = badness(shortfall, curactivewidth[2]);
                    if (b > 12) {

                        if (b > 99)
                            fitclass = VERYLOOSEFIT;
                        else
                            fitclass = LOOSEFIT;
                    } else
                        fitclass = DECENTFIT;
                labtrybreak31done1:;
                }
            } else /* comment:Set the value of |b| to the badness for shrinking
                    */
            {

                if (-(integer)shortfall > curactivewidth[6])
                    b = /* @d10048@ */ 10001;
                else
                    b = badness(-(integer)shortfall, curactivewidth[6]);
                if (b > 12)
                    fitclass = TIGHTFIT;
                else
                    fitclass = DECENTFIT;
            }
            if (dolastlinefit) /* comment:Adjust \(t)the additional data for
                                  last line */
            {
                if (curp == TEXNULL)
                    shortfall = 0;
                if (shortfall > 0)
                    g = curactivewidth[2];
                else if (shortfall < 0)
                    g = curactivewidth[6];
                else
                    g = 0;
            }
        labtrybreak40found:
            if ((b > INFBAD) ||
                (pi == /* @d10054@ */ -10000)) /* comment:Prepare to
                                                  deactivate node~|r|, and
                                                  |goto deactiva */
            {
                if (finalpass && (minimumdemerits == 1073741823L) &&
                    (mem[r].hh.v.RH == memtop - 7) && (prevr == memtop - 7))
                    artificialdemerits = true;
                else if (b > threshold)
                    goto labtrybreak60deactivate;
                noderstaysactive = false;
            } else {

                prevr = r;
                if (b > threshold)
                    goto labtrybreak22continue;
                noderstaysactive = true;
            }
            /* comment:Record a new feasible break */ if (artificialdemerits)
                d = 0;
            else /* comment:Compute the demerits, |d|, from |r| to |cur_p| */ {

                d = eqtb[INTBASE + LINEPENALTYCODE].cint + b;
                if (abs(d) >= 10000)
                    d = 100000000L;
                else
                    d = d * d;
                if (pi != 0) {

                    if (pi > 0)
                        d = d + pi * pi;
                    else if (pi > /* @d10062@ */ -10000)
                        d = d - pi * pi;
                }
                if ((breaktype == HYPHENATED) && (mem[r].hh.b0 == HYPHENATED)) {

                    if (curp != TEXNULL)
                        d = d + eqtb[INTBASE + DOUBLEHYPHENDEMERITSCODE].cint;
                    else
                        d = d + eqtb[INTBASE + FINALHYPHENDEMERITSCODE].cint;
                }
                if (abs(fitclass - mem[r].hh.b1) > 1)
                    d = d + eqtb[INTBASE + ADJDEMERITSCODE].cint;
            };
#ifdef STAT
            if (eqtb[INTBASE + TRACINGPARAGRAPHSCODE].cint >
                0) /* comment:Print a symbolic description of this feasible brea
                    */
            {
                if (printednode != curp) /* comment:Print the list between
                                            |printed_node| and |cur_p|, */
                {
                    printnl(/* str '' */ 345);
                    if (curp == TEXNULL)
                        shortdisplay(mem[printednode].hh.v.RH);
                    else {

                        savelink = mem[curp].hh.v.RH;
                        mem[curp].hh.v.RH = TEXNULL;
                        printnl(/* str '' */ 345);
                        shortdisplay(mem[printednode].hh.v.RH);
                        mem[curp].hh.v.RH = savelink;
                    }
                    printednode = curp;
                }
                printnl(/* str '@@' */ 64);
                if (curp == TEXNULL)
                    printesc(/* str 'par' */ 681);
                else if (mem[curp].hh.b0 != GLUENODE) {
                    if (mem[curp].hh.b0 == PENALTYNODE)
                        printesc(/* str 'penalty' */ 611);
                    else if (mem[curp].hh.b0 == DISCNODE)
                        printesc(/* str 'discretionary' */ 357);
                    else if (mem[curp].hh.b0 == KERNNODE)
                        printesc(/* str 'kern' */ 322);
                    else
                        printesc(/* str 'math' */ 351);
                }
                print(/* str ' via @@@@' */ 1343);
                if (mem[r + 1].hh.v.RH == TEXNULL)
                    printchar(/* str '0' */ 48);
                else
                    printint(mem[mem[r + 1].hh.v.RH].hh.v.LH);
                print(/* str ' b=' */ 1344);
                if (b > INFBAD)
                    printchar(/* str '' */ 42);
                else
                    printint(b);
                print(/* str ' p=' */ 1345);
                printint(pi);
                print(/* str ' d=' */ 1346);
                if (artificialdemerits)
                    printchar(/* str '' */ 42);
                else
                    printint(d);
            }
#endif /* STAT */
            d = d + mem[r + 2].cint;
            if (d <= minimaldemerits[fitclass]) {
                minimaldemerits[fitclass] = d;
                bestplace[fitclass] = mem[r + 1].hh.v.RH;
                bestplline[fitclass] = l;
                if (dolastlinefit) /* comment:Store \(a)additional data for this
                                      feasible break */
                {
                    bestplshort[fitclass] = shortfall;
                    bestplglue[fitclass] = g;
                }
                if (d < minimumdemerits)
                    minimumdemerits = d;
            }
            if (noderstaysactive)
                goto labtrybreak22continue;
        labtrybreak60deactivate: /* comment:Deactivate node |r| */
            mem[prevr].hh.v.RH = mem[r].hh.v.RH;
            freenode(r, activenodesize);
            if (prevr == memtop - 7) /* comment:Update the active widths, since
                                        the first active n */
            {
                r = mem[memtop - 7].hh.v.RH;
                if (mem[r].hh.b0 == DELTANODE) {
                    activewidth[1] = activewidth[1] + mem[r + 1].cint;
                    activewidth[2] = activewidth[2] + mem[r + 2].cint;
                    activewidth[3] = activewidth[3] + mem[r + 3].cint;
                    activewidth[4] = activewidth[4] + mem[r + 4].cint;
                    activewidth[5] = activewidth[5] + mem[r + 5].cint;
                    activewidth[6] = activewidth[6] + mem[r + 6].cint;
                    if (eqtb[INTBASE + PDFADJUSTSPACINGCODE].cint > 1) {
                        activewidth[7] = activewidth[7] + mem[r + 7].cint;
                        activewidth[8] = activewidth[8] + mem[r + 8].cint;
                    }
                    curactivewidth[1] = activewidth[1];
                    curactivewidth[2] = activewidth[2];
                    curactivewidth[3] = activewidth[3];
                    curactivewidth[4] = activewidth[4];
                    curactivewidth[5] = activewidth[5];
                    curactivewidth[6] = activewidth[6];
                    if (eqtb[INTBASE + PDFADJUSTSPACINGCODE].cint > 1) {
                        curactivewidth[7] = activewidth[7];
                        curactivewidth[8] = activewidth[8];
                    }
                    mem[memtop - 7].hh.v.RH = mem[r].hh.v.RH;
                    freenode(r, DELTANODESIZE);
                }
            } else if (mem[prevr].hh.b0 == DELTANODE) {
                r = mem[prevr].hh.v.RH;
                if (r == memtop - 7) {
                    curactivewidth[1] = curactivewidth[1] - mem[prevr + 1].cint;
                    curactivewidth[2] = curactivewidth[2] - mem[prevr + 2].cint;
                    curactivewidth[3] = curactivewidth[3] - mem[prevr + 3].cint;
                    curactivewidth[4] = curactivewidth[4] - mem[prevr + 4].cint;
                    curactivewidth[5] = curactivewidth[5] - mem[prevr + 5].cint;
                    curactivewidth[6] = curactivewidth[6] - mem[prevr + 6].cint;
                    if (eqtb[INTBASE + PDFADJUSTSPACINGCODE].cint > 1) {
                        curactivewidth[7] =
                            curactivewidth[7] - mem[prevr + 7].cint;
                        curactivewidth[8] =
                            curactivewidth[8] - mem[prevr + 8].cint;
                    }
                    mem[prevprevr].hh.v.RH = memtop - 7;
                    freenode(prevr, DELTANODESIZE);
                    prevr = prevprevr;
                } else if (mem[r].hh.b0 == DELTANODE) {
                    curactivewidth[1] = curactivewidth[1] + mem[r + 1].cint;
                    curactivewidth[2] = curactivewidth[2] + mem[r + 2].cint;
                    curactivewidth[3] = curactivewidth[3] + mem[r + 3].cint;
                    curactivewidth[4] = curactivewidth[4] + mem[r + 4].cint;
                    curactivewidth[5] = curactivewidth[5] + mem[r + 5].cint;
                    curactivewidth[6] = curactivewidth[6] + mem[r + 6].cint;
                    if (eqtb[INTBASE + PDFADJUSTSPACINGCODE].cint > 1) {
                        curactivewidth[7] = curactivewidth[7] + mem[r + 7].cint;
                        curactivewidth[8] = curactivewidth[8] + mem[r + 8].cint;
                    }
                    mem[prevr + 1].cint = mem[prevr + 1].cint + mem[r + 1].cint;
                    mem[prevr + 2].cint = mem[prevr + 2].cint + mem[r + 2].cint;
                    mem[prevr + 3].cint = mem[prevr + 3].cint + mem[r + 3].cint;
                    mem[prevr + 4].cint = mem[prevr + 4].cint + mem[r + 4].cint;
                    mem[prevr + 5].cint = mem[prevr + 5].cint + mem[r + 5].cint;
                    mem[prevr + 6].cint = mem[prevr + 6].cint + mem[r + 6].cint;
                    if (eqtb[INTBASE + PDFADJUSTSPACINGCODE].cint > 1) {
                        mem[prevr + 7].cint =
                            mem[prevr + 7].cint + mem[r + 7].cint;
                        mem[prevr + 8].cint =
                            mem[prevr + 8].cint + mem[r + 8].cint;
                    }
                    mem[prevr].hh.v.RH = mem[r].hh.v.RH;
                    freenode(r, DELTANODESIZE);
                }
            }
        }
    }
labtrybreak10exit:;
#ifdef STAT
    /* comment:Update the value of |printed_node| for symbolic di */
    if (curp == printednode) {

        if (curp != TEXNULL) {

            if (mem[curp].hh.b0 == DISCNODE) {
                t = mem[curp].hh.b1;
                while (t > 0) {

                    decr(t);
                    printednode = mem[printednode].hh.v.RH;
                }
            }
#endif /* STAT */
        }
    }
}
void zpostlinebreak(boolean d) {
    postlinebreak_regmem halfword q, r, s;
    halfword p, k;
    scaled w;
    boolean gluebreak;
    halfword ptmp;
    boolean discbreak;
    boolean postdiscbreak;
    scaled curwidth;
    scaled curindent;
    quarterword t;
    integer pen;
    halfword curline;
    halfword LRptr;
    LRptr = curlist.eTeXauxfield;
    /* comment:Reverse the links of the relevant passive nodes, s */ q =
        mem[bestbet + 1].hh.v.RH;
    curp = TEXNULL;
    do {
        r = q;
        q = mem[q + 1].hh.v.LH;
        mem[r + 1].hh.v.LH = curp;
        curp = r;
    } while (!(q == TEXNULL));
    curline = curlist.pgfield + 1;
    do {
        /* comment:Justify the line ending at breakpoint |cur_p|, and */
        if ((eqtb[ETEXSTATEBASE + TEXXETCODE].cint >
             0)) /* comment:Insert LR nodes at the beginning of the current li
                  */
        {
            q = mem[memtop - 3].hh.v.RH;
            if (LRptr != TEXNULL) {
                tempptr = LRptr;
                r = q;
                do {
                    s = newmath(
                        0, (mem[tempptr].hh.v.LH /* @d10126@ */ /* @d10127@ */ -
                            1));
                    mem[s].hh.v.RH = r;
                    r = s;
                    tempptr = mem[tempptr].hh.v.RH;
                } while (!(tempptr == TEXNULL));
                mem[memtop - 3].hh.v.RH = r;
            }
            while (q != mem[curp + 1].hh.v.RH) {

                if (!(q >= himemmin)) {

                    if (mem[q].hh.b0 ==
                        MATHNODE) /* comment:Adjust \(t)the LR stack for
                                             the |post_line_break|  */
                    {

                        if (odd(mem[q].hh.b1)) {
                            if (LRptr != TEXNULL) {

                                if (mem[LRptr].hh.v.LH ==
                                    (LCODE *
                                         (mem[q].hh.b1 / LCODE) /* @d10132@ */
                                     + 3)) {
                                    tempptr = LRptr;
                                    LRptr = mem[tempptr].hh.v.RH;
                                    {
                                        mem[tempptr].hh.v.RH = avail;
                                        avail = tempptr;
                                        mem[tempptr].hh.me = 0;
                                        ;
#ifdef STAT
                                        decr(dynused);
#endif /* STAT */
                                    }
                                }
                            }
                        } else {

                            tempptr = getavail();
                            mem[tempptr].hh.v.LH =
                                (LCODE * (mem[q].hh.b1 / LCODE) /* @d10135@ */
                                 + 3);
                            mem[tempptr].hh.v.RH = LRptr;
                            LRptr = tempptr;
                        }
                    }
                }
                q = mem[q].hh.v.RH;
            }
        }
        /* comment:Modify the end of the line to reflect the nature o */ q =
            mem[curp + 1].hh.v.RH;
        discbreak = false;
        postdiscbreak = false;
        gluebreak = false;
        if (q != TEXNULL) {

            if (mem[q].hh.b0 == GLUENODE) {
                deleteglueref(mem[q + 1].hh.v.LH);
                mem[q + 1].hh.v.LH = eqtb[GLUEBASE + RIGHTSKIPCODE].hh.v.RH;
                mem[q].hh.b1 = /* @d10140@ */ 9;
                incr(mem[eqtb[GLUEBASE + RIGHTSKIPCODE].hh.v.RH].hh.v.RH);
                gluebreak = true;
                goto labpostlinebreak30done;
            } else {

                if (mem[q].hh.b0 ==
                    DISCNODE) /* comment:Change discretionary to
                                         compulsory and set |disc_b */
                {
                    t = mem[q].hh.b1;
                    /* comment:Destroy the |t| nodes following |q|, and make |r|
                     */
                    if (t == 0)
                        r = mem[q].hh.v.RH;
                    else {

                        r = q;
                        while (t > 1) {

                            r = mem[r].hh.v.RH;
                            decr(t);
                        }
                        s = mem[r].hh.v.RH;
                        r = mem[s].hh.v.RH;
                        mem[s].hh.v.RH = TEXNULL;
                        flushnodelist(mem[q].hh.v.RH);
                        mem[q].hh.b1 = 0;
                    }
                    if (mem[q + 1].hh.v.RH !=
                        TEXNULL) /* comment:Transplant the post-break list
                                  */
                    {
                        s = mem[q + 1].hh.v.RH;
                        while (mem[s].hh.v.RH != TEXNULL)
                            s = mem[s].hh.v.RH;
                        mem[s].hh.v.RH = r;
                        r = mem[q + 1].hh.v.RH;
                        mem[q + 1].hh.v.RH = TEXNULL;
                        postdiscbreak = true;
                    }
                    if (mem[q + 1].hh.v.LH !=
                        TEXNULL) /* comment:Transplant the pre-break list
                                  */
                    {
                        s = mem[q + 1].hh.v.LH;
                        mem[q].hh.v.RH = s;
                        while (mem[s].hh.v.RH != TEXNULL)
                            s = mem[s].hh.v.RH;
                        mem[q + 1].hh.v.LH = TEXNULL;
                        q = s;
                    }
                    mem[q].hh.v.RH = r;
                    discbreak = true;
                } else if (mem[q].hh.b0 == KERNNODE)
                    mem[q + WIDTHOFFSET].cint = 0;
                else if (mem[q].hh.b0 == MATHNODE) {
                    mem[q + WIDTHOFFSET].cint = 0;
                    if ((eqtb[ETEXSTATEBASE + TEXXETCODE].cint >
                         0)) /* comment:Adjust \(t)the LR stack for the
                                |post_line_break|  */
                    {

                        if (odd(mem[q].hh.b1)) {
                            if (LRptr != TEXNULL) {

                                if (mem[LRptr].hh.v.LH ==
                                    (LCODE *
                                         (mem[q].hh.b1 / LCODE) /* @d10158@ */
                                     + 3)) {
                                    tempptr = LRptr;
                                    LRptr = mem[tempptr].hh.v.RH;
                                    {
                                        mem[tempptr].hh.v.RH = avail;
                                        avail = tempptr;
                                        mem[tempptr].hh.me = 0;
                                        ;
#ifdef STAT
                                        decr(dynused);
#endif /* STAT */
                                    }
                                }
                            }
                        } else {

                            tempptr = getavail();
                            mem[tempptr].hh.v.LH =
                                (LCODE * (mem[q].hh.b1 / LCODE) /* @d10161@ */
                                 + 3);
                            mem[tempptr].hh.v.RH = LRptr;
                            LRptr = tempptr;
                        }
                    }
                }
            }
        } else {

            q = memtop - 3;
            while (mem[q].hh.v.RH != TEXNULL)
                q = mem[q].hh.v.RH;
        }
    labpostlinebreak30done:
        if (eqtb[INTBASE + PDFPROTRUDECHARSCODE].cint > 0) {
            if (discbreak && ((q >= himemmin) || (mem[q].hh.b0 != DISCNODE))) {
                p = q;
                ptmp = p;
            } else {

                p = prevrightmost(mem[memtop - 3].hh.v.RH, q);
                ptmp = p;
                p = findprotcharright(mem[memtop - 3].hh.v.RH, p);
            }
            w = charpw(p, 1);
            if (w != 0) {
                k = newmarginkern(-(integer)w, lastrightmostchar, 1);
                mem[k].hh.v.RH = mem[ptmp].hh.v.RH;
                mem[ptmp].hh.v.RH = k;
                if ((ptmp == q))
                    q = mem[q].hh.v.RH;
            }
        }
        if (!gluebreak) {
            /* comment:Put the \(r)\.{\\rightskip} glue after node |q| */ r =
                newparamglue(RIGHTSKIPCODE);
            mem[r].hh.v.RH = mem[q].hh.v.RH;
            mem[q].hh.v.RH = r;
            q = r;
        }
        if ((eqtb[ETEXSTATEBASE + TEXXETCODE].cint >
             0)) /* comment:Insert LR nodes at the end of the current line */ {

            if (LRptr != TEXNULL) {
                s = memtop - 3;
                r = mem[s].hh.v.RH;
                while (r != q) {

                    s = r;
                    r = mem[s].hh.v.RH;
                }
                r = LRptr;
                while (r != TEXNULL) {

                    tempptr = newmath(0, mem[r].hh.v.LH);
                    mem[s].hh.v.RH = tempptr;
                    s = tempptr;
                    r = mem[r].hh.v.RH;
                }
                mem[s].hh.v.RH = q;
            }
        }
        /* comment:Put the \(l)\.{\\leftskip} glue at the left and de */ r =
            mem[q].hh.v.RH;
        mem[q].hh.v.RH = TEXNULL;
        q = mem[memtop - 3].hh.v.RH;
        mem[memtop - 3].hh.v.RH = r;
        if (eqtb[INTBASE + PDFPROTRUDECHARSCODE].cint > 0) {
            p = q;
            p = findprotcharleft(p, false);
            w = charpw(p, 0);
            if (w != 0) {
                k = newmarginkern(-(integer)w, lastleftmostchar, 0);
                mem[k].hh.v.RH = q;
                q = k;
            }
        }
        if (eqtb[GLUEBASE + LEFTSKIPCODE].hh.v.RH != membot) {
            r = newparamglue(LEFTSKIPCODE);
            mem[r].hh.v.RH = q;
            q = r;
        }
        /* comment:Call the packaging subroutine, setting |just_box|  */
        if (curline > lastspecialline) {
            curwidth = secondwidth;
            curindent = secondindent;
        } else if (eqtb[PARSHAPELOC].hh.v.RH == TEXNULL) {
            curwidth = firstwidth;
            curindent = firstindent;
        } else {

            curwidth = mem[eqtb[PARSHAPELOC].hh.v.RH + 2 * curline].cint;
            curindent = mem[eqtb[PARSHAPELOC].hh.v.RH + 2 * curline - 1].cint;
        }
        adjusttail = memtop - 5;
        preadjusttail = memtop - 14;
        if (eqtb[INTBASE + PDFADJUSTSPACINGCODE].cint > 0)
            justbox = hpack(q, curwidth, 2);
        else
            justbox = hpack(q, curwidth, EXACTLY);
        mem[justbox + 4].cint = curindent;
        /* comment:Append the new box to the current vertical list, f */
        if (eqtb[DIMENBASE + PDFEACHLINEHEIGHTCODE].cint !=
            eqtb[DIMENBASE + PDFIGNOREDDIMENCODE].cint)
            mem[justbox + HEIGHTOFFSET].cint =
                eqtb[DIMENBASE + PDFEACHLINEHEIGHTCODE].cint;
        if (eqtb[DIMENBASE + PDFEACHLINEDEPTHCODE].cint !=
            eqtb[DIMENBASE + PDFIGNOREDDIMENCODE].cint)
            mem[justbox + DEPTHOFFSET].cint =
                eqtb[DIMENBASE + PDFEACHLINEDEPTHCODE].cint;
        if ((eqtb[DIMENBASE + PDFFIRSTLINEHEIGHTCODE].cint !=
             eqtb[DIMENBASE + PDFIGNOREDDIMENCODE].cint) &&
            (curline == curlist.pgfield + 1))
            mem[justbox + HEIGHTOFFSET].cint =
                eqtb[DIMENBASE + PDFFIRSTLINEHEIGHTCODE].cint;
        if ((eqtb[DIMENBASE + PDFLASTLINEDEPTHCODE].cint !=
             eqtb[DIMENBASE + PDFIGNOREDDIMENCODE].cint) &&
            (curline + 1 == bestline))
            mem[justbox + DEPTHOFFSET].cint =
                eqtb[DIMENBASE + PDFLASTLINEDEPTHCODE].cint;
        if (memtop - 14 != preadjusttail) {
            mem[curlist.tailfield].hh.v.RH = mem[memtop - 14].hh.v.RH;
            curlist.tailfield = preadjusttail;
        }
        preadjusttail = TEXNULL;
        appendtovlist(justbox);
        if (memtop - 5 != adjusttail) {
            mem[curlist.tailfield].hh.v.RH = mem[memtop - 5].hh.v.RH;
            curlist.tailfield = adjusttail;
        }
        adjusttail = TEXNULL;
        /* comment:Append a penalty node, if a nonzero penalty is app */
        if (curline + 1 != bestline) {
            q = eqtb[INTERLINEPENALTIESLOC].hh.v.RH;
            if (q != TEXNULL) {
                r = curline;
                if (r > mem[q + 1].cint)
                    r = mem[q + 1].cint;
                pen = mem[q + r + 1].cint;
            } else
                pen = eqtb[INTBASE + INTERLINEPENALTYCODE].cint;
            q = eqtb[CLUBPENALTIESLOC].hh.v.RH;
            if (q != TEXNULL) {
                r = curline - curlist.pgfield;
                if (r > mem[q + 1].cint)
                    r = mem[q + 1].cint;
                pen = pen + mem[q + r + 1].cint;
            } else if (curline == curlist.pgfield + 1)
                pen = pen + eqtb[INTBASE + CLUBPENALTYCODE].cint;
            if (d)
                q = eqtb[DISPLAYWIDOWPENALTIESLOC].hh.v.RH;
            else
                q = eqtb[WIDOWPENALTIESLOC].hh.v.RH;
            if (q != TEXNULL) {
                r = bestline - curline - 1;
                if (r > mem[q + 1].cint)
                    r = mem[q + 1].cint;
                pen = pen + mem[q + r + 1].cint;
            } else if (curline + 2 == bestline) {

                if (d)
                    pen = pen + eqtb[INTBASE + DISPLAYWIDOWPENALTYCODE].cint;
                else
                    pen = pen + eqtb[INTBASE + WIDOWPENALTYCODE].cint;
            }
            if (discbreak)
                pen = pen + eqtb[INTBASE + BROKENPENALTYCODE].cint;
            if (pen != 0) {
                r = newpenalty(pen);
                mem[curlist.tailfield].hh.v.RH = r;
                curlist.tailfield = r;
            }
        }
        incr(curline);
        curp = mem[curp + 1].hh.v.LH;
        if (curp != TEXNULL) {

            if (!postdiscbreak) /* comment:Prune unwanted nodes at the beginning
                                   of the next  */
            {
                r = memtop - 3;
                while (true) {

                    q = mem[r].hh.v.RH;
                    if (q == mem[curp + 1].hh.v.RH)
                        goto labpostlinebreak31done1;
                    if ((q >= himemmin))
                        goto labpostlinebreak31done1;
                    if ((mem[q].hh.b0 < MATHNODE))
                        goto labpostlinebreak31done1;
                    if (mem[q].hh.b0 == KERNNODE) {

                        if (mem[q].hh.b1 != EXPLICIT)
                            goto labpostlinebreak31done1;
                    }
                    r = q;
                    if (mem[q].hh.b0 == MATHNODE) {

                        if ((eqtb[ETEXSTATEBASE + TEXXETCODE].cint >
                             0)) /* comment:Adjust \(t)the LR stack for the
                                    |post_line_break|  */
                        {

                            if (odd(mem[q].hh.b1)) {
                                if (LRptr != TEXNULL) {

                                    if (mem[LRptr].hh.v.LH ==
                                        (LCODE * (mem[q].hh.b1 /
                                                  LCODE) /* @d10242@ */
                                         + 3)) {
                                        tempptr = LRptr;
                                        LRptr = mem[tempptr].hh.v.RH;
                                        {
                                            mem[tempptr].hh.v.RH = avail;
                                            avail = tempptr;
                                            mem[tempptr].hh.me = 0;
                                            ;
#ifdef STAT
                                            decr(dynused);
#endif /* STAT */
                                        }
                                    }
                                }
                            } else {

                                tempptr = getavail();
                                mem[tempptr].hh.v.LH =
                                    (LCODE *
                                         (mem[q].hh.b1 / LCODE) /* @d10245@ */
                                     + 3);
                                mem[tempptr].hh.v.RH = LRptr;
                                LRptr = tempptr;
                            }
                        }
                    }
                }
            labpostlinebreak31done1:
                if (r != memtop - 3) {
                    mem[r].hh.v.RH = TEXNULL;
                    flushnodelist(mem[memtop - 3].hh.v.RH);
                    mem[memtop - 3].hh.v.RH = q;
                }
            }
        }
    } while (!(curp == TEXNULL));
    if ((curline != bestline) || (mem[memtop - 3].hh.v.RH != TEXNULL))
        confusion(/* str 'line breaking' */ 1353);
    curlist.pgfield = bestline - 1;
    curlist.eTeXauxfield = LRptr;
}
/* comment:Declare the function called |reconstitute| */ smallnumber
zreconstitute(smallnumber j, smallnumber n, halfword bchar, halfword hchar) {
    register smallnumber Result;
    reconstitute_regmem halfword p;
    halfword t;
    fourquarters q;
    halfword currh;
    halfword testchar;
    scaled w;
    fontindex k;
    hyphenpassed = 0;
    t = memtop - 4;
    w = 0;
    mem[memtop - 4].hh.v.RH = TEXNULL;
    /* comment:Set up data structures with the cursor following p */ curl =
        hu[j];
    curq = t;
    if (j == 0) {
        ligaturepresent = initlig;
        p = initlist;
        if (ligaturepresent)
            lfthit = initlft;
        while (p > TEXNULL) {

            {
                mem[t].hh.v.RH = getavail();
                t = mem[t].hh.v.RH;
                mem[t].hh.b0 = hf;
                mem[t].hh.b1 = mem[p].hh.b1;
            }
            mem[t].hh.me = mem[p].hh.me;
            p = mem[p].hh.v.RH;
        }
    } else if (curl < 256) {
        mem[t].hh.v.RH = getavail();
        t = mem[t].hh.v.RH;
        mem[t].hh.b0 = hf;
        mem[t].hh.b1 = curl;
    }
    mem[t].hh.me = hm[j];
    ligstack = TEXNULL;
    {
        if (j < n)
            curr = hu[j + 1];
        else
            curr = bchar;
        if (odd(hyf[j]))
            currh = hchar;
        else
            currh = 256;
    }
labreconstitute22continue
    : /* comment:If there's a ligature or kern at the cursor positi */
    if (curl == 256) {
        k = bcharlabel[hf];
        if (k == NONADDRESS)
            goto labreconstitute30done;
        else
            q = fontinfo[k].qqqq;
    } else {

        q = fontinfo[charbase[hf] + effectivechar(true, hf, curl)].qqqq;
        if (((q.b2) % 4) != LIGTAG)
            goto labreconstitute30done;
        k = ligkernbase[hf] + q.b3;
        q = fontinfo[k].qqqq;
        if (q.b0 > 128) {
            k = ligkernbase[hf] + 256 * q.b2 + q.b3 + 32768L -
                256 * (/* @d10258@ */ 128);
            q = fontinfo[k].qqqq;
        }
    }
    if (currh < 256)
        testchar = currh;
    else
        testchar = curr;
    while (true) {

        if (q.b1 == testchar) {

            if (q.b0 <= 128) {

                if (currh < 256) {
                    hyphenpassed = j;
                    hchar = 256;
                    currh = 256;
                    goto labreconstitute22continue;
                } else {

                    if (hchar < 256) {

                        if (odd(hyf[j])) {
                            hyphenpassed = j;
                            hchar = 256;
                        }
                    }
                    if (q.b2 < 128) /* comment:Carry out a ligature replacement,
                                       updating the cur */
                    {
                        if (curl == 256)
                            lfthit = true;
                        if (j == n) {

                            if (ligstack == TEXNULL)
                                rthit = true;
                        }
                        {
                            if (interrupt != 0)
                                pauseforinstructions();
                        }
                        switch (q.b2) {
                        case 1:
                        case 5: {
                            curl = q.b3;
                            ligaturepresent = true;
                        } break;
                        case 2:
                        case 6: {
                            curr = q.b3;
                            if (ligstack > TEXNULL)
                                mem[ligstack].hh.b1 = curr;
                            else {

                                ligstack = newligitem(curr);
                                if (j == n)
                                    bchar = 256;
                                else {

                                    p = getavail();
                                    mem[ligstack + 1].hh.v.RH = p;
                                    mem[p].hh.b1 = hu[j + 1];
                                    mem[p].hh.b0 = hf;
                                }
                            }
                        } break;
                        case 3: {
                            curr = q.b3;
                            p = ligstack;
                            ligstack = newligitem(curr);
                            mem[ligstack].hh.v.RH = p;
                        } break;
                        case 7:
                        case 11: {
                            if (ligaturepresent) {
                                p = newligature(hf, curl, mem[curq].hh.v.RH);
                                mem[p].hh.me = mem[mem[curq].hh.v.RH].hh.me;
                                if (lfthit) {
                                    mem[p].hh.b1 = 2;
                                    lfthit = false;
                                }
                                if (false) {

                                    if (ligstack == TEXNULL) {
                                        incr(mem[p].hh.b1);
                                        rthit = false;
                                    }
                                }
                                mem[curq].hh.v.RH = p;
                                t = p;
                                ligaturepresent = false;
                            }
                            curq = t;
                            curl = q.b3;
                            ligaturepresent = true;
                        } break;
                        default: {
                            curl = q.b3;
                            ligaturepresent = true;
                            if (ligstack > TEXNULL) {
                                if (mem[ligstack + 1].hh.v.RH > TEXNULL) {
                                    mem[t].hh.v.RH = mem[ligstack + 1].hh.v.RH;
                                    t = mem[t].hh.v.RH;
                                    incr(j);
                                }
                                p = ligstack;
                                ligstack = mem[p].hh.v.RH;
                                freenode(p, SMALLNODESIZE);
                                if (ligstack == TEXNULL) {
                                    if (j < n)
                                        curr = hu[j + 1];
                                    else
                                        curr = bchar;
                                    if (odd(hyf[j]))
                                        currh = hchar;
                                    else
                                        currh = 256;
                                } else
                                    curr = mem[ligstack].hh.b1;
                            } else if (j == n)
                                goto labreconstitute30done;
                            else {

                                {
                                    mem[t].hh.v.RH = getavail();
                                    t = mem[t].hh.v.RH;
                                    mem[t].hh.b0 = hf;
                                    mem[t].hh.b1 = curr;
                                }
                                incr(j);
                                {
                                    if (j < n)
                                        curr = hu[j + 1];
                                    else
                                        curr = bchar;
                                    if (odd(hyf[j]))
                                        currh = hchar;
                                    else
                                        currh = 256;
                                }
                            }
                        } break;
                        }
                        if (q.b2 > 4) {

                            if (q.b2 != 7)
                                goto labreconstitute30done;
                        }
                        goto labreconstitute22continue;
                    }
                    w = fontinfo[kernbase[hf] + 256 * q.b2 + q.b3].cint;
                    goto labreconstitute30done;
                }
            }
        }
        if (q.b0 >= 128) {

            if (currh == 256)
                goto labreconstitute30done;
            else {

                currh = 256;
                goto labreconstitute22continue;
            }
        }
        k = k + q.b0 + 1;
        q = fontinfo[k].qqqq;
    }
labreconstitute30done:;
    /* comment:Append a ligature andor kern to the translation;  */
    if (ligaturepresent) {
        p = newligature(hf, curl, mem[curq].hh.v.RH);
        mem[p].hh.me = mem[mem[curq].hh.v.RH].hh.me;
        if (lfthit) {
            mem[p].hh.b1 = 2;
            lfthit = false;
        }
        if (rthit) {

            if (ligstack == TEXNULL) {
                incr(mem[p].hh.b1);
                rthit = false;
            }
        }
        mem[curq].hh.v.RH = p;
        t = p;
        ligaturepresent = false;
    }
    if (w != 0) {
        mem[t].hh.v.RH = newkern(w);
        t = mem[t].hh.v.RH;
        w = 0;
    }
    if (ligstack > TEXNULL) {
        curq = t;
        curl = mem[ligstack].hh.b1;
        ligaturepresent = true;
        {
            if (mem[ligstack + 1].hh.v.RH > TEXNULL) {
                mem[t].hh.v.RH = mem[ligstack + 1].hh.v.RH;
                t = mem[t].hh.v.RH;
                incr(j);
            }
            p = ligstack;
            ligstack = mem[p].hh.v.RH;
            freenode(p, SMALLNODESIZE);
            if (ligstack == TEXNULL) {
                if (j < n)
                    curr = hu[j + 1];
                else
                    curr = bchar;
                if (odd(hyf[j]))
                    currh = hchar;
                else
                    currh = 256;
            } else
                curr = mem[ligstack].hh.b1;
        }
        goto labreconstitute22continue;
    }
    Result = j;
    return Result;
}
/* comment:Declare \eTeX\ procedures for use by |main_control */ boolean
zeTeXenabled(boolean b, quarterword j, halfword k) {
    register boolean Result;
    eTeXenabled_regmem if (!b) {
        {
            if (interaction == ERRORSTOPMODE)
                ;
            if (filelineerrorstylep)
                printfileline();
            else
                printnl(/* str '! ' */ 264);
            print(/* str 'Improper ' */ 781);
        }
        printcmdchr(j, k);
        {
            helpptr = 1;
            helpline[0] =
                /* str 'Sorry, this optional e-TeX feature has been disab' */
                1970;
        }
        error();
    }
    Result = b;
    return Result;
}
void showsavegroups(void) {
    /* @d10715@ */ /* @d10716@ */ /* @d10717@ */ /* @d10718@ */
    showsavegroups_regmem integer p;
    /* @d10719@ */ /* @d10720@ */ short m;
    savepointer v;
    quarterword l;
    groupcode c;
    schar a;
    integer i;
    quarterword j;
    strnumber s;
    p = nestptr;
    nest[p] = curlist;
    v = saveptr;
    l = curlevel;
    c = curgroup;
    saveptr = curboundary;
    decr(curlevel);
    a = 1;
    printnl(/* str '' */ 345);
    println();
    while (true) {

        printnl(/* str '### ' */ 379);
        printgroup(true);
        if (curgroup == BOTTOMLEVEL)
            goto labshowsavegroups30done;
        do {
            m = nest[p].modefield;
            if (p > 0)
                decr(p);
            else
                m = VMODE;
        } while (!(m != HMODE));
        print(/* str ' (' */ 286);
        switch (curgroup) {
        case SIMPLEGROUP: {
            incr(p);
            goto labshowsavegroups42found2;
        } break;
        case HBOXGROUP:
        case ADJUSTEDHBOXGROUP:
            s = /* str 'hbox' */ 1474;
            break;
        case VBOXGROUP:
            s = /* str 'vbox' */ 1383;
            break;
        case VTOPGROUP:
            s = /* str 'vtop' */ 1473;
            break;
        case ALIGNGROUP:
            if (a == 0) {
                if (m == /* @d10738@ */ -1)
                    s = /* str 'halign' */ 599;
                else
                    s = /* str 'valign' */ 618;
                a = 1;
                goto labshowsavegroups41found1;
            } else {

                if (a == 1)
                    print(/* str 'align entry' */ 2008);
                else
                    printesc(/* str 'cr' */ 1309);
                if (p >= a)
                    p = p - a;
                a = 0;
                goto labshowsavegroups40found;
            }
            break;
        case NOALIGNGROUP: {
            incr(p);
            a = -1;
            printesc(/* str 'noalign' */ 606);
            goto labshowsavegroups42found2;
        } break;
        case OUTPUTGROUP: {
            printesc(/* str 'output' */ 414);
            goto labshowsavegroups40found;
        } break;
        case MATHGROUP:
            goto labshowsavegroups42found2;
            break;
        case DISCGROUP:
        case MATHCHOICEGROUP: {
            if (curgroup == DISCGROUP)
                printesc(/* str 'discretionary' */ 357);
            else
                printesc(/* str 'mathchoice' */ 604);
            {
                register integer for_end;
                i = 1;
                for_end = 3;
                if (i <= for_end)
                    do
                        if (i <= savestack[saveptr - 2].cint)
                            print(/* str '{}' */ 1269);
                    while (i++ < for_end);
            }
            goto labshowsavegroups42found2;
        } break;
        case INSERTGROUP: {
            if (savestack[saveptr - 2].cint == 255)
                printesc(/* str 'vadjust' */ 360);
            else {

                printesc(/* str 'insert' */ 337);
                printint(savestack[saveptr - 2].cint);
            }
            goto labshowsavegroups42found2;
        } break;
        case VCENTERGROUP: {
            s = /* str 'vcenter' */ 619;
            goto labshowsavegroups41found1;
        } break;
        case SEMISIMPLEGROUP: {
            incr(p);
            printesc(/* str 'begingroup' */ 588);
            goto labshowsavegroups40found;
        } break;
        case MATHSHIFTGROUP: {
            if (m == MMODE)
                printchar(/* str '$' */ 36);
            else if (nest[p].modefield == MMODE) {
                printcmdchr(EQNO, savestack[saveptr - 2].cint);
                goto labshowsavegroups40found;
            }
            printchar(/* str '$' */ 36);
            goto labshowsavegroups40found;
        } break;
        case MATHLEFTGROUP: {
            if (mem[nest[p + 1].eTeXauxfield].hh.b0 == LEFTNOAD)
                printesc(/* str 'left' */ 1285);
            else
                printesc(/* str 'middle' */ 1287);
            goto labshowsavegroups40found;
        } break;
        }
        /* comment:Show the box context */ i = savestack[saveptr - 4].cint;
        if (i != 0) {

            if (i < 1073741824L) {
                if (abs(nest[p].modefield) == VMODE)
                    j = HMOVE;
                else
                    j = VMOVE;
                if (i > 0)
                    printcmdchr(j, 0);
                else
                    printcmdchr(j, 1);
                printscaled(abs(i));
                print(/* str 'pt' */ 312);
            } else if (i < 1073807360L) {
                if (i >= 1073774592L) {
                    printesc(/* str 'global' */ 1591);
                    i = i - (32768L);
                }
                printesc(/* str 'setbox' */ 616);
                printint(i - 1073741824L);
                printchar(/* str '=' */ 61);
            } else
                printcmdchr(LEADERSHIP, i - (/* @d10792@ */ 1073807261L));
        }
    labshowsavegroups41found1:
        printesc(s);
        /* comment:Show the box packaging info */ if (savestack[saveptr - 2]
                                                          .cint != 0) {
            printchar(/* str ' ' */ 32);
            if (savestack[saveptr - 3].cint == EXACTLY)
                print(/* str 'to' */ 1245);
            else
                print(/* str 'spread' */ 1246);
            printscaled(savestack[saveptr - 2].cint);
            print(/* str 'pt' */ 312);
        }
    labshowsavegroups42found2:
        printchar(/* str '{' */ 123);
    labshowsavegroups40found:
        printchar(/* str ')' */ 41);
        decr(curlevel);
        curgroup = savestack[saveptr].hh.b1;
        saveptr = savestack[saveptr].hh.v.RH;
    }
labshowsavegroups30done:
    saveptr = v;
    curlevel = l;
    curgroup = c;
}
halfword zvertbreak(halfword p, scaled h, scaled d) {
    register halfword Result;
    vertbreak_regmem halfword prevp;
    halfword q, r;
    integer pi;
    integer b;
    integer leastcost;
    halfword bestplace;
    scaled prevdp;
    smallnumber t;
    prevp = p;
    leastcost = 1073741823L;
    activewidth[1] = 0;
    activewidth[2] = 0;
    activewidth[3] = 0;
    activewidth[4] = 0;
    activewidth[5] = 0;
    activewidth[6] = 0;
    prevdp = 0;
    while (true) {

        /* comment:If node |p| is a legal breakpoint, check if this b */
        if (p == TEXNULL)
            pi = /* @d10894@ */ -10000;
        else /* comment:Use node |p| to update the current height and dept */
            switch (mem[p].hh.b0) {
            case HLISTNODE:
            case VLISTNODE:
            case RULENODE: {
                activewidth[1] =
                    activewidth[1] + prevdp + mem[p + HEIGHTOFFSET].cint;
                prevdp = mem[p + DEPTHOFFSET].cint;
                goto labvertbreak45not_found;
            } break;
            case WHATSITNODE:
                /* comment:Process whatsit |p| in |vert_break| loop, |goto no */
                {

                    if ((mem[p].hh.b1 == /* @d10904@ */ 10) ||
                        (mem[p].hh.b1 == /* @d10905@ */ 12)) {
                        activewidth[1] =
                            activewidth[1] + prevdp + mem[p + 2].cint;
                        prevdp = mem[p + 3].cint;
                    }
                    goto labvertbreak45not_found;
                }
                break;
            case GLUENODE:
                if ((mem[prevp].hh.b0 < MATHNODE))
                    pi = 0;
                else
                    goto labvertbreak90update_heights;
                break;
            case KERNNODE: {
                if (mem[p].hh.v.RH == TEXNULL)
                    t = PENALTYNODE;
                else
                    t = mem[mem[p].hh.v.RH].hh.b0;
                if (t == GLUENODE)
                    pi = 0;
                else
                    goto labvertbreak90update_heights;
            } break;
            case PENALTYNODE:
                pi = mem[p + 1].cint;
                break;
            case MARKNODE:
            case INSNODE:
                goto labvertbreak45not_found;
                break;
            default:
                confusion(/* str 'vertbreak' */ 1376);
                break;
            }
        /* comment:Check if node |p| is a new champion breakpoint; th */
        if (pi < INFPENALTY) {
            /* comment:Compute the badness, |b|, using |awful_bad| if the */
            if (activewidth[1] < h) {

                if ((activewidth[3] != 0) || (activewidth[4] != 0) ||
                    (activewidth[5] != 0))
                    b = 0;
                else
                    b = badness(h - activewidth[1], activewidth[2]);
            } else if (activewidth[1] - h > activewidth[6])
                b = 1073741823L;
            else
                b = badness(activewidth[1] - h, activewidth[6]);
            if (b < 1073741823L) {

                if (pi <= /* @d10922@ */ -10000)
                    b = pi;
                else if (b < INFBAD)
                    b = b + pi;
                else
                    b = 100000L;
            }
            if (b <= leastcost) {
                bestplace = p;
                leastcost = b;
                bestheightplusdepth = activewidth[1] + prevdp;
            }
            if ((b == 1073741823L) || (pi <= /* @d10924@ */ -10000))
                goto labvertbreak30done;
        }
        if ((mem[p].hh.b0 < GLUENODE) || (mem[p].hh.b0 > KERNNODE))
            goto labvertbreak45not_found;
    labvertbreak90update_heights
        : /* comment:Update the current height and depth measurements w */
        if (mem[p].hh.b0 == KERNNODE)
            q = p;
        else {

            q = mem[p + 1].hh.v.LH;
            activewidth[2 + mem[q].hh.b0] =
                activewidth[2 + mem[q].hh.b0] + mem[q + 2].cint;
            activewidth[6] = activewidth[6] + mem[q + 3].cint;
            if ((mem[q].hh.b1 != NORMAL) && (mem[q + 3].cint != 0)) {
                {
                    if (interaction == ERRORSTOPMODE)
                        ;
                    if (filelineerrorstylep)
                        printfileline();
                    else
                        printnl(/* str '! ' */ 264);
                    print(/* str 'Infinite glue shrinkage found in box being
                             split' */
                          1377);
                }
                {
                    helpptr = 4;
                    helpline[3] = /* str 'The box you are \vsplitting contains
                                     some infinit' */
                        1378;
                    helpline[2] = /* str 'shrinkable glue, e.g., `\vss' or
                                     `\vskip 0pt minu' */
                        1379;
                    helpline[1] = /* str 'Such glue doesn't belong there; but
                                     you can safel' */
                        1380;
                    helpline[0] = /* str 'since the offensive shrinkability has
                                     been made f' */
                        1332;
                }
                error();
                r = newspec(q);
                mem[r].hh.b1 = NORMAL;
                deleteglueref(q);
                mem[p + 1].hh.v.LH = r;
                q = r;
            }
        }
        activewidth[1] = activewidth[1] + prevdp + mem[q + WIDTHOFFSET].cint;
        prevdp = 0;
    labvertbreak45not_found:
        if (prevdp > d) {
            activewidth[1] = activewidth[1] + prevdp - d;
            prevdp = d;
        }
        prevp = p;
        p = mem[prevp].hh.v.RH;
    }
labvertbreak30done:
    Result = bestplace;
    return Result;
}
halfword zvsplit(halfword n, scaled h) {
    register halfword Result;
    vsplit_regmem halfword v;
    halfword p;
    halfword q;
    curval = n;
    if (curval < 256)
        v = eqtb[BOXBASE + curval].hh.v.RH;
    else {

        findsaelement(4, curval, false);
        if (curptr == TEXNULL)
            v = TEXNULL;
        else
            v = mem[curptr + 1].hh.v.RH;
    }
    flushnodelist(discptr[VSPLITCODE]);
    discptr[VSPLITCODE] = TEXNULL;
    if (saroot[MARKVAL] != TEXNULL) {

        if (domarks(0, 0, saroot[MARKVAL]))
            saroot[MARKVAL] = TEXNULL;
    }
    if (curmark[SPLITFIRSTMARKCODE] != TEXNULL) {
        deletetokenref(curmark[SPLITFIRSTMARKCODE]);
        curmark[SPLITFIRSTMARKCODE] = TEXNULL;
        deletetokenref(curmark[SPLITBOTMARKCODE]);
        curmark[SPLITBOTMARKCODE] = TEXNULL;
    }
    /* comment:Dispense with trivial cases of void or bad boxes */
    if (v == TEXNULL) {
        Result = TEXNULL;
        return Result;
    }
    if (mem[v].hh.b0 != VLISTNODE) {
        {
            if (interaction == ERRORSTOPMODE)
                ;
            if (filelineerrorstylep)
                printfileline();
            else
                printnl(/* str '! ' */ 264);
            print(/* str '' */ 345);
        }
        printesc(/* str 'vsplit' */ 1381);
        print(/* str ' needs a ' */ 1382);
        printesc(/* str 'vbox' */ 1383);
        {
            helpptr = 2;
            helpline[1] =
                /* str 'The box you are trying to split is an \hbox.' */ 1384;
            helpline[0] =
                /* str 'I can't split such a box, so I'll leave it alone.' */
                1385;
        }
        error();
        Result = TEXNULL;
        return Result;
    }
    q = vertbreak(mem[v + LISTOFFSET].hh.v.RH, h,
                  eqtb[DIMENBASE + SPLITMAXDEPTHCODE].cint);
    /* comment:Look at all the marks in nodes before the break, a */ p =
        mem[v + LISTOFFSET].hh.v.RH;
    if (p == q)
        mem[v + LISTOFFSET].hh.v.RH = TEXNULL;
    else
        while (true) {

            if (mem[p].hh.b0 == MARKNODE) {

                if (mem[p + 1].hh.v.LH !=
                    0) /* comment:Update the current marks for |vsplit| */
                {
                    findsaelement(MARKVAL, mem[p + 1].hh.v.LH, true);
                    if (mem[curptr + 2].hh.v.RH == TEXNULL) {
                        mem[curptr + 2].hh.v.RH = mem[p + 1].hh.v.RH;
                        incr(mem[mem[p + 1].hh.v.RH].hh.v.LH);
                    } else
                        deletetokenref(mem[curptr + 3].hh.v.LH);
                    mem[curptr + 3].hh.v.LH = mem[p + 1].hh.v.RH;
                    incr(mem[mem[p + 1].hh.v.RH].hh.v.LH);
                } else if (curmark[SPLITFIRSTMARKCODE] == TEXNULL) {
                    curmark[SPLITFIRSTMARKCODE] = mem[p + 1].hh.v.RH;
                    curmark[SPLITBOTMARKCODE] = curmark[SPLITFIRSTMARKCODE];
                    mem[curmark[SPLITFIRSTMARKCODE]].hh.v.LH =
                        mem[curmark[SPLITFIRSTMARKCODE]].hh.v.LH + 2;
                } else {

                    deletetokenref(curmark[SPLITBOTMARKCODE]);
                    curmark[SPLITBOTMARKCODE] = mem[p + 1].hh.v.RH;
                    incr(mem[curmark[SPLITBOTMARKCODE]].hh.v.LH);
                }
            }
            if (mem[p].hh.v.RH == q) {
                mem[p].hh.v.RH = TEXNULL;
                goto labvsplit30done;
            }
            p = mem[p].hh.v.RH;
        }
labvsplit30done:;
    q = prunepagetop(q, eqtb[INTBASE + SAVINGVDISCARDSCODE].cint > 0);
    p = mem[v + LISTOFFSET].hh.v.RH;
    freenode(v, BOXNODESIZE);
    if (q != TEXNULL)
        q = vpackage(q, 0, ADDITIONAL, 1073741823L);
    if (curval < 256)
        eqtb[BOXBASE + curval].hh.v.RH = q;
    else {

        findsaelement(4, curval, false);
        if (curptr != TEXNULL) {
            mem[curptr + 1].hh.v.RH = q;
            incr(mem[curptr + 1].hh.v.LH);
            deletesaref(curptr);
        }
    }
    Result = vpackage(p, h, EXACTLY, eqtb[DIMENBASE + SPLITMAXDEPTHCODE].cint);
    return Result;
}
void printtotals(void) {
    printtotals_regmem printscaled(pagesofar[1]);
    if (pagesofar[2] != 0) {
        print(/* str ' plus ' */ 317);
        printscaled(pagesofar[2]);
        print(/* str '' */ 345);
    }
    if (pagesofar[3] != 0) {
        print(/* str ' plus ' */ 317);
        printscaled(pagesofar[3]);
        print(/* str 'fil' */ 316);
    }
    if (pagesofar[4] != 0) {
        print(/* str ' plus ' */ 317);
        printscaled(pagesofar[4]);
        print(/* str 'fill' */ 1394);
    }
    if (pagesofar[5] != 0) {
        print(/* str ' plus ' */ 317);
        printscaled(pagesofar[5]);
        print(/* str 'filll' */ 1395);
    }
    if (pagesofar[6] != 0) {
        print(/* str ' minus ' */ 318);
        printscaled(pagesofar[6]);
    }
}
void zfreezepagespecs(smallnumber s) {
    freezepagespecs_regmem pagecontents = s;
    pagesofar[0] = eqtb[DIMENBASE + VSIZECODE].cint;
    pagemaxdepth = eqtb[DIMENBASE + MAXDEPTHCODE].cint;
    pagesofar[7] = 0;
    pagesofar[1] = 0;
    pagesofar[2] = 0;
    pagesofar[3] = 0;
    pagesofar[4] = 0;
    pagesofar[5] = 0;
    pagesofar[6] = 0;
    leastpagecost = 1073741823L;
    ;
#ifdef STAT
    if (eqtb[INTBASE + TRACINGPAGESCODE].cint > 0) {
        begindiagnostic();
        printnl(/* str '%% goal height=' */ 1403);
        printscaled(pagesofar[0]);
        print(/* str ', max depth=' */ 1404);
        printscaled(pagemaxdepth);
        enddiagnostic(false);
    }
#endif /* STAT */
}
void zboxerror(eightbits n) {
    boxerror_regmem error();
    begindiagnostic();
    printnl(/* str 'The following box has been deleted' */ 995);
    showbox(eqtb[BOXBASE + n].hh.v.RH);
    enddiagnostic(true);
    flushnodelist(eqtb[BOXBASE + n].hh.v.RH);
    eqtb[BOXBASE + n].hh.v.RH = TEXNULL;
}
void zensurevbox(eightbits n) {
    ensurevbox_regmem halfword p;
    p = eqtb[BOXBASE + n].hh.v.RH;
    if (p != TEXNULL) {

        if (mem[p].hh.b0 == HLISTNODE) {
            {
                if (interaction == ERRORSTOPMODE)
                    ;
                if (filelineerrorstylep)
                    printfileline();
                else
                    printnl(/* str '! ' */ 264);
                print(/* str 'Insertions can only be added to a vbox' */ 1405);
            }
            {
                helpptr = 3;
                helpline[2] = /* str 'Tut tut' */ 1406;
                helpline[1] =
                    /* str '\box register that now contains an \hbox.' */ 1407;
                helpline[0] =
                    /* str 'Proceed, and I'll discard its present contents.' */
                    1408;
            }
            boxerror(n);
        }
    }
}
/* comment:Declare the procedure called |fire_up| */ void zfireup(halfword c) {
    fireup_regmem halfword p, q, r, s;
    halfword prevp;
    unsigned char n;
    boolean wait;
    integer savevbadness;
    scaled savevfuzz;
    halfword savesplittopskip;
    /* comment:Set the value of |output_penalty| */ if (mem[bestpagebreak]
                                                            .hh.b0 ==
                                                        PENALTYNODE) {
        geqworddefine(/* @d11039@ */ /* @d11040@ */ 29316,
                      mem[bestpagebreak + 1].cint);
        mem[bestpagebreak + 1].cint = INFPENALTY;
    } else
        geqworddefine(/* @d11042@ */ /* @d11043@ */ 29316, INFPENALTY);
    if (saroot[MARKVAL] != TEXNULL) {

        if (domarks(1, 0, saroot[MARKVAL]))
            saroot[MARKVAL] = TEXNULL;
    }
    if (curmark[BOTMARKCODE] != TEXNULL) {
        if (curmark[TOPMARKCODE] != TEXNULL)
            deletetokenref(curmark[TOPMARKCODE]);
        curmark[TOPMARKCODE] = curmark[BOTMARKCODE];
        incr(mem[curmark[TOPMARKCODE]].hh.v.LH);
        deletetokenref(curmark[FIRSTMARKCODE]);
        curmark[FIRSTMARKCODE] = TEXNULL;
    }
    /* comment:Put the \(o)optimal current page into box 255, upd */
    if (c == bestpagebreak)
        bestpagebreak = TEXNULL;
    /* comment:Ensure that box 255 is empty before output */
    if (eqtb[/* @d11058@ */ 27688].hh.v.RH != TEXNULL) {
        {
            if (interaction == ERRORSTOPMODE)
                ;
            if (filelineerrorstylep)
                printfileline();
            else
                printnl(/* str '! ' */ 264);
            print(/* str '' */ 345);
        }
        printesc(/* str 'box' */ 429);
        print(/* str '255 is not void' */ 1418);
        {
            helpptr = 2;
            helpline[1] =
                /* str 'You shouldn't use \box255 except in \output routi' */
                1419;
            helpline[0] =
                /* str 'Proceed, and I'll discard its present contents.' */
                1408;
        }
        boxerror(255);
    }
    insertpenalties = 0;
    savesplittopskip = eqtb[GLUEBASE + SPLITTOPSKIPCODE].hh.v.RH;
    if (eqtb[INTBASE + HOLDINGINSERTSCODE].cint <=
        0) /* comment:Prepare all the boxes involved in insertions to ac */
    {
        r = mem[memtop].hh.v.RH;
        while (r != memtop) {

            if (mem[r + 2].hh.v.LH != TEXNULL) {
                n = mem[r].hh.b1;
                ensurevbox(n);
                if (eqtb[BOXBASE + n].hh.v.RH == TEXNULL)
                    eqtb[BOXBASE + n].hh.v.RH = newnullbox();
                p = eqtb[BOXBASE + n].hh.v.RH /* @d11074@ */ + 5;
                while (mem[p].hh.v.RH != TEXNULL)
                    p = mem[p].hh.v.RH;
                mem[r + 2].hh.v.RH = p;
            }
            r = mem[r].hh.v.RH;
        }
    }
    q = memtop - 4;
    mem[q].hh.v.RH = TEXNULL;
    prevp = memtop - 2;
    p = mem[prevp].hh.v.RH;
    while (p != bestpagebreak) {

        if (mem[p].hh.b0 == INSNODE) {
            if (eqtb[INTBASE + HOLDINGINSERTSCODE].cint <=
                0) /* comment:Either insert the material specified by node |p| i
                    */
            {
                r = mem[memtop].hh.v.RH;
                while (mem[r].hh.b1 != mem[p].hh.b1)
                    r = mem[r].hh.v.RH;
                if (mem[r + 2].hh.v.LH == TEXNULL)
                    wait = true;
                else {

                    wait = false;
                    s = mem[r + 2].hh.v.RH;
                    mem[s].hh.v.RH = mem[p + 4].hh.v.LH;
                    if (mem[r + 2].hh.v.LH ==
                        p) /* comment:Wrap up the box specified by node |r|,
                              splitting n */
                    {
                        if (mem[r].hh.b0 == SPLITUP) {

                            if ((mem[r + 1].hh.v.LH == p) &&
                                (mem[r + 1].hh.v.RH != TEXNULL)) {
                                while (mem[s].hh.v.RH != mem[r + 1].hh.v.RH)
                                    s = mem[s].hh.v.RH;
                                mem[s].hh.v.RH = TEXNULL;
                                eqtb[GLUEBASE + SPLITTOPSKIPCODE].hh.v.RH =
                                    mem[p + 4].hh.v.RH;
                                mem[p + 4].hh.v.LH =
                                    prunepagetop(mem[r + 1].hh.v.RH, false);
                                if (mem[p + 4].hh.v.LH != TEXNULL) {
                                    tempptr = vpackage(mem[p + 4].hh.v.LH, 0,
                                                       ADDITIONAL, 1073741823L);
                                    mem[p + HEIGHTOFFSET].cint =
                                        mem[tempptr + HEIGHTOFFSET].cint +
                                        mem[/* @d11086@ */
                                            tempptr + 2]
                                            .cint;
                                    freenode(tempptr, BOXNODESIZE);
                                    wait = true;
                                }
                            }
                        }
                        mem[r + 2].hh.v.LH = TEXNULL;
                        n = mem[r].hh.b1;
                        tempptr = mem[eqtb[BOXBASE + n].hh.v.RH /* @d11089@
                                                                 */
                                      + 5]
                                      .hh.v.RH;
                        freenode(eqtb[BOXBASE + n].hh.v.RH, BOXNODESIZE);
                        eqtb[BOXBASE + n].hh.v.RH =
                            vpackage(tempptr, 0, ADDITIONAL, 1073741823L);
                    } else {

                        while (mem[s].hh.v.RH != TEXNULL)
                            s = mem[s].hh.v.RH;
                        mem[r + 2].hh.v.RH = s;
                    }
                }
                /* comment:Either append the insertion node |p| after node |q */
                mem[prevp].hh.v.RH = mem[p].hh.v.RH;
                mem[p].hh.v.RH = TEXNULL;
                if (wait) {
                    mem[q].hh.v.RH = p;
                    q = p;
                    incr(insertpenalties);
                } else {

                    deleteglueref(mem[p + 4].hh.v.RH);
                    freenode(p, INSNODESIZE);
                }
                p = prevp;
            }
        } else if (mem[p].hh.b0 == MARKNODE) {

            if (mem[p + 1].hh.v.LH !=
                0) /* comment:Update the current marks for |fire_up| */
            {
                findsaelement(MARKVAL, mem[p + 1].hh.v.LH, true);
                if (mem[curptr + 1].hh.v.RH == TEXNULL) {
                    mem[curptr + 1].hh.v.RH = mem[p + 1].hh.v.RH;
                    incr(mem[mem[p + 1].hh.v.RH].hh.v.LH);
                }
                if (mem[curptr + 2].hh.v.LH != TEXNULL)
                    deletetokenref(mem[curptr + 2].hh.v.LH);
                mem[curptr + 2].hh.v.LH = mem[p + 1].hh.v.RH;
                incr(mem[mem[p + 1].hh.v.RH].hh.v.LH);
            } else /* comment:Update the values of |first_mark| and |bot_mark|
                    */
            {

                if (curmark[FIRSTMARKCODE] == TEXNULL) {
                    curmark[FIRSTMARKCODE] = mem[p + 1].hh.v.RH;
                    incr(mem[curmark[FIRSTMARKCODE]].hh.v.LH);
                }
                if (curmark[BOTMARKCODE] != TEXNULL)
                    deletetokenref(curmark[BOTMARKCODE]);
                curmark[BOTMARKCODE] = mem[p + 1].hh.v.RH;
                incr(mem[curmark[BOTMARKCODE]].hh.v.LH);
            }
        }
        prevp = p;
        p = mem[prevp].hh.v.RH;
    }
    eqtb[GLUEBASE + SPLITTOPSKIPCODE].hh.v.RH = savesplittopskip;
    /* comment:Break the current page at node |p|, put it in box~ */
    if (p != TEXNULL) {
        if (mem[memtop - 1].hh.v.RH == TEXNULL) {

            if (nestptr == 0)
                curlist.tailfield = pagetail;
            else
                nest[0].tailfield = pagetail;
        }
        mem[pagetail].hh.v.RH = mem[memtop - 1].hh.v.RH;
        mem[memtop - 1].hh.v.RH = p;
        mem[prevp].hh.v.RH = TEXNULL;
    }
    savevbadness = eqtb[INTBASE + VBADNESSCODE].cint;
    eqtb[INTBASE + VBADNESSCODE].cint = INFBAD;
    savevfuzz = eqtb[DIMENBASE + VFUZZCODE].cint;
    eqtb[DIMENBASE + VFUZZCODE].cint = 1073741823L;
    eqtb[/* @d11119@ */ 27688].hh.v.RH =
        vpackage(mem[memtop - 2].hh.v.RH, bestsize, EXACTLY, pagemaxdepth);
    eqtb[INTBASE + VBADNESSCODE].cint = savevbadness;
    eqtb[DIMENBASE + VFUZZCODE].cint = savevfuzz;
    if (lastglue != 2147483647L)
        deleteglueref(lastglue);
    /* comment:Start a new current page */ pagecontents = EMPTY;
    pagetail = memtop - 2;
    mem[memtop - 2].hh.v.RH = TEXNULL;
    lastglue = 2147483647L;
    lastpenalty = 0;
    lastkern = 0;
    lastnodetype = -1;
    pagesofar[7] = 0;
    pagemaxdepth = 0;
    if (q != memtop - 4) {
        mem[memtop - 2].hh.v.RH = mem[memtop - 4].hh.v.RH;
        pagetail = q;
    }
    /* comment:Delete \(t)the page-insertion nodes */ r = mem[memtop].hh.v.RH;
    while (r != memtop) {

        q = mem[r].hh.v.RH;
        freenode(r, PAGEINSNODESIZE);
        r = q;
    }
    mem[memtop].hh.v.RH = memtop;
    if (saroot[MARKVAL] != TEXNULL) {

        if (domarks(2, 0, saroot[MARKVAL]))
            saroot[MARKVAL] = TEXNULL;
    }
    if ((curmark[TOPMARKCODE] != TEXNULL) &&
        (curmark[FIRSTMARKCODE] == TEXNULL)) {
        curmark[FIRSTMARKCODE] = curmark[TOPMARKCODE];
        incr(mem[curmark[TOPMARKCODE]].hh.v.LH);
    }
    if (eqtb[OUTPUTROUTINELOC].hh.v.RH != TEXNULL) {

        if (deadcycles >= eqtb[INTBASE + MAXDEADCYCLESCODE]
                              .cint) /* comment:Explain that too many dead
                                        cycles have occurred in */
        {
            {
                if (interaction == ERRORSTOPMODE)
                    ;
                if (filelineerrorstylep)
                    printfileline();
                else
                    printnl(/* str '! ' */ 264);
                print(/* str 'Output loop---' */ 1420);
            }
            printint(deadcycles);
            print(/* str ' consecutive dead cycles' */ 1421);
            {
                helpptr = 3;
                helpline[2] = /* str 'I've concluded that your \output is awry;
                                 it neve' */
                    1422;
                helpline[1] = /* str '\shipout, so I'm shipping \box255 out
                                 myself. Nex' */
                    1423;
                helpline[0] = /* str 'increase \maxdeadcycles if you want me to
                                 be more' */
                    1424;
            }
            error();
        } else /* comment:Fire up the user's output routine and |return| */ {

            outputactive = true;
            incr(deadcycles);
            pushnest();
            curlist.modefield = /* @d11149@ */ -1;
            curlist.auxfield.cint = eqtb[DIMENBASE + PDFIGNOREDDIMENCODE].cint;
            curlist.mlfield = -(integer)line;
            begintokenlist(eqtb[OUTPUTROUTINELOC].hh.v.RH, OUTPUTTEXT);
            newsavelevel(OUTPUTGROUP);
            normalparagraph();
            scanleftbrace();
            return;
        }
    }
    /* comment:Perform the default output routine */ {

        if (mem[memtop - 2].hh.v.RH != TEXNULL) {
            if (mem[memtop - 1].hh.v.RH == TEXNULL) {

                if (nestptr == 0)
                    curlist.tailfield = pagetail;
                else
                    nest[0].tailfield = pagetail;
            } else
                mem[pagetail].hh.v.RH = mem[memtop - 1].hh.v.RH;
            mem[memtop - 1].hh.v.RH = mem[memtop - 2].hh.v.RH;
            mem[memtop - 2].hh.v.RH = TEXNULL;
            pagetail = memtop - 2;
        }
        flushnodelist(discptr[LASTBOXCODE]);
        discptr[LASTBOXCODE] = TEXNULL;
        shipout(eqtb[/* @d11159@ */ 27688].hh.v.RH);
        eqtb[/* @d11160@ */ 27688].hh.v.RH = TEXNULL;
    }
}
void buildpage(void) {
    /* @d11162@ */ /* @d11163@ */ /* @d11164@ */ /* @d11165@ */ /* @d11166@ */
    buildpage_regmem halfword p;
    halfword q, r;
    integer b, c;
    integer pi;
    unsigned char n;
    scaled delta, h, w;
    if ((mem[memtop - 1].hh.v.RH == TEXNULL) || outputactive)
        return;
    do {
    labbuildpage22continue:
        p = mem[memtop - 1].hh.v.RH;
        /* comment:Update the values of |last_glue|, |last_penalty|,  */
        if (lastglue != 2147483647L)
            deleteglueref(lastglue);
        lastpenalty = 0;
        lastkern = 0;
        lastnodetype = mem[p].hh.b0 + 1;
        if (mem[p].hh.b0 == GLUENODE) {
            lastglue = mem[p + 1].hh.v.LH;
            incr(mem[lastglue].hh.v.RH);
        } else {

            lastglue = 2147483647L;
            if (mem[p].hh.b0 == PENALTYNODE)
                lastpenalty = mem[p + 1].cint;
            else if (mem[p].hh.b0 == KERNNODE)
                lastkern = mem[p + WIDTHOFFSET].cint;
        }
        /* comment:Move node |p| to the current page; if it is time f */
        /* comment:If the current page is empty and node |p| is to be */
        switch (mem[p].hh.b0) {
        case HLISTNODE:
        case VLISTNODE:
        case RULENODE:
            if (pagecontents < BOXTHERE) /* comment:Initialize the current page,
                                            insert the \.{\\topsk */
            {
                if (pagecontents == EMPTY)
                    freezepagespecs(BOXTHERE);
                else
                    pagecontents = BOXTHERE;
                q = newskipparam(TOPSKIPCODE);
                if (mem[tempptr + WIDTHOFFSET].cint >
                    mem[p + HEIGHTOFFSET].cint)
                    mem[tempptr + WIDTHOFFSET].cint =
                        mem[tempptr + WIDTHOFFSET].cint -
                        mem[p + HEIGHTOFFSET].cint;
                else
                    mem[tempptr + WIDTHOFFSET].cint = 0;
                mem[q].hh.v.RH = p;
                mem[memtop - 1].hh.v.RH = q;
                goto labbuildpage22continue;
            } else /* comment:Prepare to move a box or rule node to the current
                    */
            {

                pagesofar[1] =
                    pagesofar[1] + pagesofar[7] + mem[p + HEIGHTOFFSET].cint;
                pagesofar[7] = mem[p + DEPTHOFFSET].cint;
                goto labbuildpage80contribute;
            }
            break;
        case WHATSITNODE:
            if ((pagecontents < BOXTHERE) &&
                ((mem[p].hh.b1 == /* @d11200@ */ 35) ||
                 (mem[p].hh.b1 == /* @d11201@ */ 36))) {
                print(/* str 'snap node being discarded' */ 1373);
                goto labbuildpage31done1;
            } else /* comment:Prepare to move whatsit |p| to the current page, t
                    */
            {

                if ((mem[p].hh.b1 == /* @d11205@ */ 10) ||
                    (mem[p].hh.b1 == /* @d11206@ */ 12)) {
                    pagesofar[1] =
                        pagesofar[1] + pagesofar[7] + mem[p + 2].cint;
                    pagesofar[7] = mem[p + 3].cint;
                }
                goto labbuildpage80contribute;
            }
            break;
        case GLUENODE:
            if (pagecontents < BOXTHERE)
                goto labbuildpage31done1;
            else if ((mem[pagetail].hh.b0 < MATHNODE))
                pi = 0;
            else
                goto labbuildpage90update_heights;
            break;
        case KERNNODE:
            if (pagecontents < BOXTHERE)
                goto labbuildpage31done1;
            else if (mem[p].hh.v.RH == TEXNULL)
                return;
            else if (mem[mem[p].hh.v.RH].hh.b0 == GLUENODE)
                pi = 0;
            else
                goto labbuildpage90update_heights;
            break;
        case PENALTYNODE:
            if (pagecontents < BOXTHERE)
                goto labbuildpage31done1;
            else
                pi = mem[p + 1].cint;
            break;
        case MARKNODE:
            goto labbuildpage80contribute;
            break;
        case INSNODE:
            /* comment:Append an insertion to the current page and |goto  */ {

                if (pagecontents == EMPTY)
                    freezepagespecs(INSERTSONLY);
                n = mem[p].hh.b1;
                r = memtop;
                while (n >= mem[mem[r].hh.v.RH].hh.b1)
                    r = mem[r].hh.v.RH;
                n = n;
                if (mem[r].hh.b1 != n) /* comment:Create a page insertion node
                                          with |subtype(r)=qi(n */
                {
                    q = getnode(PAGEINSNODESIZE);
                    mem[q].hh.v.RH = mem[r].hh.v.RH;
                    mem[r].hh.v.RH = q;
                    r = q;
                    mem[r].hh.b1 = n;
                    mem[r].hh.b0 = INSERTING;
                    ensurevbox(n);
                    if (eqtb[BOXBASE + n].hh.v.RH == TEXNULL)
                        mem[r + HEIGHTOFFSET].cint = 0;
                    else
                        mem[r + HEIGHTOFFSET].cint =
                            mem[eqtb[BOXBASE + n].hh.v.RH /* @d11235@
                                                           */
                                + 3]
                                .cint +
                            mem[eqtb[BOXBASE + n].hh.v.RH /* @d11237@
                                                           */
                                + 2]
                                .cint;
                    mem[r + 2].hh.v.LH = TEXNULL;
                    q = eqtb[SKIPBASE + n].hh.v.RH;
                    if (eqtb[COUNTBASE + n].cint == 1000)
                        h = mem[r + HEIGHTOFFSET].cint;
                    else
                        h = xovern(mem[r + HEIGHTOFFSET].cint, 1000) *
                            eqtb[COUNTBASE + n].cint;
                    pagesofar[0] = pagesofar[0] - h - mem[q + WIDTHOFFSET].cint;
                    pagesofar[2 + mem[q].hh.b0] =
                        pagesofar[2 + mem[q].hh.b0] + mem[q + 2].cint;
                    pagesofar[6] = pagesofar[6] + mem[q + 3].cint;
                    if ((mem[q].hh.b1 != NORMAL) && (mem[q + 3].cint != 0)) {
                        {
                            if (interaction == ERRORSTOPMODE)
                                ;
                            if (filelineerrorstylep)
                                printfileline();
                            else
                                printnl(/* str '! ' */ 264);
                            print(/* str 'Infinite glue shrinkage inserted from
                                     ' */
                                  1413);
                        }
                        printesc(/* str 'skip' */ 412);
                        printint(n);
                        {
                            helpptr = 3;
                            helpline[2] = /* str 'The correction glue for page
                                             breaking with insert' */
                                1414;
                            helpline[1] =
                                /* str 'must have finite shrinkability. But you
                                   may proce' */
                                1415;
                            helpline[0] = /* str 'since the offensive
                                             shrinkability has been made f' */
                                1332;
                        }
                        error();
                    }
                }
                if (mem[r].hh.b0 == SPLITUP)
                    insertpenalties = insertpenalties + mem[p + 1].cint;
                else {

                    mem[r + 2].hh.v.RH = p;
                    delta = pagesofar[0] - pagesofar[1] - pagesofar[7] +
                            pagesofar[6];
                    if (eqtb[COUNTBASE + n].cint == 1000)
                        h = mem[p + HEIGHTOFFSET].cint;
                    else
                        h = xovern(mem[p + HEIGHTOFFSET].cint, 1000) *
                            eqtb[COUNTBASE + n].cint;
                    if (((h <= 0) || (h <= delta)) &&
                        (mem[p + HEIGHTOFFSET].cint +
                             mem[r + HEIGHTOFFSET].cint <=
                         eqtb[SCALEDBASE + n].cint)) {
                        pagesofar[0] = pagesofar[0] - h;
                        mem[r + HEIGHTOFFSET].cint =
                            mem[r + HEIGHTOFFSET].cint +
                            mem[p + HEIGHTOFFSET].cint;
                    } else /* comment:Find the best way to split the insertion,
                              and chan */
                    {

                        if (eqtb[COUNTBASE + n].cint <= 0)
                            w = 1073741823L;
                        else {

                            w = pagesofar[0] - pagesofar[1] - pagesofar[7];
                            if (eqtb[COUNTBASE + n].cint != 1000)
                                w = xovern(w, eqtb[COUNTBASE + n].cint) * 1000;
                        }
                        if (w > eqtb[SCALEDBASE + n].cint -
                                    mem[r + HEIGHTOFFSET].cint)
                            w = eqtb[SCALEDBASE + n].cint -
                                mem[r + HEIGHTOFFSET].cint;
                        q = vertbreak(mem[p + 4].hh.v.LH, w,
                                      mem[p + DEPTHOFFSET].cint);
                        mem[r + HEIGHTOFFSET].cint =
                            mem[r + HEIGHTOFFSET].cint + bestheightplusdepth;
                        ;
#ifdef STAT
                        if (eqtb[INTBASE + TRACINGPAGESCODE].cint >
                            0) /* comment:Display the insertion split cost */
                        {
                            begindiagnostic();
                            printnl(/* str '% split' */ 1416);
                            printint(n);
                            print(/* str ' to ' */ 1417);
                            printscaled(w);
                            printchar(/* str ',' */ 44);
                            printscaled(bestheightplusdepth);
                            print(/* str ' p=' */ 1345);
                            if (q == TEXNULL)
                                printint(/* @d11281@ */ -10000);
                            else if (mem[q].hh.b0 == PENALTYNODE)
                                printint(mem[q + 1].cint);
                            else
                                printchar(/* str '0' */ 48);
                            enddiagnostic(false);
                        }
#endif /* STAT */
                        if (eqtb[COUNTBASE + n].cint != 1000)
                            bestheightplusdepth =
                                xovern(bestheightplusdepth, 1000) *
                                eqtb[COUNTBASE + n].cint;
                        pagesofar[0] = pagesofar[0] - bestheightplusdepth;
                        mem[r].hh.b0 = SPLITUP;
                        mem[r + 1].hh.v.RH = q;
                        mem[r + 1].hh.v.LH = p;
                        if (q == TEXNULL)
                            insertpenalties =
                                /* @d11287@ */ insertpenalties - 10000;
                        else if (mem[q].hh.b0 == PENALTYNODE)
                            insertpenalties = insertpenalties + mem[q + 1].cint;
                    }
                }
                goto labbuildpage80contribute;
            }
            break;
        default:
            confusion(/* str 'page' */ 889);
            break;
        }
        /* comment:Check if node |p| is a new champion breakpoint; th */
        if (pi < INFPENALTY) {
            /* comment:Compute the badness, |b|, of the current page, usi */
            if (pagesofar[1] < pagesofar[0]) {

                if ((pagesofar[3] != 0) || (pagesofar[4] != 0) ||
                    (pagesofar[5] != 0))
                    b = 0;
                else
                    b = badness(pagesofar[0] - pagesofar[1], pagesofar[2]);
            } else if (pagesofar[1] - pagesofar[0] > pagesofar[6])
                b = 1073741823L;
            else
                b = badness(pagesofar[1] - pagesofar[0], pagesofar[6]);
            if (b < 1073741823L) {

                if (pi <= /* @d11294@ */ -10000)
                    c = pi;
                else if (b < INFBAD)
                    c = b + pi + insertpenalties;
                else
                    c = 100000L;
            } else
                c = b;
            if (insertpenalties >= 10000)
                c = 1073741823L;
            ;
#ifdef STAT
            if (eqtb[INTBASE + TRACINGPAGESCODE].cint >
                0) /* comment:Display the page break cost */
            {
                begindiagnostic();
                printnl(/* str '%' */ 37);
                print(/* str ' t=' */ 1341);
                printtotals();
                print(/* str ' g=' */ 1411);
                printscaled(pagesofar[0]);
                print(/* str ' b=' */ 1344);
                if (b == 1073741823L)
                    printchar(/* str '' */ 42);
                else
                    printint(b);
                print(/* str ' p=' */ 1345);
                printint(pi);
                print(/* str ' c=' */ 1412);
                if (c == 1073741823L)
                    printchar(/* str '' */ 42);
                else
                    printint(c);
                if (c <= leastpagecost)
                    printchar(/* str '#' */ 35);
                enddiagnostic(false);
            }
#endif /* STAT */
            if (c <= leastpagecost) {
                bestpagebreak = p;
                bestsize = pagesofar[0];
                leastpagecost = c;
                r = mem[memtop].hh.v.RH;
                while (r != memtop) {

                    mem[r + 2].hh.v.LH = mem[r + 2].hh.v.RH;
                    r = mem[r].hh.v.RH;
                }
            }
            if ((c == 1073741823L) || (pi <= /* @d11308@ */ -10000)) {
                fireup(p);
                if (outputactive)
                    return;
                goto labbuildpage30done;
            }
        }
        if ((mem[p].hh.b0 < GLUENODE) || (mem[p].hh.b0 > KERNNODE))
            goto labbuildpage80contribute;
    labbuildpage90update_heights
        : /* comment:Update the current page measurements with respect  */
        if (mem[p].hh.b0 == KERNNODE)
            q = p;
        else {

            q = mem[p + 1].hh.v.LH;
            pagesofar[2 + mem[q].hh.b0] =
                pagesofar[2 + mem[q].hh.b0] + mem[q + 2].cint;
            pagesofar[6] = pagesofar[6] + mem[q + 3].cint;
            if ((mem[q].hh.b1 != NORMAL) && (mem[q + 3].cint != 0)) {
                {
                    if (interaction == ERRORSTOPMODE)
                        ;
                    if (filelineerrorstylep)
                        printfileline();
                    else
                        printnl(/* str '! ' */ 264);
                    print(/* str 'Infinite glue shrinkage found on current page'
                           */
                          1409);
                }
                {
                    helpptr = 4;
                    helpline[3] = /* str 'The page about to be output contains
                                     some infinit' */
                        1410;
                    helpline[2] = /* str 'shrinkable glue, e.g., `\vss' or
                                     `\vskip 0pt minu' */
                        1379;
                    helpline[1] = /* str 'Such glue doesn't belong there; but
                                     you can safel' */
                        1380;
                    helpline[0] = /* str 'since the offensive shrinkability has
                                     been made f' */
                        1332;
                }
                error();
                r = newspec(q);
                mem[r].hh.b1 = NORMAL;
                deleteglueref(q);
                mem[p + 1].hh.v.LH = r;
                q = r;
            }
        }
        pagesofar[1] = pagesofar[1] + pagesofar[7] + mem[q + WIDTHOFFSET].cint;
        pagesofar[7] = 0;
    labbuildpage80contribute
        : /* comment:Make sure that |page_max_depth| is not exceeded */
        if (pagesofar[7] > pagemaxdepth) {
            pagesofar[1] = pagesofar[1] + pagesofar[7] - pagemaxdepth;
            pagesofar[7] = pagemaxdepth;
        }
        /* comment:Link node |p| into the current page and |goto done */ mem
            [pagetail]
                .hh.v.RH = p;
        pagetail = p;
        mem[memtop - 1].hh.v.RH = mem[p].hh.v.RH;
        mem[p].hh.v.RH = TEXNULL;
        goto labbuildpage30done;
    labbuildpage31done1: /* comment:Recycle node |p| */
        mem[memtop - 1].hh.v.RH = mem[p].hh.v.RH;
        mem[p].hh.v.RH = TEXNULL;
        if (eqtb[INTBASE + SAVINGVDISCARDSCODE].cint > 0) {
            if (discptr[LASTBOXCODE] == TEXNULL)
                discptr[LASTBOXCODE] = p;
            else
                mem[discptr[COPYCODE]].hh.v.RH = p;
            discptr[COPYCODE] = p;
        } else
            flushnodelist(p);
    labbuildpage30done:;
    } while (!(mem[memtop - 1].hh.v.RH == TEXNULL));
    /* comment:Make the contribution list empty by setting its ta */
    if (nestptr == 0)
        curlist.tailfield = memtop - 1;
    else
        nest[0].tailfield = memtop - 1;
}
/* comment:Declare action procedures for use by |main_control */ void
appspace(void) {
    appspace_regmem halfword q;
    if ((curlist.auxfield.hh.v.LH >= 2000) &&
        (eqtb[GLUEBASE + XSPACESKIPCODE].hh.v.RH != membot))
        q = newparamglue(XSPACESKIPCODE);
    else {

        if (eqtb[GLUEBASE + SPACESKIPCODE].hh.v.RH != membot)
            mainp = eqtb[GLUEBASE + SPACESKIPCODE].hh.v.RH;
        else /* comment:Find the glue specification, |main_p|, for text sp */ {

            mainp = fontglue[eqtb[CURFONTLOC].hh.v.RH];
            if (mainp == TEXNULL) {
                mainp = newspec(membot);
                maink = parambase[eqtb[CURFONTLOC].hh.v.RH] /* @d11353@ */
                        + 2;
                mem[mainp + WIDTHOFFSET].cint = fontinfo[maink].cint;
                mem[mainp + 2].cint = fontinfo[maink + 1].cint;
                mem[mainp + 3].cint = fontinfo[maink + 2].cint;
                fontglue[eqtb[CURFONTLOC].hh.v.RH] = mainp;
            }
        }
        mainp = newspec(mainp);
        /* comment:Modify the glue specification in |main_p| accordin */
        if (curlist.auxfield.hh.v.LH >= 2000)
            mem[mainp + WIDTHOFFSET].cint =
                mem[mainp + WIDTHOFFSET].cint +
                fontinfo[EXTRASPACECODE + parambase[eqtb[CURFONTLOC].hh.v.RH]]
                    .cint;
        mem[mainp + 2].cint =
            xnoverd(mem[mainp + 2].cint, curlist.auxfield.hh.v.LH, 1000);
        mem[mainp + 3].cint =
            xnoverd(mem[mainp + 3].cint, 1000, curlist.auxfield.hh.v.LH);
        q = newglue(mainp);
        mem[q].hh.me = curchrsig;
        mem[mainp].hh.v.RH = TEXNULL;
    }
    mem[curlist.tailfield].hh.v.RH = q;
    curlist.tailfield = q;
}
void insertdollarsign(void) {
    insertdollarsign_regmem backinput();
    curtok = /* @d11361@ */ /* str '$' */ 804;
    {
        if (interaction == ERRORSTOPMODE)
            ;
        if (filelineerrorstylep)
            printfileline();
        else
            printnl(/* str '! ' */ 264);
        print(/* str 'Missing $ inserted' */ 1432);
    }
    {
        helpptr = 2;
        helpline[1] =
            /* str 'I've inserted a begin-mathend-math symbol since ' */ 1433;
        helpline[0] =
            /* str 'you left one out. Proceed, with fingers crossed.' */ 1434;
    }
    inserror();
}
void youcant(void) {
    youcant_regmem {
        if (interaction == ERRORSTOPMODE)
            ;
        if (filelineerrorstylep)
            printfileline();
        else
            printnl(/* str '! ' */ 264);
        print(/* str 'You can't use `' */ 786);
    }
    printcmdchr(curcmd, curchr);
    printinmode(curlist.modefield);
}
void reportillegalcase(void) {
    reportillegalcase_regmem youcant();
    {
        helpptr = 4;
        helpline[3] =
            /* str 'Sorry, but I'm not programmed to handle this case' */ 1435;
        helpline[2] =
            /* str 'I'll just pretend that you didn't ask for it.' */ 1436;
        helpline[1] =
            /* str 'If you're in the wrong mode, you might be able to' */ 1437;
        helpline[0] =
            /* str 'return to the right one by typing `I}' or `I$' or' */ 1438;
    }
    error();
}
boolean privileged(void) {
    register boolean Result;
    privileged_regmem if (curlist.modefield > 0) Result = true;
    else {

        reportillegalcase();
        Result = false;
    }
    return Result;
}
boolean itsallover(void) {
    register boolean Result;
    itsallover_regmem if (privileged()) {
        if ((memtop - 2 == pagetail) &&
            (curlist.headfield == curlist.tailfield) && (deadcycles == 0)) {
            Result = true;
            return Result;
        }
        backinput();
        {
            mem[curlist.tailfield].hh.v.RH = newnullbox();
            curlist.tailfield = mem[curlist.tailfield].hh.v.RH;
        }
        mem[curlist.tailfield /* @d11377@ */ + 1].cint =
            eqtb[DIMENBASE + HSIZECODE].cint;
        {
            mem[curlist.tailfield].hh.v.RH =
                newglue(/* @d11380@ */ /* @d11381@ */ membot + 8);
            curlist.tailfield = mem[curlist.tailfield].hh.v.RH;
        }
        {
            mem[curlist.tailfield].hh.v.RH = newpenalty(-1073741824L);
            curlist.tailfield = mem[curlist.tailfield].hh.v.RH;
        }
        buildpage();
    }
    Result = false;
    return Result;
}
void appendglue(void) {
    appendglue_regmem smallnumber s;
    s = curchr;
    switch (s) {
    case FILCODE:
        curval = membot + GLUESPECSIZE;
        break;
    case FILLCODE:
        curval = /* @d11386@ */ /* @d11387@ */ membot + 8;
        break;
    case SSCODE:
        curval = /* @d11389@ */ /* @d11390@ */ /* @d11391@ */ membot + 12;
        break;
    case FILNEGCODE:
        curval =
            /* @d11393@ */ /* @d11394@ */ /* @d11395@ */ /* @d11396@ */ membot +
            16;
        break;
    case SKIPCODE:
        scanglue(GLUEVAL);
        break;
    case MSKIPCODE:
        scanglue(MUVAL);
        break;
    }
    {
        mem[curlist.tailfield].hh.v.RH = newglue(curval);
        curlist.tailfield = mem[curlist.tailfield].hh.v.RH;
    }
    if (s >= SKIPCODE) {
        decr(mem[curval].hh.v.RH);
        if (s > SKIPCODE)
            mem[curlist.tailfield].hh.b1 = MUGLUE;
    }
}
void appendkern(void) {
    appendkern_regmem quarterword s;
    s = curchr;
    scandimen(s == MUGLUE, false, false);
    {
        mem[curlist.tailfield].hh.v.RH = newkern(curval);
        curlist.tailfield = mem[curlist.tailfield].hh.v.RH;
    }
    mem[curlist.tailfield].hh.b1 = s;
}
void offsave(void) {
    offsave_regmem halfword p;
    if (curgroup == BOTTOMLEVEL) /* comment:Drop current token and complain
                                         that it was unmatc */
    {
        {
            if (interaction == ERRORSTOPMODE)
                ;
            if (filelineerrorstylep)
                printfileline();
            else
                printnl(/* str '! ' */ 264);
            print(/* str 'Extra ' */ 932);
        }
        printcmdchr(curcmd, curchr);
        {
            helpptr = 1;
            helpline[0] =
                /* str 'Things are pretty mixed up, but I think the worst' */
                1456;
        }
        error();
    } else {

        backinput();
        p = getavail();
        mem[memtop - 3].hh.v.RH = p;
        {
            if (interaction == ERRORSTOPMODE)
                ;
            if (filelineerrorstylep)
                printfileline();
            else
                printnl(/* str '! ' */ 264);
            print(/* str 'Missing ' */ 712);
        }
        /* comment:Prepare to insert a token that matches |cur_group| */
        switch (curgroup) {
        case SEMISIMPLEGROUP: {
            mem[p].hh.v.LH = /* @d11416@ */ 19611;
            printesc(/* str 'endgroup' */ 593);
        } break;
        case MATHSHIFTGROUP: {
            mem[p].hh.v.LH = /* @d11419@ */ /* str '$' */ 804;
            printchar(/* str '$' */ 36);
        } break;
        case MATHLEFTGROUP: {
            mem[p].hh.v.LH = /* @d11423@ */ 19612;
            mem[p].hh.v.RH = getavail();
            p = mem[p].hh.v.RH;
            mem[p].hh.v.LH = /* @d11424@ */ /* str '.' */ 3118;
            printesc(/* str 'right.' */ 1455);
        } break;
        default: {
            mem[p].hh.v.LH = /* @d11427@ */ /* str '}' */ 637;
            printchar(/* str '}' */ 125);
        } break;
        }
        print(/* str ' inserted' */ 713);
        begintokenlist(mem[memtop - 3].hh.v.RH, INSERTED);
        {
            helpptr = 5;
            helpline[4] =
                /* str 'I've inserted something that you may have forgott' */
                1450;
            helpline[3] = /* str '(See the <inserted text> above.)' */ 1451;
            helpline[2] =
                /* str 'With luck, this will get me unwedged. But if you' */
                1452;
            helpline[1] =
                /* str 'really didn't forget anything, try typing `2' now' */
                1453;
            helpline[0] =
                /* str 'my insertion and my current dilemma will both dis' */
                1454;
        }
        error();
    }
}
void extrarightbrace(void) {
    extrarightbrace_regmem {
        if (interaction == ERRORSTOPMODE)
            ;
        if (filelineerrorstylep)
            printfileline();
        else
            printnl(/* str '! ' */ 264);
        print(/* str 'Extra }, or forgotten ' */ 1461);
    }
    switch (curgroup) {
    case SEMISIMPLEGROUP:
        printesc(/* str 'endgroup' */ 593);
        break;
    case MATHSHIFTGROUP:
        printchar(/* str '$' */ 36);
        break;
    case MATHLEFTGROUP:
        printesc(/* str 'right' */ 1286);
        break;
    }
    {
        helpptr = 5;
        helpline[4] =
            /* str 'I've deleted a group-closing symbol because it se' */ 1462;
        helpline[3] =
            /* str 'spurious, as in `$x}$'. But perhaps the } is legi' */ 1463;
        helpline[2] =
            /* str 'you forgot something else, as in `\hbox{$x}'. In ' */ 1464;
        helpline[1] =
            /* str 'the way to recover is to insert both the forgotte' */ 1465;
        helpline[0] = /* str 'deleted material, e.g., by typing `I$}'.' */ 1466;
    }
    error();
    incr(alignstate);
}
void normalparagraph(void) {
    normalparagraph_regmem if (eqtb[INTBASE + LOOSENESSCODE].cint != 0)
        eqworddefine(/* @d11453@ */ /* @d11454@ */ 29296, 0);
    if (eqtb[DIMENBASE + HANGINDENTCODE].cint != 0)
        eqworddefine(/* @d11457@ */ /* @d11458@ */ 29911, 0);
    if (eqtb[INTBASE + HANGAFTERCODE].cint != 1)
        eqworddefine(/* @d11461@ */ /* @d11462@ */ 29318, 1);
    if (eqtb[PARSHAPELOC].hh.v.RH != TEXNULL)
        eqdefine(PARSHAPELOC, SHAPEREF, TEXNULL);
    if (eqtb[INTERLINEPENALTIESLOC].hh.v.RH != TEXNULL)
        eqdefine(INTERLINEPENALTIESLOC, SHAPEREF, TEXNULL);
}
void zboxend(integer boxcontext) {
    boxend_regmem halfword p;
    smallnumber a;
    if (boxcontext < 1073741824L) /* comment:Append box |cur_box| to the current
                                     list, shifted  */
    {
        if (curbox != TEXNULL) {
            mem[curbox + 4].cint = boxcontext;
            if (abs(curlist.modefield) == VMODE) {
                if (preadjusttail != TEXNULL) {
                    if (memtop - 14 != preadjusttail) {
                        mem[curlist.tailfield].hh.v.RH =
                            mem[memtop - 14].hh.v.RH;
                        curlist.tailfield = preadjusttail;
                    }
                    preadjusttail = TEXNULL;
                }
                appendtovlist(curbox);
                if (adjusttail != TEXNULL) {
                    if (memtop - 5 != adjusttail) {
                        mem[curlist.tailfield].hh.v.RH =
                            mem[memtop - 5].hh.v.RH;
                        curlist.tailfield = adjusttail;
                    }
                    adjusttail = TEXNULL;
                }
                if (curlist.modefield > 0)
                    buildpage();
            } else {

                if (abs(curlist.modefield) == HMODE)
                    curlist.auxfield.hh.v.LH = 1000;
                else {

                    p = newnoad();
                    mem[p + 1].hh.v.RH = SUBBOX;
                    mem[p + 1].hh.v.LH = curbox;
                    curbox = p;
                }
                mem[curlist.tailfield].hh.v.RH = curbox;
                curlist.tailfield = curbox;
            }
        }
    } else if (boxcontext <
               1073807360L) /* comment:Store \(c)|cur_box| in a box register */
    {
        if (boxcontext < 1073774592L) {
            curval = boxcontext - 1073741824L;
            a = 0;
        } else {

            curval = boxcontext - 1073774592L;
            a = 4;
        }
        if (curval < 256) {

            if ((a >= 4))
                geqdefine(BOXBASE + curval, BOXREF, curbox);
            else
                eqdefine(BOXBASE + curval, BOXREF, curbox);
        } else {

            findsaelement(4, curval, true);
            if ((a >= 4))
                gsadef(curptr, curbox);
            else
                sadef(curptr, curbox);
        }
    } else if (curbox != TEXNULL) {

        if (boxcontext > 1073807360L) /* comment:Append a new leader node that
                                         uses |cur_box| */
        {
            /* comment:Get the next non-blank non-relax non-call token */ do {
                getxtoken();
            } while (!((curcmd != SPACER) && (curcmd != RELAX)));
            if (((curcmd == HSKIP) && (abs(curlist.modefield) != VMODE)) ||
                ((curcmd == VSKIP) && (abs(curlist.modefield) == VMODE))) {
                appendglue();
                mem[curlist.tailfield].hh.b1 =
                    boxcontext - (/* @d11486@ */ 1073807261L);
                mem[curlist.tailfield + 1].hh.v.RH = curbox;
            } else {

                {
                    if (interaction == ERRORSTOPMODE)
                        ;
                    if (filelineerrorstylep)
                        printfileline();
                    else
                        printnl(/* str '! ' */ 264);
                    print(/* str 'Leaders not followed by proper glue' */ 1479);
                }
                {
                    helpptr = 3;
                    helpline[2] = /* str 'You should say `\leaders <box or
                                     rule><hskip or v' */
                        1480;
                    helpline[1] = /* str 'I found the <box or rule>, but there's
                                     no suitabl' */
                        1481;
                    helpline[0] = /* str '<hskip or vskip>, so I'm ignoring
                                     these leaders.' */
                        1482;
                }
                backerror();
                flushnodelist(curbox);
            }
        } else
            shipout(curbox);
    }
}
void zbeginbox(integer boxcontext) {
    beginbox_regmem halfword p, q;
    halfword r;
    boolean fm;
    halfword tx;
    quarterword m;
    halfword k;
    halfword n;
    switch (curchr) {
    case BOXCODE: {
        scanregisternum();
        if (curval < 256)
            curbox = eqtb[BOXBASE + curval].hh.v.RH;
        else {

            findsaelement(4, curval, false);
            if (curptr == TEXNULL)
                curbox = TEXNULL;
            else
                curbox = mem[curptr + 1].hh.v.RH;
        }
        if (curval < 256)
            eqtb[BOXBASE + curval].hh.v.RH = TEXNULL;
        else {

            findsaelement(4, curval, false);
            if (curptr != TEXNULL) {
                mem[curptr + 1].hh.v.RH = TEXNULL;
                incr(mem[curptr + 1].hh.v.LH);
                deletesaref(curptr);
            }
        }
    } break;
    case COPYCODE: {
        scanregisternum();
        if (curval < 256)
            q = eqtb[BOXBASE + curval].hh.v.RH;
        else {

            findsaelement(4, curval, false);
            if (curptr == TEXNULL)
                q = TEXNULL;
            else
                q = mem[curptr + 1].hh.v.RH;
        }
        curbox = copynodelist(q);
    } break;
    case LASTBOXCODE:
        /* comment:If the current list ends with a box node, delete i */ {

            curbox = TEXNULL;
            if (abs(curlist.modefield) == MMODE) {
                youcant();
                {
                    helpptr = 1;
                    helpline[0] =
                        /* str 'Sorry; this \lastbox will be void.' */ 1484;
                }
                error();
            } else if ((curlist.modefield == VMODE) &&
                       (curlist.headfield == curlist.tailfield)) {
                youcant();
                {
                    helpptr = 2;
                    helpline[1] = /* str 'Sorry...I usually can't take things
                                     from the curr' */
                        1485;
                    helpline[0] =
                        /* str 'This \lastbox will therefore be void.' */ 1486;
                }
                error();
            } else {

                tx = curlist.tailfield;
                if (!(tx >= himemmin)) {

                    if ((mem[tx].hh.b0 == MATHNODE) &&
                        (mem[tx].hh.b1 == ENDMCODE)) {
                        r = curlist.headfield;
                        do {
                            q = r;
                            r = mem[q].hh.v.RH;
                        } while (!(r == tx));
                        tx = q;
                    }
                }
                if (!(tx >= himemmin)) {

                    if ((mem[tx].hh.b0 == HLISTNODE) ||
                        (mem[tx].hh.b0 ==
                         VLISTNODE)) /* comment:Remove the last box,
                                               unless it's part of a discret */
                    {
                        q = curlist.headfield;
                        p = TEXNULL;
                        do {
                            r = p;
                            p = q;
                            fm = false;
                            if (!(q >= himemmin)) {

                                if (mem[q].hh.b0 == DISCNODE) {
                                    {
                                        register integer for_end;
                                        m = 1;
                                        for_end = mem[q].hh.b1;
                                        if (m <= for_end)
                                            do
                                                p = mem[p].hh.v.RH;
                                            while (m++ < for_end);
                                    }
                                    if (p == tx)
                                        goto labbeginbox30done;
                                } else if ((mem[q].hh.b0 == MATHNODE) &&
                                           (mem[q].hh.b1 == BEGINMCODE))
                                    fm = true;
                            }
                            q = mem[p].hh.v.RH;
                        } while (!(q == tx));
                        q = mem[tx].hh.v.RH;
                        mem[p].hh.v.RH = q;
                        mem[tx].hh.v.RH = TEXNULL;
                        if (q == TEXNULL) {

                            if (fm)
                                confusion(/* str 'tail1' */ 1483);
                            else
                                curlist.tailfield = p;
                        } else if (fm) {
                            curlist.tailfield = r;
                            mem[r].hh.v.RH = TEXNULL;
                            flushnodelist(p);
                        }
                        curbox = tx;
                        mem[curbox + 4].cint = 0;
                    }
                }
            labbeginbox30done:;
            }
        }
        break;
    case VSPLITCODE:
        /* comment:Split off part of a vertical box, make |cur_box| p */ {

            scanregisternum();
            n = curval;
            if (!scankeyword(/* str 'to' */ 1245)) {
                {
                    if (interaction == ERRORSTOPMODE)
                        ;
                    if (filelineerrorstylep)
                        printfileline();
                    else
                        printnl(/* str '! ' */ 264);
                    print(/* str 'Missing `to' inserted' */ 1487);
                }
                {
                    helpptr = 2;
                    helpline[1] = /* str 'I'm working on `\vsplit<box number> to
                                     <dimen>';' */
                        1488;
                    helpline[0] =
                        /* str 'will look for the <dimen> next.' */ 1489;
                }
                error();
            }
            scandimen(false, false, false);
            curbox = vsplit(n, curval);
        }
        break;
    default:
        /* comment:Initiate the construction of an hbox or vbox, then */ {

            k = curchr - VTOPCODE;
            savestack[saveptr + 0].cint = boxcontext;
            if (k == HMODE) {

                if ((boxcontext < 1073741824L) &&
                    (abs(curlist.modefield) == VMODE))
                    scanspec(ADJUSTEDHBOXGROUP, true);
                else
                    scanspec(HBOXGROUP, true);
            } else {

                if (k == VMODE)
                    scanspec(VBOXGROUP, true);
                else {

                    scanspec(VTOPGROUP, true);
                    k = VMODE;
                }
                normalparagraph();
            }
            pushnest();
            curlist.modefield = -(integer)k;
            if (k == VMODE) {
                curlist.auxfield.cint =
                    eqtb[DIMENBASE + PDFIGNOREDDIMENCODE].cint;
                if (eqtb[EVERYVBOXLOC].hh.v.RH != TEXNULL)
                    begintokenlist(eqtb[EVERYVBOXLOC].hh.v.RH, EVERYVBOXTEXT);
            } else {

                curlist.auxfield.hh.v.LH = 1000;
                if (eqtb[EVERYHBOXLOC].hh.v.RH != TEXNULL)
                    begintokenlist(eqtb[EVERYHBOXLOC].hh.v.RH, EVERYHBOXTEXT);
            }
            return;
        }
        break;
    }
    boxend(boxcontext);
}
void zscanbox(integer boxcontext) {
    scanbox_regmem
        /* comment:Get the next non-blank non-relax non-call token */ do {
        getxtoken();
    }
    while (!((curcmd != SPACER) && (curcmd != RELAX)))
        ;
    if (curcmd == MAKEBOX)
        beginbox(boxcontext);
    else if ((boxcontext >= 1073807361L) &&
             ((curcmd == HRULE) || (curcmd == /* @d11552@ */
                                    35))) {
        curbox = scanrulespec();
        boxend(boxcontext);
    } else {

        {
            if (interaction == ERRORSTOPMODE)
                ;
            if (filelineerrorstylep)
                printfileline();
            else
                printnl(/* str '! ' */ 264);
            print(/* str 'A <box> was supposed to be here' */ 1490);
        }
        {
            helpptr = 3;
            helpline[2] =
                /* str 'I was expecting to see \hbox or \vbox or \copy or' */
                1491;
            helpline[1] =
                /* str 'something like that. So you might find something ' */
                1492;
            helpline[0] =
                /* str 'your output. But keep trying; you can fix this la' */
                1493;
        }
        backerror();
    }
}
void zpackage(smallnumber c) {
    package_regmem scaled h;
    halfword p;
    scaled d;
    d = eqtb[DIMENBASE + BOXMAXDEPTHCODE].cint;
    unsave();
    saveptr = saveptr - 3;
    if (curlist.modefield == /* @d11561@ */ -104)
        curbox =
            hpack(mem[curlist.headfield].hh.v.RH, savestack[saveptr + 2].cint,
                  savestack[saveptr + 1].cint);
    else {

        curbox = vpackage(mem[curlist.headfield].hh.v.RH,
                          savestack[saveptr + 2].cint,
                          savestack[saveptr + 1].cint, d);
        if (c == VTOPCODE) /* comment:Readjust the height and depth of
                                      |cur_box|, for \. */
        {
            h = 0;
            p = mem[curbox + LISTOFFSET].hh.v.RH;
            if (p != TEXNULL) {

                if (mem[p].hh.b0 <= RULENODE)
                    h = mem[p + HEIGHTOFFSET].cint;
            }
            mem[curbox + DEPTHOFFSET].cint = mem[curbox + DEPTHOFFSET].cint -
                                             h +
                                             mem[curbox + HEIGHTOFFSET].cint;
            mem[curbox + HEIGHTOFFSET].cint = h;
        }
    }
    popnest();
    boxend(savestack[saveptr + 0].cint);
}
smallnumber znormmin(integer h) {
    register smallnumber Result;
    normmin_regmem if (h <= 0) Result = 1;
    else if (h >= 63) Result = 63;
    else Result = h;
    return Result;
}
void znewgraf(boolean indented) {
    newgraf_regmem curlist.pgfield = 0;
    if ((curlist.modefield == VMODE) ||
        (curlist.headfield != curlist.tailfield)) {
        mem[curlist.tailfield].hh.v.RH = newparamglue(PARSKIPCODE);
        curlist.tailfield = mem[curlist.tailfield].hh.v.RH;
    }
    pushnest();
    curlist.modefield = HMODE;
    curlist.auxfield.hh.v.LH = 1000;
    if (eqtb[INTBASE + LANGUAGECODE].cint <= 0)
        curlang = 0;
    else if (eqtb[INTBASE + LANGUAGECODE].cint > 255)
        curlang = 0;
    else
        curlang = eqtb[INTBASE + LANGUAGECODE].cint;
    curlist.auxfield.hh.v.RH = curlang;
    curlist.pgfield = (normmin(eqtb[INTBASE + LEFTHYPHENMINCODE].cint) * 64 +
                       normmin(eqtb[INTBASE + RIGHTHYPHENMINCODE].cint)) *
                          65536L +
                      curlang;
    if (indented) {
        curlist.tailfield = newnullbox();
        mem[curlist.headfield].hh.v.RH = curlist.tailfield;
        mem[curlist.tailfield /* @d11584@ */ + 1].cint =
            eqtb[DIMENBASE + PARINDENTCODE].cint;
        if ((insertsrcspecialeverypar))
            insertsrcspecial();
    }
    if (eqtb[EVERYPARLOC].hh.v.RH != TEXNULL)
        begintokenlist(eqtb[EVERYPARLOC].hh.v.RH, EVERYPARTEXT);
    if (nestptr == 1)
        buildpage();
}
void indentinhmode(void) {
    indentinhmode_regmem halfword p, q;
    if (curchr > 0) {
        p = newnullbox();
        mem[p + WIDTHOFFSET].cint = eqtb[DIMENBASE + PARINDENTCODE].cint;
        if (abs(curlist.modefield) == HMODE)
            curlist.auxfield.hh.v.LH = 1000;
        else {

            q = newnoad();
            mem[q + 1].hh.v.RH = SUBBOX;
            mem[q + 1].hh.v.LH = p;
            p = q;
        }
        {
            mem[curlist.tailfield].hh.v.RH = p;
            curlist.tailfield = mem[curlist.tailfield].hh.v.RH;
        }
    }
}
void headforvmode(void) {
    headforvmode_regmem if (curlist.modefield < 0) {

        if (curcmd != HRULE)
            offsave();
        else {

            {
                if (interaction == ERRORSTOPMODE)
                    ;
                if (filelineerrorstylep)
                    printfileline();
                else
                    printnl(/* str '! ' */ 264);
                print(/* str 'You can't use `' */ 786);
            }
            printesc(/* str 'hrule' */ 600);
            print(/* str '' here except with leaders' */ 1497);
            {
                helpptr = 2;
                helpline[1] = /* str 'To put a horizontal rule in an hbox or an
                                 alignme' */
                    1498;
                helpline[0] = /* str 'you should use \leaders or \hrulefill (see
                                 The Te' */
                    1499;
            }
            error();
        }
    }
    else {

        backinput();
        curtok = partoken;
        backinput();
        curinput.indexfield = INSERTED;
    }
}
void endgraf(void) {
    endgraf_regmem if (curlist.modefield == HMODE) {
        if (curlist.headfield == curlist.tailfield)
            popnest();
        else
            linebreak(false);
        if (curlist.eTeXauxfield != TEXNULL) {
            flushlist(curlist.eTeXauxfield);
            curlist.eTeXauxfield = TEXNULL;
        }
        normalparagraph();
        errorcount = 0;
    }
}
void begininsertoradjust(void) {
    begininsertoradjust_regmem if (curcmd == VADJUST) curval = 255;
    else {

        scaneightbitint();
        if (curval == 255) {
            {
                if (interaction == ERRORSTOPMODE)
                    ;
                if (filelineerrorstylep)
                    printfileline();
                else
                    printnl(/* str '! ' */ 264);
                print(/* str 'You can't ' */ 1500);
            }
            printesc(/* str 'insert' */ 337);
            printint(255);
            {
                helpptr = 1;
                helpline[0] =
                    /* str 'I'm changing to \insert0; box 255 is special.' */
                    1501;
            }
            error();
            curval = 0;
        }
    }
    savestack[saveptr + 0].cint = curval;
    if ((curcmd == VADJUST) && scankeyword(/* str 'pre' */ 1502))
        savestack[saveptr + 1].cint = 1;
    else
        savestack[saveptr + 1].cint = 0;
    saveptr = saveptr + 2;
    newsavelevel(INSERTGROUP);
    scanleftbrace();
    normalparagraph();
    pushnest();
    curlist.modefield = /* @d11614@ */ -1;
    curlist.auxfield.cint = eqtb[DIMENBASE + PDFIGNOREDDIMENCODE].cint;
}
void makemark(void) {
    makemark_regmem halfword p;
    halfword c;
    if (curchr == 0)
        c = 0;
    else {

        scanregisternum();
        c = curval;
    }
    p = scantoks(false, true);
    p = getnode(SMALLNODESIZE);
    mem[p + 1].hh.v.LH = c;
    mem[p].hh.b0 = MARKNODE;
    mem[p].hh.b1 = 0;
    mem[p + 1].hh.v.RH = defref;
    mem[curlist.tailfield].hh.v.RH = p;
    curlist.tailfield = p;
}
void appendpenalty(void) {
    appendpenalty_regmem scanint();
    {
        mem[curlist.tailfield].hh.v.RH = newpenalty(curval);
        curlist.tailfield = mem[curlist.tailfield].hh.v.RH;
    }
    if (curlist.modefield == VMODE)
        buildpage();
}
void deletelast(void) {
    deletelast_regmem halfword p, q;
    halfword r;
    boolean fm;
    halfword tx;
    quarterword m;
    if ((curlist.modefield == VMODE) &&
        (curlist.tailfield ==
         curlist.headfield)) /* comment:Apologize for inability to do the
                                operation now, u */
    {
        if ((curchr != GLUENODE) || (lastglue != 2147483647L)) {
            youcant();
            {
                helpptr = 2;
                helpline[1] = /* str 'Sorry...I usually can't take things from
                                 the curr' */
                    1485;
                helpline[0] = /* str 'Try `I\vskip-\lastskip' instead.' */ 1503;
            }
            if (curchr == KERNNODE)
                helpline[0] =
                    (/* str 'Try `I\kern-\lastkern' instead.' */ 1504);
            else if (curchr != GLUENODE)
                helpline[0] =
                    (/* str 'Perhaps you can make the output routine do it.' */
                     1505);
            error();
        }
    } else {

        tx = curlist.tailfield;
        if (!(tx >= himemmin)) {

            if ((mem[tx].hh.b0 == MATHNODE) && (mem[tx].hh.b1 == ENDMCODE)) {
                r = curlist.headfield;
                do {
                    q = r;
                    r = mem[q].hh.v.RH;
                } while (!(r == tx));
                tx = q;
            }
        }
        if (!(tx >= himemmin)) {

            if (mem[tx].hh.b0 == curchr) {
                q = curlist.headfield;
                p = TEXNULL;
                do {
                    r = p;
                    p = q;
                    fm = false;
                    if (!(q >= himemmin)) {

                        if (mem[q].hh.b0 == DISCNODE) {
                            {
                                register integer for_end;
                                m = 1;
                                for_end = mem[q].hh.b1;
                                if (m <= for_end)
                                    do
                                        p = mem[p].hh.v.RH;
                                    while (m++ < for_end);
                            }
                            if (p == tx)
                                return;
                        } else if ((mem[q].hh.b0 == MATHNODE) &&
                                   (mem[q].hh.b1 == BEGINMCODE))
                            fm = true;
                    }
                    q = mem[p].hh.v.RH;
                } while (!(q == tx));
                q = mem[tx].hh.v.RH;
                mem[p].hh.v.RH = q;
                mem[tx].hh.v.RH = TEXNULL;
                if (q == TEXNULL) {

                    if (fm)
                        confusion(/* str 'tail1' */ 1483);
                    else
                        curlist.tailfield = p;
                } else if (fm) {
                    curlist.tailfield = r;
                    mem[r].hh.v.RH = TEXNULL;
                    flushnodelist(p);
                }
                flushnodelist(tx);
            }
        }
    }
}
void unpackage(void) {
    unpackage_regmem halfword p;
    halfword r;
    unsigned char c;
    if (curchr > COPYCODE) /* comment:Handle saved items and |goto done| */
    {
        mem[curlist.tailfield].hh.v.RH = discptr[curchr];
        discptr[curchr] = TEXNULL;
        goto labunpackage30done;
    }
    c = curchr;
    scanregisternum();
    if (curval < 256)
        p = eqtb[BOXBASE + curval].hh.v.RH;
    else {

        findsaelement(4, curval, false);
        if (curptr == TEXNULL)
            p = TEXNULL;
        else
            p = mem[curptr + 1].hh.v.RH;
    }
    if (p == TEXNULL)
        return;
    if ((abs(curlist.modefield) == MMODE) ||
        ((abs(curlist.modefield) == VMODE) && (mem[p].hh.b0 != VLISTNODE)) ||
        ((abs(curlist.modefield) == /* @d11650@ */
          104) &&
         (mem[p].hh.b0 != HLISTNODE))) {
        {
            if (interaction == ERRORSTOPMODE)
                ;
            if (filelineerrorstylep)
                printfileline();
            else
                printnl(/* str '! ' */ 264);
            print(/* str 'Incompatible list can't be unboxed' */ 1513);
        }
        {
            helpptr = 3;
            helpline[2] = /* str 'Sorry, Pandora. (You sneaky devil.)' */ 1514;
            helpline[1] =
                /* str 'I refuse to unbox an \hbox in vertical mode or vi' */
                1515;
            helpline[0] =
                /* str 'And I can't open any boxes in math mode.' */ 1516;
        }
        error();
        return;
    }
    if (c == COPYCODE)
        mem[curlist.tailfield].hh.v.RH =
            copynodelist(mem[p + LISTOFFSET].hh.v.RH);
    else {

        mem[curlist.tailfield].hh.v.RH = mem[p + LISTOFFSET].hh.v.RH;
        if (curval < 256)
            eqtb[BOXBASE + curval].hh.v.RH = TEXNULL;
        else {

            findsaelement(4, curval, false);
            if (curptr != TEXNULL) {
                mem[curptr + 1].hh.v.RH = TEXNULL;
                incr(mem[curptr + 1].hh.v.LH);
                deletesaref(curptr);
            }
        }
        freenode(p, BOXNODESIZE);
    }
labunpackage30done:
    while (mem[curlist.tailfield].hh.v.RH != TEXNULL) {

        r = mem[curlist.tailfield].hh.v.RH;
        if (!(r >= himemmin) && (mem[r].hh.b0 == MARGINKERNNODE)) {
            mem[curlist.tailfield].hh.v.RH = mem[r].hh.v.RH;
            {
                mem[mem[r + 2].hh.v.LH].hh.v.RH = avail;
                avail = mem[r + 2].hh.v.LH;
                mem[mem[r + 2].hh.v.LH].hh.me = 0;
                ;
#ifdef STAT
                decr(dynused);
#endif /* STAT */
            }
            freenode(r, MARGINKERNNODESIZE);
        }
        curlist.tailfield = mem[curlist.tailfield].hh.v.RH;
    }
}
void appenditaliccorrection(void) {
    appenditaliccorrection_regmem halfword p;
    internalfontnumber f;
    if (curlist.tailfield != curlist.headfield) {
        if ((curlist.tailfield >= himemmin))
            p = curlist.tailfield;
        else if (mem[curlist.tailfield].hh.b0 == LIGATURENODE)
            p = curlist.tailfield + 1;
        else /* @d11670@ */
            return;
        f = mem[p].hh.b0;
        {
            mem[curlist.tailfield].hh.v.RH =
                newkern(fontinfo[italicbase[f] +
                                 (fontinfo[charbase[f] +
                                           effectivechar(true, f, mem[p].hh.b1)]
                                      .qqqq.b2) /
                                     4]
                            .cint);
            curlist.tailfield = mem[curlist.tailfield].hh.v.RH;
        }
        mem[curlist.tailfield].hh.b1 = EXPLICIT;
    }
}
void appenddiscretionary(void) {
    appenddiscretionary_regmem integer c;
    {
        mem[curlist.tailfield].hh.v.RH = newdisc();
        curlist.tailfield = mem[curlist.tailfield].hh.v.RH;
    }
    if (curchr == 1) {
        c = hyphenchar[eqtb[CURFONTLOC].hh.v.RH];
        if (c >= 0) {

            if (c < 256)
                mem[curlist.tailfield + 1].hh.v.LH =
                    newcharacter(eqtb[CURFONTLOC].hh.v.RH, c);
        }
    } else {

        incr(saveptr);
        savestack[saveptr - 1].cint = 0;
        newsavelevel(DISCGROUP);
        scanleftbrace();
        pushnest();
        curlist.modefield = /* @d11676@ */ -104;
        curlist.auxfield.hh.v.LH = 1000;
    }
}
void builddiscretionary(void) {
    builddiscretionary_regmem halfword p, q;
    integer n;
    unsave();
    /* comment:Prune the current list, if necessary, until it con */ q =
        curlist.headfield;
    p = mem[q].hh.v.RH;
    n = 0;
    while (p != TEXNULL) {

        if (!(p >= himemmin)) {

            if (mem[p].hh.b0 > RULENODE) {

                if (mem[p].hh.b0 != KERNNODE) {

                    if (mem[p].hh.b0 != LIGATURENODE) {
                        {
                            if (interaction == ERRORSTOPMODE)
                                ;
                            if (filelineerrorstylep)
                                printfileline();
                            else
                                printnl(/* str '! ' */ 264);
                            print(/* str 'Improper discretionary list' */ 1523);
                        }
                        {
                            helpptr = 1;
                            helpline[0] = /* str 'Discretionary lists must
                                             contain only boxes and k' */
                                1524;
                        }
                        error();
                        begindiagnostic();
                        printnl(/* str 'The following discretionary sublist has
                                   been dele' */
                                1525);
                        showbox(p);
                        enddiagnostic(true);
                        flushnodelist(p);
                        mem[q].hh.v.RH = TEXNULL;
                        goto labbuilddiscretionary30done;
                    }
                }
            }
        }
        q = p;
        p = mem[q].hh.v.RH;
        incr(n);
    }
labbuilddiscretionary30done:;
    p = mem[curlist.headfield].hh.v.RH;
    popnest();
    switch (savestack[saveptr - 1].cint) {
    case 0:
        mem[curlist.tailfield + 1].hh.v.LH = p;
        break;
    case 1:
        mem[curlist.tailfield + 1].hh.v.RH = p;
        break;
    case 2:
        /* comment:Attach list |p| to the current list, and record it */ {

            if ((n > 0) && (abs(curlist.modefield) == MMODE)) {
                {
                    if (interaction == ERRORSTOPMODE)
                        ;
                    if (filelineerrorstylep)
                        printfileline();
                    else
                        printnl(/* str '! ' */ 264);
                    print(/* str 'Illegal math ' */ 1517);
                }
                printesc(/* str 'discretionary' */ 357);
                {
                    helpptr = 2;
                    helpline[1] = /* str 'Sorry' */ 1518;
                    helpline[0] = /* str 'empty, in math formulas. I had to
                                     delete your thi' */
                        1519;
                }
                flushnodelist(p);
                n = 0;
                error();
            } else
                mem[curlist.tailfield].hh.v.RH = p;
            if (n <= MAXQUARTERWORD)
                mem[curlist.tailfield].hh.b1 = n;
            else {

                {
                    if (interaction == ERRORSTOPMODE)
                        ;
                    if (filelineerrorstylep)
                        printfileline();
                    else
                        printnl(/* str '! ' */ 264);
                    print(/* str 'Discretionary list is too long' */ 1520);
                }
                {
                    helpptr = 2;
                    helpline[1] = /* str 'Wow---I never thought anybody would
                                     tweak me here' */
                        1521;
                    helpline[0] = /* str 'You can't seriously need such a huge
                                     discretionar' */
                        1522;
                }
                error();
            }
            if (n > 0)
                curlist.tailfield = q;
            decr(saveptr);
            return;
        }
        break;
    }
    incr(savestack[saveptr - 1].cint);
    newsavelevel(DISCGROUP);
    scanleftbrace();
    pushnest();
    curlist.modefield = /* @d11706@ */ -104;
    curlist.auxfield.hh.v.LH = 1000;
}
void makeaccent(void) {
    makeaccent_regmem real s, t;
    halfword p, q, r;
    internalfontnumber f;
    scaled a, h, x, w, delta;
    fourquarters i;
    scancharnum();
    f = eqtb[CURFONTLOC].hh.v.RH;
    p = newcharacter(f, curval);
    if (p != TEXNULL) {
        x = fontinfo[XHEIGHTCODE + parambase[f]].cint;
        s = fontinfo[SLANTCODE + parambase[f]].cint / ((double)65536.0);
        a = fontinfo[widthbase[f] +
                     fontinfo[charbase[f] +
                              effectivechar(true, f, mem[p].hh.b1)]
                         .qqqq.b0]
                .cint;
        doassignments();
        /* comment:Create a character node |q| for the next character */ q =
            TEXNULL;
        f = eqtb[CURFONTLOC].hh.v.RH;
        if ((curcmd == LETTER) || (curcmd == OTHERCHAR) ||
            (curcmd == CHARGIVEN))
            q = newcharacter(f, curchr);
        else if (curcmd == CHARNUM) {
            scancharnum();
            q = newcharacter(f, curval);
        } else
            backinput();
        if (q != TEXNULL) /* comment:Append the accent with appropriate
                                  kerns, then set */
        {
            t = fontinfo[SLANTCODE + parambase[f]].cint / ((double)65536.0);
            i = fontinfo[charbase[f] + effectivechar(true, f, mem[q].hh.b1)]
                    .qqqq;
            w = fontinfo[widthbase[f] + i.b0].cint;
            h = fontinfo[heightbase[f] + (i.b1) / 16].cint;
            if (h != x) {
                p = hpack(p, 0, ADDITIONAL);
                mem[p + 4].cint = x - h;
            }
            delta = round((w - a) / ((double)2.0) + h * t - x * s);
            r = newkern(delta);
            mem[r].hh.b1 = ACCKERN;
            mem[curlist.tailfield].hh.v.RH = r;
            mem[r].hh.v.RH = p;
            curlist.tailfield = newkern(-(integer)a - delta);
            mem[curlist.tailfield].hh.b1 = ACCKERN;
            mem[p].hh.v.RH = curlist.tailfield;
            p = q;
        }
        mem[curlist.tailfield].hh.v.RH = p;
        curlist.tailfield = p;
        curlist.auxfield.hh.v.LH = 1000;
    }
}
void alignerror(void) {
    alignerror_regmem if (abs(alignstate) >
                          2) /* comment:Express consternation over the fact that
                                no alignm */
    {
        {
            if (interaction == ERRORSTOPMODE)
                ;
            if (filelineerrorstylep)
                printfileline();
            else
                printnl(/* str '! ' */ 264);
            print(/* str 'Misplaced ' */ 1530);
        }
        printcmdchr(curcmd, curchr);
        if (curtok == /* @d11726@ */ /* str '&' */ 1062) {
            {
                helpptr = 6;
                helpline[5] = /* str 'I can't figure out why you would want to
                                 use a ta' */
                    1531;
                helpline[4] = /* str 'here. If you just want an ampersand, the
                                 remedy i' */
                    1532;
                helpline[3] = /* str 'simple' */ 1533;
                helpline[2] = /* str 'up above has ended a previous alignment
                                 premature' */
                    1534;
                helpline[1] = /* str 'you're probably due for more error
                                 messages, and ' */
                    1535;
                helpline[0] = /* str 'might try typing `S' now just to see what
                                 is salv' */
                    1536;
            }
        } else {

            {
                helpptr = 5;
                helpline[4] = /* str 'I can't figure out why you would want to
                                 use a ta' */
                    1531;
                helpline[3] = /* str 'or \cr or \span just now. If something
                                 like a rig' */
                    1537;
                helpline[2] = /* str 'up above has ended a previous alignment
                                 premature' */
                    1534;
                helpline[1] = /* str 'you're probably due for more error
                                 messages, and ' */
                    1535;
                helpline[0] = /* str 'might try typing `S' now just to see what
                                 is salv' */
                    1536;
            }
        }
        error();
    }
    else {

        backinput();
        if (alignstate < 0) {
            {
                if (interaction == ERRORSTOPMODE)
                    ;
                if (filelineerrorstylep)
                    printfileline();
                else
                    printnl(/* str '! ' */ 264);
                print(/* str 'Missing { inserted' */ 744);
            }
            incr(alignstate);
            curtok = /* @d11742@ */ /* str '{' */ 379;
        } else {

            {
                if (interaction == ERRORSTOPMODE)
                    ;
                if (filelineerrorstylep)
                    printfileline();
                else
                    printnl(/* str '! ' */ 264);
                print(/* str 'Missing } inserted' */ 1526);
            }
            decr(alignstate);
            curtok = /* @d11747@ */ /* str '}' */ 637;
        }
        {
            helpptr = 3;
            helpline[2] =
                /* str 'I've put in what seems to be necessary to fix' */ 1527;
            helpline[1] =
                /* str 'the current column of the current alignment.' */ 1528;
            helpline[0] =
                /* str 'Try to go on, since this might almost work.' */ 1529;
        }
        inserror();
    }
}
void noalignerror(void) {
    noalignerror_regmem {
        if (interaction == ERRORSTOPMODE)
            ;
        if (filelineerrorstylep)
            printfileline();
        else
            printnl(/* str '! ' */ 264);
        print(/* str 'Misplaced ' */ 1530);
    }
    printesc(/* str 'noalign' */ 606);
    {
        helpptr = 2;
        helpline[1] =
            /* str 'I expect to see \noalign only after the \cr of' */ 1538;
        helpline[0] =
            /* str 'an alignment. Proceed, and I'll ignore this case.' */ 1539;
    }
    error();
}
void omiterror(void) {
    omiterror_regmem {
        if (interaction == ERRORSTOPMODE)
            ;
        if (filelineerrorstylep)
            printfileline();
        else
            printnl(/* str '! ' */ 264);
        print(/* str 'Misplaced ' */ 1530);
    }
    printesc(/* str 'omit' */ 609);
    {
        helpptr = 2;
        helpline[1] =
            /* str 'I expect to see \omit only after tab marks or the' */ 1540;
        helpline[0] =
            /* str 'an alignment. Proceed, and I'll ignore this case.' */ 1539;
    }
    error();
}
void doendv(void) {
    doendv_regmem baseptr = inputptr;
    inputstack[baseptr] = curinput;
    while ((inputstack[baseptr].indexfield != VTEMPLATE) &&
           (inputstack[baseptr].locfield == TEXNULL) &&
           (inputstack[baseptr].statefield == TOKENLIST))
        decr(baseptr);
    if ((inputstack[baseptr].indexfield != VTEMPLATE) ||
        (inputstack[baseptr].locfield != TEXNULL) ||
        (inputstack[baseptr].statefield != TOKENLIST))
        fatalerror(
            /* str '(interwoven alignment preambles are not allowed)' */ 679);
    if (curgroup == ALIGNGROUP) {
        endgraf();
        if (fincol())
            finrow();
    } else
        offsave();
}
void cserror(void) {
    cserror_regmem if (curchr == 10) {
        {
            if (interaction == ERRORSTOPMODE)
                ;
            if (filelineerrorstylep)
                printfileline();
            else
                printnl(/* str '! ' */ 264);
            print(/* str 'Extra ' */ 932);
        }
        printesc(/* str 'endmubyte' */ 592);
        {
            helpptr = 1;
            helpline[0] =
                /* str 'I'm ignoring this, since I wasn't doing a \mubyte' */
                1542;
        }
    }
    else {

        {
            if (interaction == ERRORSTOPMODE)
                ;
            if (filelineerrorstylep)
                printfileline();
            else
                printnl(/* str '! ' */ 264);
            print(/* str 'Extra ' */ 932);
        }
        printesc(/* str 'endcsname' */ 581);
        {
            helpptr = 1;
            helpline[0] =
                /* str 'I'm ignoring this, since I wasn't doing a \csname' */
                1543;
        }
    }
    error();
}
void zpushmath(groupcode c) {
    pushmath_regmem pushnest();
    curlist.modefield = /* @d11780@ */ -207;
    curlist.auxfield.cint = TEXNULL;
    newsavelevel(c);
}
/* comment:Declare subprocedures for |init_math| */ void
zjustcopy(halfword p, halfword h, halfword t) {
    justcopy_regmem halfword r;
    unsigned char words;
    while (p != TEXNULL) {

        words = 1;
        if ((p >= himemmin))
            r = getavail();
        else
            switch (mem[p].hh.b0) {
            case HLISTNODE:
            case VLISTNODE: {
                r = getnode(BOXNODESIZE);
                mem[r + 6] = mem[p + 6];
                mem[r + 5] = mem[p + 5];
                words = 5;
                mem[r + LISTOFFSET].hh.v.RH = TEXNULL;
            } break;
            case RULENODE: {
                r = getnode(RULENODESIZE);
                words = RULENODESIZE;
            } break;
            case LIGATURENODE: {
                r = getavail();
                mem[r] = mem[p + 1];
                mem[r].hh.me = mem[p + 1].hh.me;
                goto labjustcopy40found;
            } break;
            case KERNNODE:
            case MATHNODE: {
                r = getnode(SMALLNODESIZE);
                words = SMALLNODESIZE;
            } break;
            case GLUENODE: {
                r = getnode(SMALLNODESIZE);
                incr(mem[mem[p + 1].hh.v.LH].hh.v.RH);
                mem[r + 1].hh.v.LH = mem[p + 1].hh.v.LH;
                mem[r + 1].hh.v.RH = TEXNULL;
            } break;
            case WHATSITNODE:
                /* comment:Make a partial copy of the whatsit node |p| and ma */
                switch (mem[p].hh.b1) {
                case OPENNODE: {
                    r = getnode(OPENNODESIZE);
                    words = OPENNODESIZE;
                } break;
                case WRITENODE:
                case SPECIALNODE: {
                    r = getnode(WRITENODESIZE);
                    incr(mem[mem[p + 1].hh.v.RH].hh.v.LH);
                    words = WRITENODESIZE;
                } break;
                case CLOSENODE:
                case LANGUAGENODE: {
                    r = getnode(SMALLNODESIZE);
                    words = SMALLNODESIZE;
                } break;
                case PDFTEXFIRSTEXTENSIONCODE: {
                    r = getnode(WRITENODESIZE);
                    incr(mem[mem[p + 1].hh.v.RH].hh.v.LH);
                    words = WRITENODESIZE;
                } break;
                case PDFTEXFIRSTEXTENSIONCODE + 32: {
                    if (mem[p + 1].hh.v.LH <= 1) {
                        r = getnode(3);
                        incr(mem[mem[p + 2].hh.v.RH].hh.v.LH);
                        words = 3;
                    } else {

                        r = getnode(2);
                        words = 2;
                    }
                } break;
                case PDFTEXFIRSTEXTENSIONCODE + 33: {
                    r = getnode(2);
                    incr(mem[mem[p + 1].hh.v.RH].hh.v.LH);
                    words = 2;
                } break;
                case PDFTEXFIRSTEXTENSIONCODE + 34: {
                    r = getnode(2);
                    words = 2;
                } break;
                case PDFTEXFIRSTEXTENSIONCODE + 35: {
                    r = getnode(2);
                    words = 2;
                } break;
                case PDFTEXFIRSTEXTENSIONCODE + 2: {
                    r = getnode(2);
                    words = 2;
                } break;
                case PDFTEXFIRSTEXTENSIONCODE + 4: {
                    r = getnode(5);
                    words = 5;
                } break;
                case PDFTEXFIRSTEXTENSIONCODE + 6: {
                    r = getnode(5);
                    words = 5;
                } break;
                case PDFTEXFIRSTEXTENSIONCODE + 7: {
                    r = getnode(7);
                    incr(mem[mem[p + 5].hh.v.LH].hh.v.LH);
                    words = 7;
                } break;
                case PDFTEXFIRSTEXTENSIONCODE + 8: {
                    r = getnode(7);
                    mem[r + 2].cint = mem[p + 2].cint;
                    mem[r + 3].cint = mem[p + 3].cint;
                    mem[r + 1].cint = mem[p + 1].cint;
                    mem[r + 5].hh.v.LH = mem[p + 5].hh.v.LH;
                    if (mem[r + 5].hh.v.LH != TEXNULL)
                        incr(mem[mem[r + 5].hh.v.LH].hh.v.LH);
                    mem[r + 5].hh.v.RH = mem[p + 5].hh.v.RH;
                    incr(mem[mem[r + 5].hh.v.RH + 2].hh.v.RH);
                    mem[r + 6].cint = mem[p + 6].cint;
                } break;
                case PDFTEXFIRSTEXTENSIONCODE + 9:
                    r = getnode(SMALLNODESIZE);
                    break;
                case PDFTEXFIRSTEXTENSIONCODE + 11: {
                    r = getnode(7);
                    if (mem[p + 5].hh.b1 > 0)
                        incr(mem[mem[p + 5].hh.v.RH].hh.v.LH);
                    words = 7;
                } break;
                case PDFTEXFIRSTEXTENSIONCODE + 12:
                case PDFTEXFIRSTEXTENSIONCODE + 13: {
                    r = getnode(7);
                    if (mem[p + 5].hh.b1 > 0)
                        incr(mem[mem[p + 5].hh.v.RH].hh.v.LH);
                    if (mem[p + 6].hh.v.LH != TEXNULL)
                        incr(mem[mem[p + 6].hh.v.LH].hh.v.LH);
                    words = 7;
                } break;
                case PDFTEXFIRSTEXTENSIONCODE + 14:
                    r = getnode(SMALLNODESIZE);
                    break;
                case PDFTEXFIRSTEXTENSIONCODE + 15:
                    r = getnode(SMALLNODESIZE);
                    break;
                case PDFTEXFIRSTEXTENSIONCODE + 28:
                    r = getnode(SMALLNODESIZE);
                    break;
                case PDFTEXFIRSTEXTENSIONCODE + 29: {
                    incr(mem[mem[p + 1].hh.v.LH].hh.v.RH);
                    r = getnode(3);
                    words = 3;
                } break;
                case PDFTEXFIRSTEXTENSIONCODE + 30:
                    r = getnode(SMALLNODESIZE);
                    break;
                case PDFTEXFIRSTEXTENSIONCODE + 37:
                    r = getnode(SMALLNODESIZE);
                    break;
                case PDFTEXFIRSTEXTENSIONCODE + 38:
                    r = getnode(SMALLNODESIZE);
                    break;
                case PDFTEXFIRSTEXTENSIONCODE + 39:
                    r = getnode(SMALLNODESIZE);
                    break;
                default:
                    confusion(/* str 'ext2' */ 1908);
                    break;
                }
                break;
            default:
                goto labjustcopy45not_found;
                break;
            }
        while (words > 0) {

            decr(words);
            mem[r + words] = mem[p + words];
        }
    labjustcopy40found:
        mem[h].hh.v.RH = r;
        h = r;
    labjustcopy45not_found:
        p = mem[p].hh.v.RH;
    }
    mem[h].hh.v.RH = t;
}
void zjustreverse(halfword p) {
    justreverse_regmem halfword l;
    halfword t;
    halfword q;
    halfword m, n;
    m = TEXNULL;
    n = TEXNULL;
    if (mem[memtop - 3].hh.v.RH == TEXNULL) {
        justcopy(mem[p].hh.v.RH, memtop - 3, TEXNULL);
        q = mem[memtop - 3].hh.v.RH;
    } else {

        q = mem[p].hh.v.RH;
        mem[p].hh.v.RH = TEXNULL;
        flushnodelist(mem[memtop - 3].hh.v.RH);
    }
    t = newedge(curdir, 0);
    l = t;
    curdir = 1 - curdir;
    while (q != TEXNULL)
        if ((q >= himemmin))
            do {
                p = q;
                q = mem[p].hh.v.RH;
                mem[p].hh.v.RH = l;
                l = p;
            } while (!(!(q >= himemmin)));
        else {

            p = q;
            q = mem[p].hh.v.RH;
            if (mem[p].hh.b0 == MATHNODE) /* comment:Adjust \(t)the LR stack for
                                             the |just_reverse| rou */
            {

                if (odd(mem[p].hh.b1)) {

                    if (mem[LRptr].hh.v.LH !=
                        (LCODE * (mem[p].hh.b1 / LCODE) /* @d11854@ */
                         + 3)) {
                        mem[p].hh.b0 = KERNNODE;
                        incr(LRproblems);
                    } else {

                        {
                            tempptr = LRptr;
                            LRptr = mem[tempptr].hh.v.RH;
                            {
                                mem[tempptr].hh.v.RH = avail;
                                avail = tempptr;
                                mem[tempptr].hh.me = 0;
                                ;
#ifdef STAT
                                decr(dynused);
#endif /* STAT */
                            }
                        }
                        if (n > TEXNULL) {
                            decr(n);
                            decr(mem[p].hh.b1);
                        } else {

                            if (m > TEXNULL)
                                decr(m);
                            else
                                goto labjustreverse40found;
                            mem[p].hh.b0 = KERNNODE;
                        }
                    }
                } else {

                    {
                        tempptr = getavail();
                        mem[tempptr].hh.v.LH =
                            (LCODE * (mem[p].hh.b1 / LCODE) /* @d11860@ */
                             + 3);
                        mem[tempptr].hh.v.RH = LRptr;
                        LRptr = tempptr;
                    }
                    if ((n > TEXNULL) || ((mem[p].hh.b1 / RCODE) != curdir)) {
                        incr(n);
                        incr(mem[p].hh.b1);
                    } else {

                        mem[p].hh.b0 = KERNNODE;
                        incr(m);
                    }
                }
            }
            mem[p].hh.v.RH = l;
            l = p;
        }
    goto labjustreverse30done;
labjustreverse40found:
    mem[t + WIDTHOFFSET].cint = mem[p + WIDTHOFFSET].cint;
    mem[t].hh.v.RH = q;
    freenode(p, SMALLNODESIZE);
labjustreverse30done:
    mem[memtop - 3].hh.v.RH = l;
}
void initmath(void) {
    initmath_regmem scaled w;
    halfword j;
    integer x;
    scaled l;
    scaled s;
    halfword p;
    halfword q;
    internalfontnumber f;
    integer n;
    scaled v;
    scaled d;
    gettoken();
    if ((curcmd == MATHSHIFT) &&
        (curlist.modefield > 0)) /* comment:Go into display math mode */
    {
        j = TEXNULL;
        w = -1073741823L;
        if (curlist.headfield ==
            curlist.tailfield) /* comment:Prepare for display after an empty
                                  paragraph */
        {
            popnest();
            /* comment:Set the value of |x| to the text direction before  */
            if (curlist.eTeXauxfield == TEXNULL)
                x = 0;
            else if (mem[curlist.eTeXauxfield].hh.v.LH >= RCODE)
                x = -1;
            else
                x = 1;
        } else {

            linebreak(true);
            /* comment:Calculate the natural width, |w|, by which the cha */
            /* comment:Prepare for display after a non-empty paragraph */
            if ((eTeXmode ==
                 1)) /* comment:Let |j| be the prototype box for the display */
            {
                if (eqtb[GLUEBASE + RIGHTSKIPCODE].hh.v.RH == membot)
                    j = newkern(0);
                else
                    j = newparamglue(RIGHTSKIPCODE);
                if (eqtb[GLUEBASE + LEFTSKIPCODE].hh.v.RH == membot)
                    p = newkern(0);
                else
                    p = newparamglue(LEFTSKIPCODE);
                mem[p].hh.v.RH = j;
                j = newnullbox();
                mem[j + WIDTHOFFSET].cint = mem[justbox + WIDTHOFFSET].cint;
                mem[j + 4].cint = mem[justbox + 4].cint;
                mem[j + LISTOFFSET].hh.v.RH = p;
                mem[j + LISTOFFSET].hh.b1 = mem[justbox + LISTOFFSET].hh.b1;
                mem[j + LISTOFFSET].hh.b0 = mem[justbox + LISTOFFSET].hh.b0;
                mem[j + GLUEOFFSET].gr = mem[justbox + GLUEOFFSET].gr;
            }
            v = mem[justbox + 4].cint;
            /* comment:Set the value of |x| to the text direction before  */
            if (curlist.eTeXauxfield == TEXNULL)
                x = 0;
            else if (mem[curlist.eTeXauxfield].hh.v.LH >= RCODE)
                x = -1;
            else
                x = 1;
            if (x >= 0) {
                p = mem[justbox + LISTOFFSET].hh.v.RH;
                mem[memtop - 3].hh.v.RH = TEXNULL;
            } else {

                v = -(integer)v - mem[justbox + WIDTHOFFSET].cint;
                p = newmath(0, BEGINLCODE);
                mem[memtop - 3].hh.v.RH = p;
                justcopy(mem[justbox + LISTOFFSET].hh.v.RH, p,
                         newmath(0, ENDLCODE));
                curdir = RIGHTTOLEFT;
            }
            v = v + 2 * fontinfo[QUADCODE + parambase[eqtb[CURFONTLOC].hh.v.RH]]
                            .cint;
            if ((eqtb[ETEXSTATEBASE + TEXXETCODE].cint >
                 0)) /* comment:Initialize the LR stack */
            {
                tempptr = getavail();
                mem[tempptr].hh.v.LH = BEFORE;
                mem[tempptr].hh.v.RH = LRptr;
                LRptr = tempptr;
            }
            while (p != TEXNULL) {

            /* comment:Let |d| be the natural width of node |p|; if the n */
            labinitmath21reswitch:
                if ((p >= himemmin)) {
                    f = mem[p].hh.b0;
                    d = fontinfo[widthbase[f] +
                                 fontinfo[charbase[f] +
                                          effectivechar(true, f, mem[p].hh.b1)]
                                     .qqqq.b0]
                            .cint;
                    goto labinitmath40found;
                }
                switch (mem[p].hh.b0) {
                case HLISTNODE:
                case VLISTNODE:
                case RULENODE: {
                    d = mem[p + WIDTHOFFSET].cint;
                    goto labinitmath40found;
                } break;
                case LIGATURENODE:
                    /* comment:Make node |p| look like a |char_node| and |goto
                     * re */
                    {

                        mem[memtop - 12] = mem[p + 1];
                        mem[memtop - 12].hh.v.RH = mem[p].hh.v.RH;
                        mem[memtop - 12].hh.me = mem[p].hh.me;
                        p = memtop - 12;
                        goto labinitmath21reswitch;
                    }
                    break;
                case MARGINKERNNODE:
                    d = mem[p + WIDTHOFFSET].cint;
                    break;
                case KERNNODE:
                    d = mem[p + WIDTHOFFSET].cint;
                    break;
                /* comment:Cases of `Let |d| be the natural width' that need  */
                case MATHNODE: {
                    d = mem[p + WIDTHOFFSET].cint;
                    if ((eqtb[ETEXSTATEBASE + TEXXETCODE].cint >
                         0)) /* comment:Adjust \(t)the LR stack for the
                                |init_math| routin */
                    {

                        if (odd(mem[p].hh.b1)) {
                            if (mem[LRptr].hh.v.LH ==
                                (LCODE * (mem[p].hh.b1 / LCODE) /* @d11933@ */
                                 + 3)) {
                                tempptr = LRptr;
                                LRptr = mem[tempptr].hh.v.RH;
                                {
                                    mem[tempptr].hh.v.RH = avail;
                                    avail = tempptr;
                                    mem[tempptr].hh.me = 0;
                                    ;
#ifdef STAT
                                    decr(dynused);
#endif /* STAT */
                                }
                            } else if (mem[p].hh.b1 > LCODE) {
                                w = 1073741823L;
                                goto labinitmath30done;
                            }
                        } else {

                            {
                                tempptr = getavail();
                                mem[tempptr].hh.v.LH =
                                    (LCODE *
                                         (mem[p].hh.b1 / LCODE) /* @d11938@ */
                                     + 3);
                                mem[tempptr].hh.v.RH = LRptr;
                                LRptr = tempptr;
                            }
                            if ((mem[p].hh.b1 / RCODE) != curdir) {
                                justreverse(p);
                                p = memtop - 3;
                            }
                        }
                    } else if (mem[p].hh.b1 >= LCODE) {
                        w = 1073741823L;
                        goto labinitmath30done;
                    }
                } break;
                case EDGENODE: {
                    d = mem[p + WIDTHOFFSET].cint;
                    curdir = mem[p].hh.b1;
                } break;
                case GLUENODE:
                    /* comment:Let |d| be the natural width of this glue; if
                     * stre */
                    {

                        q = mem[p + 1].hh.v.LH;
                        d = mem[q + WIDTHOFFSET].cint;
                        if (mem[justbox + LISTOFFSET].hh.b0 == STRETCHING) {
                            if ((mem[justbox + LISTOFFSET].hh.b1 ==
                                 mem[q].hh.b0) &&
                                (mem[q + 2].cint != 0))
                                v = 1073741823L;
                        } else if (mem[justbox + LISTOFFSET].hh.b0 ==
                                   SHRINKING) {
                            if ((mem[justbox + LISTOFFSET].hh.b1 ==
                                 mem[q].hh.b1) &&
                                (mem[q + 3].cint != 0))
                                v = 1073741823L;
                        }
                        if (mem[p].hh.b1 >= ALEADERS)
                            goto labinitmath40found;
                    }
                    break;
                case WHATSITNODE:
                    /* comment:Let |d| be the width of the whatsit |p| */
                    if ((mem[p].hh.b1 == /* @d11957@ */ 10) ||
                        (mem[p].hh.b1 == /* @d11958@ */ 12))
                        d = mem[p + 1].cint;
                    else
                        d = 0;
                    break;
                default:
                    d = 0;
                    break;
                }
                if (v < 1073741823L)
                    v = v + d;
                goto labinitmath45not_found;
            labinitmath40found:
                if (v < 1073741823L) {
                    v = v + d;
                    w = v;
                } else {

                    w = 1073741823L;
                    goto labinitmath30done;
                }
            labinitmath45not_found:
                p = mem[p].hh.v.RH;
            }
        labinitmath30done: /* comment:Finish the natural width computation */
            if ((eqtb[ETEXSTATEBASE + TEXXETCODE].cint > 0)) {
                while (LRptr != TEXNULL) {

                    tempptr = LRptr;
                    LRptr = mem[tempptr].hh.v.RH;
                    {
                        mem[tempptr].hh.v.RH = avail;
                        avail = tempptr;
                        mem[tempptr].hh.me = 0;
                        ;
#ifdef STAT
                        decr(dynused);
#endif /* STAT */
                    }
                }
                if (LRproblems != 0) {
                    w = 1073741823L;
                    LRproblems = 0;
                }
            }
            curdir = LEFTTORIGHT;
            flushnodelist(mem[memtop - 3].hh.v.RH);
        }
        /* comment:Calculate the length, |l|, and the shift amount, | */
        if (eqtb[PARSHAPELOC].hh.v.RH == TEXNULL) {

            if ((eqtb[DIMENBASE + HANGINDENTCODE].cint != 0) &&
                (((eqtb[INTBASE + HANGAFTERCODE].cint >= 0) &&
                  (curlist.pgfield + 2 > eqtb[INTBASE + HANGAFTERCODE].cint)) ||
                 (curlist.pgfield + 1 <
                  -(integer)eqtb[INTBASE + HANGAFTERCODE].cint))) {
                l = eqtb[DIMENBASE + HSIZECODE].cint -
                    abs(eqtb[DIMENBASE + HANGINDENTCODE].cint);
                if (eqtb[DIMENBASE + HANGINDENTCODE].cint > 0)
                    s = eqtb[DIMENBASE + HANGINDENTCODE].cint;
                else
                    s = 0;
            } else {

                l = eqtb[DIMENBASE + HSIZECODE].cint;
                s = 0;
            }
        } else {

            n = mem[eqtb[PARSHAPELOC].hh.v.RH].hh.v.LH;
            if (curlist.pgfield + 2 >= n)
                p = eqtb[PARSHAPELOC].hh.v.RH + 2 * n;
            else
                p = eqtb[PARSHAPELOC].hh.v.RH + 2 * (curlist.pgfield + 2);
            s = mem[p - 1].cint;
            l = mem[p].cint;
        }
        pushmath(MATHSHIFTGROUP);
        curlist.modefield = MMODE;
        eqworddefine(/* @d11993@ */ /* @d11994@ */ 29321, -1);
        eqworddefine(/* @d11995@ */ /* @d11996@ */ 29907, w);
        curlist.eTeXauxfield = j;
        if ((eTeXmode == 1))
            eqworddefine(/* @d11997@ */ /* @d11998@ */ 29377, x);
        eqworddefine(/* @d11999@ */ /* @d12000@ */ 29908, l);
        eqworddefine(/* @d12001@ */ /* @d12002@ */ 29909, s);
        if (eqtb[EVERYDISPLAYLOC].hh.v.RH != TEXNULL)
            begintokenlist(eqtb[EVERYDISPLAYLOC].hh.v.RH, EVERYDISPLAYTEXT);
        if (nestptr == 1)
            buildpage();
    } else {

        backinput();
        /* comment:Go into ordinary math mode */ {

            pushmath(MATHSHIFTGROUP);
            eqworddefine(/* @d12008@ */ /* @d12009@ */ 29321, -1);
            if ((insertsrcspecialeverymath))
                insertsrcspecial();
            if (eqtb[EVERYMATHLOC].hh.v.RH != TEXNULL)
                begintokenlist(eqtb[EVERYMATHLOC].hh.v.RH, EVERYMATHTEXT);
        }
    }
}
void starteqno(void) {
    starteqno_regmem savestack[saveptr + 0].cint = curchr;
    incr(saveptr);
    /* comment:Go into ordinary math mode */ {

        pushmath(MATHSHIFTGROUP);
        eqworddefine(/* @d12015@ */ /* @d12016@ */ 29321, -1);
        if ((insertsrcspecialeverymath))
            insertsrcspecial();
        if (eqtb[EVERYMATHLOC].hh.v.RH != TEXNULL)
            begintokenlist(eqtb[EVERYMATHLOC].hh.v.RH, EVERYMATHTEXT);
    }
}
void zscanmath(halfword p) {
    scanmath_regmem integer c;
labscanmath20restart
    : /* comment:Get the next non-blank non-relax non-call token */
    do {
        getxtoken();
    } while (!((curcmd != SPACER) && (curcmd != RELAX)));
labscanmath21reswitch:
    switch (curcmd) {
    case LETTER:
    case OTHERCHAR:
    case CHARGIVEN: {
        c = eqtb[MATHCODEBASE + curchr].hh.v.RH;
        if (c == 32768L) {
            /* comment:Treat |cur_chr| as an active character */ {

                curcs = curchr + ACTIVEBASE;
                curcmd = eqtb[curcs].hh.b0;
                curchr = eqtb[curcs].hh.v.RH;
                xtoken();
                backinput();
            }
            goto labscanmath20restart;
        }
    } break;
    case CHARNUM: {
        scancharnum();
        curchr = curval;
        curcmd = CHARGIVEN;
        goto labscanmath21reswitch;
    } break;
    case MATHCHARNUM: {
        scanfifteenbitint();
        c = curval;
    } break;
    case MATHGIVEN:
        c = curchr;
        break;
    case DELIMNUM: {
        scantwentysevenbitint();
        c = curval / 4096;
    } break;
    default:
        /* comment:Scan a subformula enclosed in braces and |return| */ {

            backinput();
            scanleftbrace();
            savestack[saveptr + 0].cint = p;
            incr(saveptr);
            pushmath(MATHGROUP);
            return;
        }
        break;
    }
    mem[p].hh.v.RH = MATHCHAR;
    mem[p].hh.b1 = c % 256;
    mem[p].hh.me = curchrsig;
    if ((c >= 28672) && ((eqtb[INTBASE + CURFAMCODE].cint >= 0) &&
                         (eqtb[INTBASE + CURFAMCODE].cint < 16)))
        mem[p].hh.b0 = eqtb[INTBASE + CURFAMCODE].cint;
    else
        mem[p].hh.b0 = (c / 256) % 16;
}
void zsetmathchar(integer c) {
    setmathchar_regmem halfword p;
    if (c >= 32768L) /* comment:Treat |cur_chr| as an active character */
    {
        curcs = curchr + ACTIVEBASE;
        curcmd = eqtb[curcs].hh.b0;
        curchr = eqtb[curcs].hh.v.RH;
        xtoken();
        backinput();
    } else {

        p = newnoad();
        mem[p + 1].hh.v.RH = MATHCHAR;
        mem[p + 1].hh.b1 = c % 256;
        mem[p + 1].hh.b0 = (c / 256) % 16;
        mem[p].hh.me = curchrsig;
        if (c >= 28672) {
            if (((eqtb[INTBASE + CURFAMCODE].cint >= 0) &&
                 (eqtb[INTBASE + CURFAMCODE].cint < 16)))
                mem[p + 1].hh.b0 = eqtb[INTBASE + CURFAMCODE].cint;
            mem[p].hh.b0 = ORDNOAD;
        } else
            mem[p].hh.b0 = ORDNOAD + (c / 4096);
        mem[curlist.tailfield].hh.v.RH = p;
        curlist.tailfield = p;
    }
}
void mathlimitswitch(void) {
    mathlimitswitch_regmem if (curlist.headfield != curlist.tailfield) {

        if (mem[curlist.tailfield].hh.b0 == OPNOAD) {
            mem[curlist.tailfield].hh.b1 = curchr;
            return;
        }
    }
    {
        if (interaction == ERRORSTOPMODE)
            ;
        if (filelineerrorstylep)
            printfileline();
        else
            printnl(/* str '! ' */ 264);
        print(/* str 'Limit controls must follow a math operator' */ 1547);
    }
    {
        helpptr = 1;
        helpline[0] =
            /* str 'I'm ignoring this misplaced \limits or \nolimits ' */ 1548;
    }
    error();
}
void zscandelimiter(halfword p, boolean r) {
    scandelimiter_regmem if (r) scantwentysevenbitint();
    else {

        /* comment:Get the next non-blank non-relax non-call token */ do {
            getxtoken();
        } while (!((curcmd != SPACER) && (curcmd != RELAX)));
        switch (curcmd) {
        case LETTER:
        case OTHERCHAR:
            curval = eqtb[DELCODEBASE + curchr].cint;
            break;
        case DELIMNUM:
            scantwentysevenbitint();
            break;
        default:
            curval = -1;
            break;
        }
    }
    if (curval <
        0) /* comment:Report that an invalid delimiter code is being cha */
    {
        {
            if (interaction == ERRORSTOPMODE)
                ;
            if (filelineerrorstylep)
                printfileline();
            else
                printnl(/* str '! ' */ 264);
            print(/* str 'Missing delimiter (. inserted)' */ 1549);
        }
        {
            helpptr = 6;
            helpline[5] =
                /* str 'I was expecting to see something like `(' or `\{'' */
                1550;
            helpline[4] =
                /* str '`\}' here. If you typed, e.g., `{' instead of `\{' */
                1551;
            helpline[3] =
                /* str 'should probably delete the `{' by typing `1' now,' */
                1552;
            helpline[2] =
                /* str 'braces don't get unbalanced. Otherwise just proce' */
                1553;
            helpline[1] =
                /* str 'Acceptable delimiters are characters whose \delco' */
                1554;
            helpline[0] =
                /* str 'nonnegative, or you can use `\delimiter <delimite' */
                1555;
        }
        backerror();
        curval = 0;
    }
    mem[p].qqqq.b0 = (curval / 1048576L) % 16;
    mem[p].qqqq.b1 = (curval / 4096) % 256;
    mem[p].qqqq.b2 = (curval / 256) % 16;
    mem[p].qqqq.b3 = curval % 256;
}
void mathradical(void) {
    mathradical_regmem {
        mem[curlist.tailfield].hh.v.RH = getnode(RADICALNOADSIZE);
        curlist.tailfield = mem[curlist.tailfield].hh.v.RH;
    }
    mem[curlist.tailfield].hh.b0 = RADICALNOAD;
    mem[curlist.tailfield].hh.b1 = NORMAL;
    mem[curlist.tailfield + 1].hh = emptyfield;
    mem[curlist.tailfield + 3].hh = emptyfield;
    mem[curlist.tailfield + 2].hh = emptyfield;
    scandelimiter(curlist.tailfield + 4, true);
    scanmath(curlist.tailfield + 1);
}
void mathac(void) {
    mathac_regmem if (curcmd ==
                      ACCENT) /* comment:Complain that the user
                                            should have said \.{\\matha */
    {
        {
            if (interaction == ERRORSTOPMODE)
                ;
            if (filelineerrorstylep)
                printfileline();
            else
                printnl(/* str '! ' */ 264);
            print(/* str 'Please use ' */ 1556);
        }
        printesc(/* str 'mathaccent' */ 602);
        print(/* str ' for accents in math mode' */ 1557);
        {
            helpptr = 2;
            helpline[1] =
                /* str 'I'm changing \accent to \mathaccent here; wish me' */
                1558;
            helpline[0] =
                /* str '(Accents are not the same in formulas as they are' */
                1559;
        }
        error();
    }
    {
        mem[curlist.tailfield].hh.v.RH = getnode(ACCENTNOADSIZE);
        curlist.tailfield = mem[curlist.tailfield].hh.v.RH;
    }
    mem[curlist.tailfield].hh.b0 = ACCENTNOAD;
    mem[curlist.tailfield].hh.b1 = NORMAL;
    mem[curlist.tailfield + 1].hh = emptyfield;
    mem[curlist.tailfield + 3].hh = emptyfield;
    mem[curlist.tailfield + 2].hh = emptyfield;
    mem[curlist.tailfield + 4].hh.v.RH = MATHCHAR;
    scanfifteenbitint();
    mem[curlist.tailfield + 4].hh.b1 = curval % 256;
    if ((curval >= 28672) && ((eqtb[INTBASE + CURFAMCODE].cint >= 0) &&
                              (eqtb[/* @d12106@ */ /* @d12107@ */
                                    29321]
                                   .cint < 16)))
        mem[curlist.tailfield + 4].hh.b0 = eqtb[INTBASE + CURFAMCODE].cint;
    else
        mem[curlist.tailfield + 4].hh.b0 = (curval / 256) % 16;
    scanmath(curlist.tailfield + 1);
}
void appendchoices(void) {
    appendchoices_regmem {
        mem[curlist.tailfield].hh.v.RH = newchoice();
        curlist.tailfield = mem[curlist.tailfield].hh.v.RH;
    }
    incr(saveptr);
    savestack[saveptr - 1].cint = 0;
    pushmath(MATHCHOICEGROUP);
    scanleftbrace();
}
/* comment:Declare the function called |fin_mlist| */ halfword
zfinmlist(halfword p) {
    register halfword Result;
    finmlist_regmem halfword q;
    if (curlist.auxfield.cint !=
        TEXNULL) /* comment:Compleat the incompleat noad */
    {
        mem[curlist.auxfield.cint + 3].hh.v.RH = SUBMLIST;
        mem[curlist.auxfield.cint + 3].hh.v.LH = mem[curlist.headfield].hh.v.RH;
        if (p == TEXNULL)
            q = curlist.auxfield.cint;
        else {

            q = mem[curlist.auxfield.cint + 2].hh.v.LH;
            if ((mem[q].hh.b0 != LEFTNOAD) || (curlist.eTeXauxfield == TEXNULL))
                confusion(/* str 'right' */ 1286);
            mem[curlist.auxfield.cint + 2].hh.v.LH =
                mem[curlist.eTeXauxfield].hh.v.RH;
            mem[curlist.eTeXauxfield].hh.v.RH = curlist.auxfield.cint;
            mem[curlist.auxfield.cint].hh.v.RH = p;
        }
    } else {

        mem[curlist.tailfield].hh.v.RH = p;
        q = mem[curlist.headfield].hh.v.RH;
    }
    popnest();
    Result = q;
    return Result;
}
void buildchoices(void) {
    buildchoices_regmem halfword p;
    unsave();
    p = finmlist(TEXNULL);
    switch (savestack[saveptr - 1].cint) {
    case 0:
        mem[curlist.tailfield + 1].hh.v.LH = p;
        break;
    case 1:
        mem[curlist.tailfield + 1].hh.v.RH = p;
        break;
    case 2:
        mem[curlist.tailfield + 2].hh.v.LH = p;
        break;
    case 3: {
        mem[curlist.tailfield + 2].hh.v.RH = p;
        decr(saveptr);
        return;
    } break;
    }
    incr(savestack[saveptr - 1].cint);
    pushmath(MATHCHOICEGROUP);
    scanleftbrace();
}
void subsup(void) {
    subsup_regmem smallnumber t;
    halfword p;
    t = EMPTY;
    p = TEXNULL;
    if (curlist.tailfield != curlist.headfield) {

        if ((mem[curlist.tailfield].hh.b0 >= ORDNOAD) &&
            (mem[curlist.tailfield].hh.b0 < LEFTNOAD)) {
            p = curlist.tailfield + 2 + curcmd - SUPMARK;
            t = mem[p].hh.v.RH;
        }
    }
    if ((p == TEXNULL) || (t != EMPTY)) /* comment:Insert a dummy noad to be
                                                      subsuperscripted */
    {
        {
            mem[curlist.tailfield].hh.v.RH = newnoad();
            curlist.tailfield = mem[curlist.tailfield].hh.v.RH;
        }
        p = curlist.tailfield + 2 + curcmd - SUPMARK;
        if (t != EMPTY) {
            if (curcmd == SUPMARK) {
                {
                    if (interaction == ERRORSTOPMODE)
                        ;
                    if (filelineerrorstylep)
                        printfileline();
                    else
                        printnl(/* str '! ' */ 264);
                    print(/* str 'Double superscript' */ 1560);
                }
                {
                    helpptr = 1;
                    helpline[0] =
                        /* str 'I treat `x^1^2' essentially like `x^1{}^2'.' */
                        1561;
                }
            } else {

                {
                    if (interaction == ERRORSTOPMODE)
                        ;
                    if (filelineerrorstylep)
                        printfileline();
                    else
                        printnl(/* str '! ' */ 264);
                    print(/* str 'Double subscript' */ 1562);
                }
                {
                    helpptr = 1;
                    helpline[0] =
                        /* str 'I treat `x_1_2' essentially like `x_1{}_2'.' */
                        1563;
                }
            }
            error();
        }
    }
    scanmath(p);
}
void mathfraction(void) {
    mathfraction_regmem smallnumber c;
    c = curchr;
    if (curlist.auxfield.cint != TEXNULL) /* comment:Ignore the fraction
                                             operation and complain about t */
    {
        if (c >= DELIMITEDCODE) {
            scandelimiter(memtop - 12, false);
            scandelimiter(memtop - 12, false);
        }
        if (c % /* @d12139@ */ 3 == ABOVECODE)
            scandimen(false, false, false);
        {
            if (interaction == ERRORSTOPMODE)
                ;
            if (filelineerrorstylep)
                printfileline();
            else
                printnl(/* str '! ' */ 264);
            print(/* str 'Ambiguous; you need another { and }' */ 1570);
        }
        {
            helpptr = 3;
            helpline[2] =
                /* str 'I'm ignoring this fraction specification, since I' */
                1571;
            helpline[1] =
                /* str 'know whether a construction like `x \over y \over' */
                1572;
            helpline[0] =
                /* str 'means `{x \over y} \over z' or `x \over {y \over ' */
                1573;
        }
        error();
    } else {

        curlist.auxfield.cint = getnode(FRACTIONNOADSIZE);
        mem[curlist.auxfield.cint].hh.b0 = FRACTIONNOAD;
        mem[curlist.auxfield.cint].hh.b1 = NORMAL;
        mem[curlist.auxfield.cint + 2].hh.v.RH = SUBMLIST;
        mem[curlist.auxfield.cint + 2].hh.v.LH = mem[curlist.headfield].hh.v.RH;
        mem[curlist.auxfield.cint + 3].hh = emptyfield;
        mem[curlist.auxfield.cint + 4].qqqq = nulldelimiter;
        mem[curlist.auxfield.cint + 5].qqqq = nulldelimiter;
        mem[curlist.headfield].hh.v.RH = TEXNULL;
        curlist.tailfield = curlist.headfield;
        /* comment:Use code |c| to distinguish between generalized fr */
        if (c >= DELIMITEDCODE) {
            scandelimiter(curlist.auxfield.cint + 4, false);
            scandelimiter(curlist.auxfield.cint + 5, false);
        }
        switch (c % /* @d12153@ */ 3) {
        case ABOVECODE: {
            scandimen(false, false, false);
            mem[curlist.auxfield.cint /* @d12155@ */ + 1].cint = curval;
        } break;
        case OVERCODE:
            mem[curlist.auxfield.cint /* @d12157@ */ + 1].cint = 1073741824L;
            break;
        case ATOPCODE:
            mem[curlist.auxfield.cint /* @d12159@ */ + 1].cint = 0;
            break;
        }
    }
}
void mathleftright(void) {
    mathleftright_regmem smallnumber t;
    halfword p;
    halfword q;
    t = curchr;
    if ((t != LEFTNOAD) &&
        (curgroup != MATHLEFTGROUP)) /* comment:Try to recover from
                                            mismatched \.{\\right} */
    {
        if (curgroup == MATHSHIFTGROUP) {
            scandelimiter(memtop - 12, false);
            {
                if (interaction == ERRORSTOPMODE)
                    ;
                if (filelineerrorstylep)
                    printfileline();
                else
                    printnl(/* str '! ' */ 264);
                print(/* str 'Extra ' */ 932);
            }
            if (t == 1) {
                printesc(/* str 'middle' */ 1287);
                {
                    helpptr = 1;
                    helpline[0] = /* str 'I'm ignoring a \middle that had no
                                     matching \left' */
                        1574;
                }
            } else {

                printesc(/* str 'right' */ 1286);
                {
                    helpptr = 1;
                    helpline[0] = /* str 'I'm ignoring a \right that had no
                                     matching \left.' */
                        1575;
                }
            }
            error();
        } else
            offsave();
    } else {

        p = newnoad();
        mem[p].hh.b0 = t;
        scandelimiter(p + 1, false);
        if (t == 1) {
            mem[p].hh.b0 = RIGHTNOAD;
            mem[p].hh.b1 = 1;
        }
        if (t == LEFTNOAD)
            q = p;
        else {

            q = finmlist(p);
            unsave();
        }
        if (t != RIGHTNOAD) {
            pushmath(MATHLEFTGROUP);
            mem[curlist.headfield].hh.v.RH = q;
            curlist.tailfield = p;
            curlist.eTeXauxfield = p;
        } else {

            {
                mem[curlist.tailfield].hh.v.RH = newnoad();
                curlist.tailfield = mem[curlist.tailfield].hh.v.RH;
            }
            mem[curlist.tailfield].hh.b0 = INNERNOAD;
            mem[curlist.tailfield + 1].hh.v.RH = SUBMLIST;
            mem[curlist.tailfield + 1].hh.v.LH = q;
        }
    }
}
/* comment:Declare subprocedures for |after_math| */ void
zappdisplay(halfword j, halfword b, scaled d) {
    appdisplay_regmem scaled z;
    scaled s;
    scaled e;
    integer x;
    halfword p, q, r, t, u;
    s = eqtb[DIMENBASE + DISPLAYINDENTCODE].cint;
    x = eqtb[INTBASE + PREDISPLAYDIRECTIONCODE].cint;
    if (x == 0)
        mem[b + 4].cint = s + d;
    else {

        z = eqtb[DIMENBASE + DISPLAYWIDTHCODE].cint;
        p = b;
        /* comment:Set up the hlist for the display line */ if (x > 0)
            e = z - d - mem[p + WIDTHOFFSET].cint;
        else {

            e = d;
            d = z - e - mem[p + WIDTHOFFSET].cint;
        }
        if (j != TEXNULL) {
            b = copynodelist(j);
            mem[b + HEIGHTOFFSET].cint = mem[p + HEIGHTOFFSET].cint;
            mem[b + DEPTHOFFSET].cint = mem[p + DEPTHOFFSET].cint;
            s = s - mem[b + 4].cint;
            d = d + s;
            e = e + mem[b + WIDTHOFFSET].cint - z - s;
        }
        if ((mem[p].hh.b1) == DLIST)
            q = p;
        else {

            r = mem[p + LISTOFFSET].hh.v.RH;
            freenode(p, BOXNODESIZE);
            if (r == TEXNULL)
                confusion(/* str 'LR4' */ 2032);
            if (x > 0) {
                p = r;
                do {
                    q = r;
                    r = mem[r].hh.v.RH;
                } while (!(r == TEXNULL));
            } else {

                p = TEXNULL;
                q = r;
                do {
                    t = mem[r].hh.v.RH;
                    mem[r].hh.v.RH = p;
                    p = r;
                    r = t;
                } while (!(r == TEXNULL));
            }
        }
        /* comment:Package the display line */ if (j == TEXNULL) {
            r = newkern(0);
            t = newkern(0);
        } else {

            r = mem[b + LISTOFFSET].hh.v.RH;
            t = mem[r].hh.v.RH;
        }
        u = newmath(0, ENDMCODE);
        if (mem[t].hh.b0 == GLUENODE) {
            j = newskipparam(RIGHTSKIPCODE);
            mem[q].hh.v.RH = j;
            mem[j].hh.v.RH = u;
            j = mem[t + 1].hh.v.LH;
            mem[tempptr].hh.b0 = mem[j].hh.b0;
            mem[tempptr].hh.b1 = mem[j].hh.b1;
            mem[tempptr + WIDTHOFFSET].cint = e - mem[j + WIDTHOFFSET].cint;
            mem[tempptr + 2].cint = -(integer)mem[j + 2].cint;
            mem[tempptr + 3].cint = -(integer)mem[j + 3].cint;
            mem[u].hh.v.RH = t;
        } else {

            mem[t + WIDTHOFFSET].cint = e;
            mem[t].hh.v.RH = u;
            mem[q].hh.v.RH = t;
        }
        u = newmath(0, BEGINMCODE);
        if (mem[r].hh.b0 == GLUENODE) {
            j = newskipparam(LEFTSKIPCODE);
            mem[u].hh.v.RH = j;
            mem[j].hh.v.RH = p;
            j = mem[r + 1].hh.v.LH;
            mem[tempptr].hh.b0 = mem[j].hh.b0;
            mem[tempptr].hh.b1 = mem[j].hh.b1;
            mem[tempptr + WIDTHOFFSET].cint = d - mem[j + WIDTHOFFSET].cint;
            mem[tempptr + 2].cint = -(integer)mem[j + 2].cint;
            mem[tempptr + 3].cint = -(integer)mem[j + 3].cint;
            mem[r].hh.v.RH = u;
        } else {

            mem[r + WIDTHOFFSET].cint = d;
            mem[r].hh.v.RH = p;
            mem[u].hh.v.RH = r;
            if (j == TEXNULL) {
                b = hpack(u, 0, ADDITIONAL);
                mem[b + 4].cint = s;
            } else
                mem[b + LISTOFFSET].hh.v.RH = u;
        }
    }
    appendtovlist(b);
}
void aftermath(void) {
    aftermath_regmem boolean l;
    boolean danger;
    integer m;
    halfword p;
    halfword a;
    /* comment:Local variables for finishing a displayed formula */ halfword b;
    scaled w;
    scaled z;
    scaled e;
    scaled q;
    scaled d;
    scaled s;
    smallnumber g1, g2;
    halfword r;
    halfword t;
    halfword pret;
    halfword j;
    danger = false;
    /* comment:Retrieve the prototype box */ if (curlist.modefield == MMODE)
        j = curlist.eTeXauxfield;
    /* comment:Check that the necessary fonts for math symbols ar */
    if ((fontparams[eqtb[MATHFONTBASE + TEXTSIZE + 2].hh.v.RH] <
         TOTALMATHSYPARAMS) ||
        (fontparams[eqtb[MATHFONTBASE + SCRIPTSIZE + 2].hh.v.RH] <
         TOTALMATHSYPARAMS) ||
        (fontparams[eqtb[MATHFONTBASE + SCRIPTSCRIPTSIZE + 2]
                        .hh.v.RH] < /* @d12224@
                                     */
         22)) {
        {
            if (interaction == ERRORSTOPMODE)
                ;
            if (filelineerrorstylep)
                printfileline();
            else
                printnl(/* str '! ' */ 264);
            print(/* str 'Math formula deleted' */ 1576);
        }
        {
            helpptr = 3;
            helpline[2] =
                /* str 'Sorry, but I can't typeset math unless \textfont ' */
                1577;
            helpline[1] =
                /* str 'and \scriptfont 2 and \scriptscriptfont 2 have al' */
                1578;
            helpline[0] =
                /* str 'the \fontdimen values needed in math symbol fonts' */
                1579;
        }
        error();
        flushmath();
        danger = true;
    } else if ((fontparams[eqtb[MATHFONTBASE + TEXTSIZE + 3].hh.v.RH] <
                TOTALMATHEXPARAMS) ||
               (fontparams[eqtb[MATHFONTBASE + SCRIPTSIZE + 3].hh.v.RH] <
                TOTALMATHEXPARAMS) ||
               (fontparams[eqtb[MATHFONTBASE + SCRIPTSCRIPTSIZE + 3].hh.v.RH] <
                TOTALMATHEXPARAMS)) {
        {
            if (interaction == ERRORSTOPMODE)
                ;
            if (filelineerrorstylep)
                printfileline();
            else
                printnl(/* str '! ' */ 264);
            print(/* str 'Math formula deleted' */ 1580);
        }
        {
            helpptr = 3;
            helpline[2] =
                /* str 'Sorry, but I can't typeset math unless \textfont ' */
                1581;
            helpline[1] =
                /* str 'and \scriptfont 3 and \scriptscriptfont 3 have al' */
                1582;
            helpline[0] =
                /* str 'the \fontdimen values needed in math extension fo' */
                1583;
        }
        error();
        flushmath();
        danger = true;
    }
    m = curlist.modefield;
    l = false;
    p = finmlist(TEXNULL);
    if (curlist.modefield == -(integer)m) {
        /* comment:Check that another \.\$ follows */ {

            getxtoken();
            if (curcmd != MATHSHIFT) {
                {
                    if (interaction == ERRORSTOPMODE)
                        ;
                    if (filelineerrorstylep)
                        printfileline();
                    else
                        printnl(/* str '! ' */ 264);
                    print(/* str 'Display math should end with $$' */ 1584);
                }
                {
                    helpptr = 2;
                    helpline[1] = /* str 'The `$' that I just saw supposedly
                                     matches a prev' */
                        1585;
                    helpline[0] = /* str 'So I shall assume that you typed `$$'
                                     both times.' */
                        1586;
                }
                backerror();
            }
        }
        curmlist = p;
        curstyle = TEXTSTYLE;
        mlistpenalties = false;
        mlisttohlist();
        a = hpack(mem[memtop - 3].hh.v.RH, 0, ADDITIONAL);
        mem[a].hh.b1 = DLIST;
        unsave();
        decr(saveptr);
        if (savestack[saveptr + 0].cint == 1)
            l = true;
        danger = false;
        /* comment:Retrieve the prototype box */ if (curlist.modefield == MMODE)
            j = curlist.eTeXauxfield;
        /* comment:Check that the necessary fonts for math symbols ar */
        if ((fontparams[eqtb[MATHFONTBASE + TEXTSIZE + 2].hh.v.RH] <
             TOTALMATHSYPARAMS) ||
            (fontparams[eqtb[MATHFONTBASE + SCRIPTSIZE + 2].hh.v.RH] <
             TOTALMATHSYPARAMS) ||
            (fontparams[eqtb[MATHFONTBASE + SCRIPTSCRIPTSIZE + 2].hh.v.RH] <
             TOTALMATHSYPARAMS)) {
            {
                if (interaction == ERRORSTOPMODE)
                    ;
                if (filelineerrorstylep)
                    printfileline();
                else
                    printnl(/* str '! ' */ 264);
                print(/* str 'Math formula deleted' */ 1576);
            }
            {
                helpptr = 3;
                helpline[2] = /* str 'Sorry, but I can't typeset math unless
                                 \textfont ' */
                    1577;
                helpline[1] = /* str 'and \scriptfont 2 and \scriptscriptfont 2
                                 have al' */
                    1578;
                helpline[0] = /* str 'the \fontdimen values needed in math
                                 symbol fonts' */
                    1579;
            }
            error();
            flushmath();
            danger = true;
        } else if ((fontparams[eqtb[MATHFONTBASE + TEXTSIZE + 3].hh.v.RH] <
                    TOTALMATHEXPARAMS) ||
                   (fontparams[eqtb[MATHFONTBASE + SCRIPTSIZE + 3].hh.v.RH] <
                    TOTALMATHEXPARAMS) ||
                   (fontparams[eqtb[MATHFONTBASE + SCRIPTSCRIPTSIZE + 3]
                                   .hh.v.RH] < TOTALMATHEXPARAMS)) {
            {
                if (interaction == ERRORSTOPMODE)
                    ;
                if (filelineerrorstylep)
                    printfileline();
                else
                    printnl(/* str '! ' */ 264);
                print(/* str 'Math formula deleted' */ 1580);
            }
            {
                helpptr = 3;
                helpline[2] = /* str 'Sorry, but I can't typeset math unless
                                 \textfont ' */
                    1581;
                helpline[1] = /* str 'and \scriptfont 3 and \scriptscriptfont 3
                                 have al' */
                    1582;
                helpline[0] = /* str 'the \fontdimen values needed in math
                                 extension fo' */
                    1583;
            }
            error();
            flushmath();
            danger = true;
        }
        m = curlist.modefield;
        p = finmlist(TEXNULL);
    } else
        a = TEXNULL;
    if (m < 0) /* comment:Finish math in text */
    {
        {
            mem[curlist.tailfield].hh.v.RH =
                newmath(eqtb[DIMENBASE + MATHSURROUNDCODE].cint, /* @d12292@ */
                        0);
            curlist.tailfield = mem[curlist.tailfield].hh.v.RH;
        }
        curmlist = p;
        curstyle = TEXTSTYLE;
        mlistpenalties = (curlist.modefield > 0);
        mlisttohlist();
        mem[curlist.tailfield].hh.v.RH = mem[memtop - 3].hh.v.RH;
        while (mem[curlist.tailfield].hh.v.RH != TEXNULL)
            curlist.tailfield = mem[curlist.tailfield].hh.v.RH;
        {
            mem[curlist.tailfield].hh.v.RH =
                newmath(eqtb[DIMENBASE + MATHSURROUNDCODE].cint, /* @d12296@ */
                        1);
            curlist.tailfield = mem[curlist.tailfield].hh.v.RH;
        }
        curlist.auxfield.hh.v.LH = 1000;
        unsave();
    } else {

        if (a == TEXNULL) /* comment:Check that another \.\$ follows */
        {
            getxtoken();
            if (curcmd != MATHSHIFT) {
                {
                    if (interaction == ERRORSTOPMODE)
                        ;
                    if (filelineerrorstylep)
                        printfileline();
                    else
                        printnl(/* str '! ' */ 264);
                    print(/* str 'Display math should end with $$' */ 1584);
                }
                {
                    helpptr = 2;
                    helpline[1] = /* str 'The `$' that I just saw supposedly
                                     matches a prev' */
                        1585;
                    helpline[0] = /* str 'So I shall assume that you typed `$$'
                                     both times.' */
                        1586;
                }
                backerror();
            }
        }
        /* comment:Finish displayed math */ curmlist = p;
        curstyle = DISPLAYSTYLE;
        mlistpenalties = false;
        mlisttohlist();
        p = mem[memtop - 3].hh.v.RH;
        adjusttail = memtop - 5;
        preadjusttail = memtop - 14;
        b = hpack(p, 0, ADDITIONAL);
        p = mem[b + LISTOFFSET].hh.v.RH;
        t = adjusttail;
        adjusttail = TEXNULL;
        pret = preadjusttail;
        preadjusttail = TEXNULL;
        w = mem[b + WIDTHOFFSET].cint;
        z = eqtb[DIMENBASE + DISPLAYWIDTHCODE].cint;
        s = eqtb[DIMENBASE + DISPLAYINDENTCODE].cint;
        if (eqtb[INTBASE + PREDISPLAYDIRECTIONCODE].cint < 0)
            s = -(integer)s - z;
        if ((a == TEXNULL) || danger) {
            e = 0;
            q = 0;
        } else {

            e = mem[a + WIDTHOFFSET].cint;
            q = e +
                fontinfo[6 +
                         parambase[eqtb[MATHFONTBASE + TEXTSIZE + 2].hh.v.RH]]
                    .cint;
        }
        if (w + q >
            z) /* comment:Squeeze the equation as much as possible; if there */
        {
            if ((e != 0) &&
                ((w - totalshrink[NORMAL] + q <= z) ||
                 (totalshrink[FIL] != 0) || (totalshrink[FILL] != 0) ||
                 (totalshrink[FILLL] != 0))) {
                freenode(b, BOXNODESIZE);
                b = hpack(p, z - q, EXACTLY);
            } else {

                e = 0;
                if (w > z) {
                    freenode(b, BOXNODESIZE);
                    b = hpack(p, z, EXACTLY);
                }
            }
            w = mem[b + WIDTHOFFSET].cint;
        }
        /* comment:Determine the displacement, |d|, of the left edge  */ mem[b]
            .hh.b1 = DLIST;
        d = half(z - w);
        if ((e > 0) && (d < 2 * e)) {
            d = half(z - w - e);
            if (p != TEXNULL) {

                if (!(p >= himemmin)) {

                    if (mem[p].hh.b0 == GLUENODE)
                        d = 0;
                }
            }
        }
        /* comment:Append the glue or equation number preceding the d */ {

            mem[curlist.tailfield].hh.v.RH =
                newpenalty(eqtb[INTBASE + PREDISPLAYPENALTYCODE].cint);
            curlist.tailfield = mem[curlist.tailfield].hh.v.RH;
        }
        if ((d + s <= eqtb[DIMENBASE + PREDISPLAYSIZECODE].cint) || l) {
            g1 = ABOVEDISPLAYSKIPCODE;
            g2 = BELOWDISPLAYSKIPCODE;
        } else {

            g1 = ABOVEDISPLAYSHORTSKIPCODE;
            g2 = BELOWDISPLAYSHORTSKIPCODE;
        }
        if (l && (e == 0)) {
            appdisplay(j, a, 0);
            {
                mem[curlist.tailfield].hh.v.RH = newpenalty(INFPENALTY);
                curlist.tailfield = mem[curlist.tailfield].hh.v.RH;
            }
        } else {

            mem[curlist.tailfield].hh.v.RH = newparamglue(g1);
            curlist.tailfield = mem[curlist.tailfield].hh.v.RH;
        }
        /* comment:Append the display and perhaps also the equation n */
        if (e != 0) {
            r = newkern(z - w - e - d);
            if (l) {
                mem[a].hh.v.RH = r;
                mem[r].hh.v.RH = b;
                b = a;
                d = 0;
            } else {

                mem[b].hh.v.RH = r;
                mem[r].hh.v.RH = a;
            }
            b = hpack(b, 0, ADDITIONAL);
        }
        appdisplay(j, b, d);
        /* comment:Append the glue or equation number following the d */
        if ((a != TEXNULL) && (e == 0) && !l) {
            {
                mem[curlist.tailfield].hh.v.RH = newpenalty(INFPENALTY);
                curlist.tailfield = mem[curlist.tailfield].hh.v.RH;
            }
            appdisplay(j, a, z - mem[a + WIDTHOFFSET].cint);
            g2 = 0;
        }
        if (t != memtop - 5) {
            mem[curlist.tailfield].hh.v.RH = mem[memtop - 5].hh.v.RH;
            curlist.tailfield = t;
        }
        if (pret != memtop - 14) {
            mem[curlist.tailfield].hh.v.RH = mem[memtop - 14].hh.v.RH;
            curlist.tailfield = pret;
        }
        {
            mem[curlist.tailfield].hh.v.RH =
                newpenalty(eqtb[INTBASE + POSTDISPLAYPENALTYCODE].cint);
            curlist.tailfield = mem[curlist.tailfield].hh.v.RH;
        }
        if (g2 > 0) {
            mem[curlist.tailfield].hh.v.RH = newparamglue(g2);
            curlist.tailfield = mem[curlist.tailfield].hh.v.RH;
        }
        /* comment:Flush the prototype box */ flushnodelist(j);
        resumeafterdisplay();
    }
}
void resumeafterdisplay(void) {
    resumeafterdisplay_regmem if (curgroup != MATHSHIFTGROUP)
        confusion(/* str 'display' */ 1587);
    unsave();
    curlist.pgfield = curlist.pgfield + 3;
    pushnest();
    curlist.modefield = HMODE;
    curlist.auxfield.hh.v.LH = 1000;
    if (eqtb[INTBASE + LANGUAGECODE].cint <= 0)
        curlang = 0;
    else if (eqtb[INTBASE + LANGUAGECODE].cint > 255)
        curlang = 0;
    else
        curlang = eqtb[INTBASE + LANGUAGECODE].cint;
    curlist.auxfield.hh.v.RH = curlang;
    curlist.pgfield = (normmin(eqtb[INTBASE + LEFTHYPHENMINCODE].cint) * 64 +
                       normmin(eqtb[INTBASE + RIGHTHYPHENMINCODE].cint)) *
                          65536L +
                      curlang;
    /* comment:Scan an optional space */ {

        getxtoken();
        if (curcmd != SPACER)
            backinput();
    }
    if (nestptr == 1)
        buildpage();
}
/* comment:Declare subprocedures for |prefixed_command| */ void
getrtoken(void) {
    getrtoken_regmem labgetrtoken20restart : do { gettoken(); }
    while (!(curtok != SPACETOKEN))
        ;
    if ((curcs == 0) || (curcs > eqtbtop) ||
        ((curcs > FROZENCONTROLSEQUENCE) && (curcs <= EQTBSIZE))) {
        {
            if (interaction == ERRORSTOPMODE)
                ;
            if (filelineerrorstylep)
                printfileline();
            else
                printnl(/* str '! ' */ 264);
            print(/* str 'Missing control sequence inserted' */ 1605);
        }
        {
            helpptr = 5;
            helpline[4] =
                /* str 'Please don't say `\def cs{...}', say `\def\cs{...' */
                1606;
            helpline[3] =
                /* str 'I've inserted an inaccessible control sequence so' */
                1607;
            helpline[2] =
                /* str 'definition will be completed without mixing me up' */
                1608;
            helpline[1] =
                /* str 'You can recover graciously from this error, if yo' */
                1609;
            helpline[0] =
                /* str 'careful; see exercise 27.2 in The TeXbook.' */ 1610;
        }
        if (curcs == 0)
            backinput();
        curtok = /* @d12378@ */ 19609;
        inserror();
        goto labgetrtoken20restart;
    }
}
void trapzeroglue(void) {
    trapzeroglue_regmem if ((mem[curval + WIDTHOFFSET].cint == 0) &&
                            (mem[curval + 2].cint == 0) &&
                            (mem[curval + 3].cint == 0)) {
        incr(mem[membot].hh.v.RH);
        deleteglueref(curval);
        curval = membot;
    }
}
void zdoregistercommand(smallnumber a) {
    doregistercommand_regmem halfword l, q, r, s;
    unsigned char p;
    boolean e;
    integer w;
    q = curcmd;
    e = false;
    /* comment:Compute the register location |l| and its type |p| */ {

        if (q != REGISTER) {
            getxtoken();
            if ((curcmd >= ASSIGNINT) && (curcmd <= ASSIGNMUGLUE)) {
                l = curchr;
                p = curcmd - ASSIGNINT;
                goto labdoregistercommand40found;
            }
            if (curcmd != REGISTER) {
                {
                    if (interaction == ERRORSTOPMODE)
                        ;
                    if (filelineerrorstylep)
                        printfileline();
                    else
                        printnl(/* str '! ' */ 264);
                    print(/* str 'You can't use `' */ 786);
                }
                printcmdchr(curcmd, curchr);
                print(/* str '' after ' */ 787);
                printcmdchr(q, 0);
                {
                    helpptr = 1;
                    helpline[0] = /* str 'I'm forgetting what you said and not
                                     changing any' */
                        1644;
                }
                error();
                return;
            }
        }
        if ((curchr < membot) ||
            (curchr > /* @d12398@ */ /* @d12399@ */ /* @d12400@ */
                          /* @d12401@ */ /* @d12402@ */ membot + 19)) {
            l = curchr;
            p = (mem[l].hh.b0 / 16);
            e = true;
        } else {

            p = curchr - membot;
            scanregisternum();
            if (curval > 255) {
                findsaelement(p, curval, true);
                l = curptr;
                e = true;
            } else
                switch (p) {
                case INTVAL:
                    l = curval + COUNTBASE;
                    break;
                case DIMENVAL:
                    l = curval + SCALEDBASE;
                    break;
                case GLUEVAL:
                    l = curval + SKIPBASE;
                    break;
                case MUVAL:
                    l = curval + MUSKIPBASE;
                    break;
                }
        }
    }
labdoregistercommand40found:
    if (p < GLUEVAL) {

        if (e)
            w = mem[l + 2].cint;
        else
            w = eqtb[l].cint;
    } else if (e)
        s = mem[l + 1].hh.v.RH;
    else
        s = eqtb[l].hh.v.RH;
    if (q == REGISTER)
        scanoptionalequals();
    else if (scankeyword(/* str 'by' */ 1640))
        ;
    aritherror = false;
    if (q < /* @d12415@ */
        91) /* comment:Compute result of |register| or |advance|, put it  */ {

        if (p < GLUEVAL) {
            if (p == INTVAL)
                scanint();
            else
                scandimen(false, false, false);
            if (q == ADVANCE)
                curval = curval + w;
        } else {

            scanglue(p);
            if (q == ADVANCE) /* comment:Compute the sum of two glue
                                           specs */
            {
                q = newspec(curval);
                r = s;
                deleteglueref(curval);
                mem[q + WIDTHOFFSET].cint =
                    mem[q + WIDTHOFFSET].cint + mem[r + WIDTHOFFSET].cint;
                if (mem[q + 2].cint == 0)
                    mem[q].hh.b0 = NORMAL;
                if (mem[q].hh.b0 == mem[r].hh.b0)
                    mem[q + 2].cint = mem[q + 2].cint + mem[r + 2].cint;
                else if ((mem[q].hh.b0 < mem[r].hh.b0) &&
                         (mem[r + 2].cint != 0)) {
                    mem[q + 2].cint = mem[r + 2].cint;
                    mem[q].hh.b0 = mem[r].hh.b0;
                }
                if (mem[q + 3].cint == 0)
                    mem[q].hh.b1 = NORMAL;
                if (mem[q].hh.b1 == mem[r].hh.b1)
                    mem[q + 3].cint = mem[q + 3].cint + mem[r + 3].cint;
                else if ((mem[q].hh.b1 < mem[r].hh.b1) &&
                         (mem[r + 3].cint != 0)) {
                    mem[q + 3].cint = mem[r + 3].cint;
                    mem[q].hh.b1 = mem[r].hh.b1;
                }
                curval = q;
            }
        }
    } else /* comment:Compute result of |multiply| or |divide|, put it i */ {

        scanint();
        if (p < GLUEVAL) {

            if (q == MULTIPLY) {

                if (p == INTVAL)
                    curval = multandadd(w, curval, 0, 2147483647L);
                else
                    curval = multandadd(w, curval, 0, 1073741823L);
            } else
                curval = xovern(w, curval);
        } else {

            r = newspec(s);
            if (q == MULTIPLY) {
                mem[r + WIDTHOFFSET].cint = multandadd(
                    mem[s + WIDTHOFFSET].cint, curval, 0, 1073741823L);
                mem[r + 2].cint =
                    multandadd(mem[s + 2].cint, curval, 0, 1073741823L);
                mem[r + 3].cint =
                    multandadd(mem[s + 3].cint, curval, 0, 1073741823L);
            } else {

                mem[r + WIDTHOFFSET].cint =
                    xovern(mem[s + WIDTHOFFSET].cint, curval);
                mem[r + 2].cint = xovern(mem[s + 2].cint, curval);
                mem[r + 3].cint = xovern(mem[s + 3].cint, curval);
            }
            curval = r;
        }
    }
    if (aritherror) {
        {
            if (interaction == ERRORSTOPMODE)
                ;
            if (filelineerrorstylep)
                printfileline();
            else
                printnl(/* str '! ' */ 264);
            print(/* str 'Arithmetic overflow' */ 1641);
        }
        {
            helpptr = 2;
            helpline[1] =
                /* str 'I can't carry out that multiplication or division' */
                1642;
            helpline[0] = /* str 'since the result is out of range.' */ 1643;
        }
        if (p >= GLUEVAL)
            deleteglueref(curval);
        error();
        return;
    }
    if (p < GLUEVAL) {

        if (e) {

            if ((a >= 4))
                gsawdef(l, curval);
            else
                sawdef(l, curval);
        } else if ((a >= 4))
            geqworddefine(l, curval);
        else
            eqworddefine(l, curval);
    } else {

        trapzeroglue();
        if (e) {

            if ((a >= 4))
                gsadef(l, curval);
            else
                sadef(l, curval);
        } else if ((a >= 4))
            geqdefine(l, GLUEREF, curval);
        else
            eqdefine(l, GLUEREF, curval);
    }
}
void alteraux(void) {
    alteraux_regmem halfword c;
    if (curchr != abs(curlist.modefield))
        reportillegalcase();
    else {

        c = curchr;
        scanoptionalequals();
        if (c == VMODE) {
            scandimen(false, false, false);
            curlist.auxfield.cint = curval;
        } else {

            scanint();
            if ((curval <= 0) || (curval > 32767)) {
                {
                    if (interaction == ERRORSTOPMODE)
                        ;
                    if (filelineerrorstylep)
                        printfileline();
                    else
                        printnl(/* str '! ' */ 264);
                    print(/* str 'Bad space factor' */ 1647);
                }
                {
                    helpptr = 1;
                    helpline[0] = /* str 'I allow only values in the
                                     range 1..32767 here.' */
                        1648;
                }
                interror(curval);
            } else
                curlist.auxfield.hh.v.LH = curval;
        }
    }
}
void alterprevgraf(void) {
    alterprevgraf_regmem integer p;
    nest[nestptr] = curlist;
    p = nestptr;
    while (abs(nest[p].modefield) != VMODE)
        decr(p);
    scanoptionalequals();
    scanint();
    if (curval < 0) {
        {
            if (interaction == ERRORSTOPMODE)
                ;
            if (filelineerrorstylep)
                printfileline();
            else
                printnl(/* str '! ' */ 264);
            print(/* str 'Bad ' */ 1369);
        }
        printesc(/* str 'prevgraf' */ 612);
        {
            helpptr = 1;
            helpline[0] =
                /* str 'I allow only nonnegative values here.' */ 1649;
        }
        interror(curval);
    } else {

        nest[p].pgfield = curval;
        curlist = nest[nestptr];
    }
}
void alterpagesofar(void) {
    alterpagesofar_regmem unsigned char c;
    c = curchr;
    scanoptionalequals();
    scandimen(false, false, false);
    pagesofar[c] = curval;
}
void alterinteger(void) {
    alterinteger_regmem smallnumber c;
    c = curchr;
    scanoptionalequals();
    scanint();
    if (c == 0)
        deadcycles = /* comment:Cases for |alter_integer| */ curval;
    else if (c == 2) {
        if ((curval < BATCHMODE) || (curval > ERRORSTOPMODE)) {
            {
                if (interaction == ERRORSTOPMODE)
                    ;
                if (filelineerrorstylep)
                    printfileline();
                else
                    printnl(/* str '! ' */ 264);
                print(/* str 'Bad interaction mode' */ 2017);
            }
            {
                helpptr = 2;
                helpline[1] =
                    /* str 'Modes are 0=batch, 1=nonstop, 2=scroll, and' */
                    2018;
                helpline[0] =
                    /* str '3=errorstop. Proceed, and I'll ignore this case.' */
                    2019;
            }
            interror(curval);
        } else {

            curchr = curval;
            newinteraction();
        }
    } else
        insertpenalties = curval;
}
void alterboxdimen(void) {
    alterboxdimen_regmem smallnumber c;
    halfword b;
    c = curchr;
    scanregisternum();
    if (curval < 256)
        b = eqtb[BOXBASE + curval].hh.v.RH;
    else {

        findsaelement(4, curval, false);
        if (curptr == TEXNULL)
            b = TEXNULL;
        else
            b = mem[curptr + 1].hh.v.RH;
    }
    scanoptionalequals();
    scandimen(false, false, false);
    if (b != TEXNULL)
        mem[b + c].cint = curval;
}
void znewfont(smallnumber a) {
    newfont_regmem halfword u;
    scaled s;
    internalfontnumber f;
    strnumber t;
    unsigned char oldsetting;
    if (jobname == 0)
        openlogfile();
    getrtoken();
    u = curcs;
    if (u >= HASHBASE)
        t = hash[u].v.RH;
    else if (u >= SINGLEBASE) {

        if (u == NULLCS)
            t = /* str 'FONT' */ 1100;
        else
            t = u - SINGLEBASE;
    } else {

        oldsetting = selector;
        selector = NEWSTRING;
        print(/* str 'FONT' */ 1100);
        print(u - ACTIVEBASE);
        selector = oldsetting;
        {
            if (poolptr + 1 > poolsize)
                overflow(/* str 'pool size' */ 259, poolsize - initpoolptr);
        }
        t = makestring();
    }
    if ((a >= 4))
        geqdefine(u, SETFONT, FONTBASE);
    else
        eqdefine(u, SETFONT, FONTBASE);
    scanoptionalequals();
    scanfilename();
    /* comment:Scan the font size specification */ nameinprogress = true;
    if (scankeyword(/* str 'at' */ 1663)) /* comment:Put the \(p)(positive) `at'
                                             size into |s| */
    {
        scandimen(false, false, false);
        s = curval;
        if ((s <= 0) || (s >= 134217728L)) {
            {
                if (interaction == ERRORSTOPMODE)
                    ;
                if (filelineerrorstylep)
                    printfileline();
                else
                    printnl(/* str '! ' */ 264);
                print(/* str 'Improper `at' size (' */ 1665);
            }
            printscaled(s);
            print(/* str 'pt), replaced by 10pt' */ 1666);
            {
                helpptr = 2;
                helpline[1] = /* str 'I can only handle fonts at positive sizes
                                 that ar' */
                    1667;
                helpline[0] = /* str 'less than 2048pt, so I've changed what you
                                 said t' */
                    1668;
            }
            error();
            s = 10 * 65536L;
        }
    } else if (scankeyword(/* str 'scaled' */ 1664)) {
        scanint();
        s = -(integer)curval;
        if ((curval <= 0) || (curval > 32768L)) {
            {
                if (interaction == ERRORSTOPMODE)
                    ;
                if (filelineerrorstylep)
                    printfileline();
                else
                    printnl(/* str '! ' */ 264);
                print(/* str 'Illegal magnification has been changed to 1000' */
                      636);
            }
            {
                helpptr = 1;
                helpline[0] = /* str 'The magnification ratio must be between 1
                                 and 327' */
                    637;
            }
            interror(curval);
            s = -1000;
        }
    } else
        s = -1000;
    nameinprogress = false;
    /* comment:If this font has already been loaded, set |f| to t */ {
        register integer for_end;
        f = /* @d12497@ */ 1;
        for_end = fontptr;
        if (f <= for_end)
            do
                if (streqstr(fontname[f], curname) &&
                    streqstr(fontarea[f], curarea)) {
                    if (pdffontstep[f] == 0) {
                        if (s > 0) {
                            if (s == fontsize[f])
                                goto labnewfont50common_ending;
                        } else if (fontsize[f] ==
                                   xnoverd(fontdsize[f], -(integer)s, 1000))
                            goto labnewfont50common_ending;
                    }
                }
            while (f++ < for_end);
    }
    f = readfontinfo(u, curname, curarea, s);
labnewfont50common_ending:
    if ((a >= 4))
        geqdefine(u, SETFONT, f);
    else
        eqdefine(u, SETFONT, f);
    eqtb[FONTIDBASE + f] = eqtb[u];
    hash[FONTIDBASE + f].v.RH = t;
}
void newinteraction(void) {
    newinteraction_regmem println();
    interaction = curchr;
    if (interaction == BATCHMODE)
        kpsemaketexdiscarderrors = 1;
    else
        kpsemaketexdiscarderrors = 0;
    /* comment:Initialize the print |selector| based on |interact */
    if (interaction == BATCHMODE)
        selector = NOPRINT;
    else
        selector = TERMONLY;
    if (logopened)
        selector = selector + 2;
}
void issuemessage(void) {
    issuemessage_regmem
        unsigned char oldsetting;
    unsigned char c;
    strnumber s;
    c = curchr;
    mem[memtop - 12].hh.v.RH = scantoks(false, true);
    oldsetting = selector;
    selector = NEWSTRING;
    messageprinting = true;
    activenoconvert = true;
    tokenshow(defref);
    messageprinting = false;
    activenoconvert = false;
    selector = oldsetting;
    flushlist(defref);
    {
        if (poolptr + 1 > poolsize)
            overflow(/* str 'pool size' */ 259, poolsize - initpoolptr);
    }
    s = makestring();
    if (c == 0) /* comment:Print string |s| on the terminal */
    {
        if (termoffset + (strstart[s + 1] - strstart[s]) > maxprintline - 2)
            println();
        else if ((termoffset > 0) || (fileoffset > 0))
            printchar(/* str ' ' */ 32);
        print(s);
        fflush(stdout);
    } else /* comment:Print string |s| as an error message */ {

        {
            if (interaction == ERRORSTOPMODE)
                ;
            if (filelineerrorstylep)
                printfileline();
            else
                printnl(/* str '! ' */ 264);
            print(/* str '' */ 345);
        }
        print(s);
        if (eqtb[ERRHELPLOC].hh.v.RH != TEXNULL)
            useerrhelp = true;
        else if (longhelpseen) {
            helpptr = 1;
            helpline[0] = /* str '(That was another \errmessage.)' */ 1675;
        } else {

            if (interaction < ERRORSTOPMODE)
                longhelpseen = true;
            {
                helpptr = 4;
                helpline[3] = /* str 'This error message was generated by an
                                 \errmessag' */
                    1676;
                helpline[2] =
                    /* str 'command, so I can't give any explicit help.' */
                    1677;
                helpline[1] =
                    /* str 'Pretend that you're Hercule Poirot' */ 1678;
                helpline[0] =
                    /* str 'and deduce the truth by order and method.' */ 1679;
            }
        }
        error();
        useerrhelp = false;
    }
    {
        decr(strptr);
        poolptr = strstart[strptr];
    }
}
void shiftcase(void) {
    shiftcase_regmem halfword b;
    halfword p;
    halfword t;
    eightbits c;
    b = curchr;
    p = scantoks(false, false);
    p = mem[defref].hh.v.RH;
    while (p != TEXNULL) {

        /* comment:Change the case of the token in |p|, if a change i */ t =
            mem[p].hh.v.LH;
        if (t < /* @d12802@ */ 4352) {
            c = t % 256;
            if (eqtb[b + c].hh.v.RH != 0)
                mem[p].hh.v.LH = t - c + eqtb[b + c].hh.v.RH;
        }
        p = mem[p].hh.v.RH;
    }
    begintokenlist(mem[defref].hh.v.RH, BACKEDUP);
    {
        mem[defref].hh.v.RH = avail;
        avail = defref;
        mem[defref].hh.me = 0;
        ;
#ifdef STAT
        decr(dynused);
#endif /* STAT */
    }
}
void showwhatever(void) {
    showwhatever_regmem halfword p;
    smallnumber t;
    unsigned char m;
    integer l;
    integer n;
    switch (curchr) {
    case SHOWLISTS: {
        begindiagnostic();
        showactivities();
    } break;
    case SHOWBOXCODE:
        /* comment:Show the current contents of a box */ {

            scanregisternum();
            if (curval < 256)
                p = eqtb[BOXBASE + curval].hh.v.RH;
            else {

                findsaelement(4, curval, false);
                if (curptr == TEXNULL)
                    p = TEXNULL;
                else
                    p = mem[curptr + 1].hh.v.RH;
            }
            begindiagnostic();
            printnl(/* str '> \box' */ 1695);
            printint(curval);
            printchar(/* str '=' */ 61);
            if (p == TEXNULL)
                print(/* str 'void' */ 430);
            else
                showbox(p);
        }
        break;
    case SHOWCODE:
        /* comment:Show the current meaning of a token, then |goto co */ {

            gettoken();
            if (interaction == ERRORSTOPMODE)
                ;
            printnl(/* str '> ' */ 1691);
            if (curcs != 0) {
                sprintcs(curcs);
                printchar(/* str '=' */ 61);
            }
            printmeaning();
            goto labshowwhatever50common_ending;
        }
        break;
    /* comment:Cases for |show_whatever| */ case SHOWGROUPS : {
        begindiagnostic();
        showsavegroups();
    } break;
    case SHOWIFS: {
        begindiagnostic();
        printnl(/* str '' */ 345);
        println();
        if (condptr == TEXNULL) {
            printnl(/* str '### ' */ 379);
            print(/* str 'no active conditionals' */ 2014);
        } else {

            p = condptr;
            n = 0;
            do {
                incr(n);
                p = mem[p].hh.v.RH;
            } while (!(p == TEXNULL));
            p = condptr;
            t = curif;
            l = ifline;
            m = iflimit;
            do {
                printnl(/* str '### level ' */ 2015);
                printint(n);
                print(/* str '' */ 651);
                printcmdchr(IFTEST, t);
                if (m == FICODE)
                    printesc(/* str 'else' */ 931);
                if (l != 0) {
                    print(/* str ' entered on line ' */ 2013);
                    printint(l);
                }
                decr(n);
                t = mem[p].hh.b1;
                l = mem[p + 1].cint;
                m = mem[p].hh.b0;
                p = mem[p].hh.v.RH;
            } while (!(p == TEXNULL));
        }
    } break;
    default:
        /* comment:Show the current value of some parameter or regist */ {

            p = thetoks();
            if (interaction == ERRORSTOPMODE)
                ;
            printnl(/* str '> ' */ 1691);
            tokenshow(memtop - 3);
            flushlist(mem[memtop - 3].hh.v.RH);
            goto labshowwhatever50common_ending;
        }
        break;
    }
    /* comment:Complete a potentially long \.{\\show} command */ enddiagnostic(
        true);
    {
        if (interaction == ERRORSTOPMODE)
            ;
        if (filelineerrorstylep)
            printfileline();
        else
            printnl(/* str '! ' */ 264);
        print(/* str 'OK' */ 1696);
    }
    if (selector == TERMANDLOG) {

        if (eqtb[INTBASE + TRACINGONLINECODE].cint <= 0) {
            selector = TERMONLY;
            print(/* str ' (see the transcript file)' */ 1697);
            selector = TERMANDLOG;
        }
    }
labshowwhatever50common_ending:
    if (interaction < ERRORSTOPMODE) {
        helpptr = 0;
        decr(errorcount);
    } else if (eqtb[INTBASE + TRACINGONLINECODE].cint > 0) {
        {
            helpptr = 3;
            helpline[2] =
                /* str 'This isn't an error message; I'm just \showing so' */
                1686;
            helpline[1] =
                /* str 'Type `I\show...' to show more (e.g., \show\cs,' */ 1687;
            helpline[0] =
                /* str '\showthe\count10, \showbox255, \showlists).' */ 1688;
        }
    } else {

        {
            helpptr = 5;
            helpline[4] =
                /* str 'This isn't an error message; I'm just \showing so' */
                1686;
            helpline[3] =
                /* str 'Type `I\show...' to show more (e.g., \show\cs,' */ 1687;
            helpline[2] =
                /* str '\showthe\count10, \showbox255, \showlists).' */ 1688;
            helpline[1] =
                /* str 'And type `I\tracingonline=1\show...' to show boxe' */
                1689;
            helpline[0] =
                /* str 'lists on your terminal as well as in the transcri' */
                1690;
        }
    }
    error();
}
/* comment:Declare procedures needed in |do_extension| */ void
znewwhatsit(smallnumber s, smallnumber w) {
    newwhatsit_regmem halfword p;
    p = getnode(w);
    mem[p].hh.b0 = WHATSITNODE;
    mem[p].hh.b1 = s;
    mem[curlist.tailfield].hh.v.RH = p;
    curlist.tailfield = p;
}
void znewwritewhatsit(smallnumber w) {
    newwritewhatsit_regmem newwhatsit(curchr, w);
    if (w != WRITENODESIZE)
        scanfourbitint();
    else {

        scanint();
        if (curval < 0)
            curval = 17;
        else if ((curval > 15) && (curval != 18))
            curval = 16;
    }
    mem[curlist.tailfield + 1].hh.b0 = curval;
    if (eqtb[INTBASE + MUBYTEOUTCODE].cint + 64 < 0)
        mem[curlist.tailfield + 1].hh.b1 = 0;
    else if (eqtb[INTBASE + MUBYTEOUTCODE].cint + 64 >= 2 * 64)
        mem[curlist.tailfield + 1].hh.b1 = 2 * 64 - 1;
    else
        mem[curlist.tailfield + 1].hh.b1 =
            eqtb[INTBASE + MUBYTEOUTCODE].cint + 64;
}
void zcheckpdfoutput(strnumber s, boolean iserror) {
    checkpdfoutput_regmem if (eqtb[INTBASE + PDFOUTPUTCODE].cint <= 0) {
        if (iserror)
            pdferror(
                s, /* str 'not allowed in DVI mode (\pdfoutput <= 0)' */ 1778);
        else
            pdfwarning(
                s, /* str 'not allowed in DVI mode (\pdfoutput <= 0); ignori' */
                1779, true, true);
    }
}
void scanpdfexttoks(void) {
    scanpdfexttoks_regmem {
        if (scantoks(false, true) != 0)
            ;
    }
}
void comparestrings(void) {
    comparestrings_regmem strnumber s1, s2;
    poolpointer i1, i2, j1, j2;
    halfword savecurcs;
    savecurcs = curcs;
    {
        if (scantoks(false, true) != 0)
            ;
    }
    s1 = tokenstostring(defref);
    deletetokenref(defref);
    curcs = savecurcs;
    {
        if (scantoks(false, true) != 0)
            ;
    }
    s2 = tokenstostring(defref);
    deletetokenref(defref);
    i1 = strstart[s1];
    j1 = strstart[s1 + 1];
    i2 = strstart[s2];
    j2 = strstart[s2 + 1];
    while ((i1 < j1) && (i2 < j2)) {

        if (strpool[i1] < strpool[i2]) {
            curval = -1;
            goto labcomparestrings30done;
        }
        if (strpool[i1] > strpool[i2]) {
            curval = 1;
            goto labcomparestrings30done;
        }
        incr(i1);
        incr(i2);
    }
    if ((i1 == j1) && (i2 == j2))
        curval = 0;
    else if (i1 < j1)
        curval = 1;
    else
        curval = -1;
labcomparestrings30done:
    flushstr(s2);
    flushstr(s1);
    curvallevel = INTVAL;
}
void zscaleimage(integer n) {
    scaleimage_regmem integer x, y, xr, yr;
    scaled w, h;
    integer defaultres;
    integer image;
    image = pdfmem[objtab[n].int4 + 4];
    if ((imagerotate(image) == 90) || (imagerotate(image) == 270)) {
        y = imagewidth(image);
        x = imageheight(image);
        yr = imagexres(image);
        xr = imageyres(image);
    } else {

        x = imagewidth(image);
        y = imageheight(image);
        xr = imagexres(image);
        yr = imageyres(image);
    }
    if ((xr > 65535L) || (yr > 65535L)) {
        xr = 0;
        yr = 0;
        pdfwarning(/* str 'ext1' */ 1777,
                   /* str 'too large image resolution ignored' */ 1809, true,
                   true);
    }
    if ((x <= 0) || (y <= 0) || (xr < 0) || (yr < 0))
        pdferror(/* str 'ext1' */ 1777,
                 /* str 'invalid image dimensions' */ 1810);
    if (ispdfimage(image)) {
        w = x;
        h = y;
    } else {

        defaultres =
            fixint(eqtb[INTBASE + PDFIMAGERESOLUTIONCODE].cint, 0, 65535L);
        if ((defaultres > 0) && ((xr == 0) || (yr == 0))) {
            xr = defaultres;
            yr = defaultres;
        }
        if ((pdfmem[objtab[n].int4 + 0] == -1073741824L) &&
            (pdfmem[objtab[n].int4 + 1] == -1073741824L)) {
            if ((xr > 0) && (yr > 0)) {
                w = extxnoverd(onehundredinch, x, 100 * xr);
                h = extxnoverd(onehundredinch, y, 100 * yr);
            } else {

                w = extxnoverd(onehundredinch, x, 7200);
                h = extxnoverd(onehundredinch, y, 7200);
            }
        }
    }
    if ((pdfmem[objtab[n].int4 + 0] == -1073741824L) &&
        (pdfmem[objtab[n].int4 + 1] == -1073741824L) &&
        (pdfmem[objtab[n].int4 + 2] == -1073741824L)) {
        pdfmem[objtab[n].int4 + 0] = w;
        pdfmem[objtab[n].int4 + 1] = h;
        pdfmem[objtab[n].int4 + 2] = 0;
    } else if ((pdfmem[objtab[n].int4 + 0] == -1073741824L)) {
        if ((pdfmem[objtab[n].int4 + 1] == -1073741824L)) {
            pdfmem[objtab[n].int4 + 0] = extxnoverd(h, x, y);
            pdfmem[objtab[n].int4 + 1] = h - pdfmem[objtab[n].int4 + 2];
        } else if ((pdfmem[objtab[n].int4 + 2] == -1073741824L)) {
            pdfmem[objtab[n].int4 + 0] =
                extxnoverd(pdfmem[objtab[n].int4 + 1], x, y);
            pdfmem[objtab[n].int4 + 2] = 0;
        } else {

            pdfmem[objtab[n].int4 + 0] = extxnoverd(
                pdfmem[objtab[n].int4 + 1] + pdfmem[objtab[n].int4 + 2], x, y);
        }
    } else {

        if ((pdfmem[objtab[n].int4 + 1] == -1073741824L) &&
            (pdfmem[objtab[n].int4 + 2] == -1073741824L)) {
            pdfmem[objtab[n].int4 + 1] =
                extxnoverd(pdfmem[objtab[n].int4 + 0], y, x);
            pdfmem[objtab[n].int4 + 2] = 0;
        } else if ((pdfmem[objtab[n].int4 + 1] == -1073741824L)) {
            pdfmem[objtab[n].int4 + 1] =
                extxnoverd(pdfmem[objtab[n].int4 + 0], y, x) -
                pdfmem[objtab[n].int4 + 2];
        } else if ((pdfmem[objtab[n].int4 + 2] == -1073741824L)) {
            pdfmem[objtab[n].int4 + 2] = 0;
        } else
            ;
    }
}
integer scanpdfboxspec(void) {
    register integer Result;
    scanpdfboxspec_regmem Result = 0;
    if (scankeyword(/* str 'mediabox' */ 1811))
        Result = pdfboxspecmedia;
    else if (scankeyword(/* str 'cropbox' */ 1812))
        Result = pdfboxspeccrop;
    else if (scankeyword(/* str 'bleedbox' */ 1813))
        Result = pdfboxspecbleed;
    else if (scankeyword(/* str 'trimbox' */ 1814))
        Result = pdfboxspectrim;
    else if (scankeyword(/* str 'artbox' */ 1815))
        Result = pdfboxspecart;
    return Result;
}
void scanaltrule(void) {
    scanaltrule_regmem if (altrule == TEXNULL) altrule = newrule();
    mem[altrule + WIDTHOFFSET].cint = -1073741824L;
    mem[altrule + HEIGHTOFFSET].cint = -1073741824L;
    mem[altrule + DEPTHOFFSET].cint = -1073741824L;
labscanaltrule21reswitch:
    if (scankeyword(/* str 'width' */ 836)) {
        scandimen(false, false, false);
        mem[altrule + WIDTHOFFSET].cint = curval;
        goto labscanaltrule21reswitch;
    }
    if (scankeyword(/* str 'height' */ 837)) {
        scandimen(false, false, false);
        mem[altrule + HEIGHTOFFSET].cint = curval;
        goto labscanaltrule21reswitch;
    }
    if (scankeyword(/* str 'depth' */ 838)) {
        scandimen(false, false, false);
        mem[altrule + DEPTHOFFSET].cint = curval;
        goto labscanaltrule21reswitch;
    }
}
void scanimage(void) {
    scanimage_regmem integer k;
    strnumber named;
    strnumber s;
    integer page, pagebox, colorspace;
    incr(pdfximagecount);
    pdfcreateobj(8, pdfximagecount);
    k = objptr;
    objtab[k].int4 = pdfgetmem(5);
    scanaltrule();
    pdfmem[objtab[k].int4 + 0] = mem[altrule + WIDTHOFFSET].cint;
    pdfmem[objtab[k].int4 + 1] = mem[altrule + HEIGHTOFFSET].cint;
    pdfmem[objtab[k].int4 + 2] = mem[altrule + DEPTHOFFSET].cint;
    if (scankeyword(/* str 'attr' */ 1802)) {
        scanpdfexttoks();
        pdfmem[objtab[k].int4 + 3] = defref;
    } else
        pdfmem[objtab[k].int4 + 3] = TEXNULL;
    named = 0;
    if (scankeyword(/* str 'named' */ 1816)) {
        scanpdfexttoks();
        named = tokenstostring(defref);
        deletetokenref(defref);
    } else if (scankeyword(/* str 'page' */ 889)) {
        scanint();
        page = curval;
    } else
        page = 1;
    if (scankeyword(/* str 'colorspace' */ 1817)) {
        scanint();
        colorspace = curval;
    } else
        colorspace = 0;
    pagebox = scanpdfboxspec();
    if (pagebox == 0)
        pagebox = eqtb[INTBASE + PDFPAGEBOXCODE].cint;
    scanpdfexttoks();
    s = tokenstostring(defref);
    deletetokenref(defref);
    if (eqtb[INTBASE + PDFOPTIONALWAYSUSEPDFPAGEBOXCODE].cint != 0) {
        pdfwarning(
            /* str 'PDF inclusion' */ 1818,
            /* str 'Primitive \pdfoptionalwaysusepdfpagebox is obsole' */ 1819,
            true, true);
        eqtb[INTBASE + PDFFORCEPAGEBOXCODE].cint =
            eqtb[INTBASE + PDFOPTIONALWAYSUSEPDFPAGEBOXCODE].cint;
        eqtb[INTBASE + PDFOPTIONALWAYSUSEPDFPAGEBOXCODE].cint = 0;
        warnpdfpagebox = false;
    }
    if (eqtb[INTBASE + PDFOPTIONPDFINCLUSIONERRORLEVELCODE].cint != 0) {
        pdfwarning(
            /* str 'PDF inclusion' */ 1818,
            /* str 'Primitive \pdfoptionpdfinclusionerrorlevel is obs' */ 1820,
            true, true);
        eqtb[INTBASE + PDFINCLUSIONERRORLEVELCODE].cint =
            eqtb[INTBASE + PDFOPTIONPDFINCLUSIONERRORLEVELCODE].cint;
        eqtb[INTBASE + PDFOPTIONPDFINCLUSIONERRORLEVELCODE].cint = 0;
    }
    if (eqtb[INTBASE + PDFFORCEPAGEBOXCODE].cint > 0) {
        if (warnpdfpagebox) {
            pdfwarning(
                /* str 'PDF inclusion' */ 1818,
                /* str 'Primitive \pdfforcepagebox is obsolete; use \pdfp' */
                1821, true, true);
            warnpdfpagebox = false;
        }
        pagebox = eqtb[INTBASE + PDFFORCEPAGEBOXCODE].cint;
    }
    if (pagebox == 0)
        pagebox = pdfboxspeccrop;
    pdfmem[objtab[k].int4 + 4] =
        readimage(s, page, named, colorspace, pagebox,
                  eqtb[INTBASE + PDFMINORVERSIONCODE].cint,
                  eqtb[INTBASE + PDFINCLUSIONERRORLEVELCODE].cint);
    if (named != 0)
        flushstr(named);
    flushstr(s);
    scaleimage(k);
    pdflastximage = k;
    pdflastximagepages = imagepages(pdfmem[objtab[k].int4 + 4]);
    pdflastximagecolordepth = imagecolordepth(pdfmem[objtab[k].int4 + 4]);
}
halfword scanaction(void) {
    register halfword Result;
    scanaction_regmem integer p;
    p = getnode(3);
    Result = p;
    mem[p + 1].hh.v.LH = TEXNULL;
    mem[p + 2].hh.v.RH = TEXNULL;
    if (scankeyword(/* str 'user' */ 1824))
        mem[p].hh.b0 = 3;
    else if (scankeyword(/* str 'goto' */ 1825))
        mem[p].hh.b0 = 1;
    else if (scankeyword(/* str 'thread' */ 1826))
        mem[p].hh.b0 = 2;
    else
        pdferror(/* str 'ext1' */ 1777, /* str 'action type missing' */ 1827);
    if (mem[p].hh.b0 == 3) {
        scanpdfexttoks();
        mem[p + 2].hh.v.LH = defref;
        return Result;
    }
    if (scankeyword(/* str 'file' */ 878)) {
        scanpdfexttoks();
        mem[p + 1].hh.v.LH = defref;
    }
    if (scankeyword(/* str 'page' */ 889)) {
        if (mem[p].hh.b0 != 1)
            pdferror(/* str 'ext1' */ 1777,
                     /* str 'only GoTo action can be used with `page'' */ 1828);
        mem[p].hh.b0 = 0;
        scanint();
        if (curval <= 0)
            pdferror(/* str 'ext1' */ 1777,
                     /* str 'page number must be positive' */ 1829);
        mem[p].hh.v.RH = curval;
        mem[p].hh.b1 = 0;
        scanpdfexttoks();
        mem[p + 2].hh.v.LH = defref;
    } else if (scankeyword(/* str 'name' */ 1830)) {
        scanpdfexttoks();
        mem[p].hh.b1 = 1;
        mem[p].hh.v.RH = defref;
    } else if (scankeyword(/* str 'num' */ 1198)) {
        if ((mem[p].hh.b0 == 1) && (mem[p + 1].hh.v.LH != TEXNULL))
            pdferror(
                /* str 'ext1' */ 1777,
                /* str '`goto' option cannot be used with both `file' and' */
                1831);
        scanint();
        if (curval <= 0)
            pdferror(/* str 'ext1' */ 1777,
                     /* str 'num identifier must be positive' */ 1832);
        mem[p].hh.b1 = 0;
        mem[p].hh.v.RH = curval;
    } else
        pdferror(/* str 'ext1' */ 1777,
                 /* str 'identifier type missing' */ 1833);
    if (scankeyword(/* str 'newwindow' */ 1834)) {
        mem[p + 1].hh.v.RH = 1;
        /* comment:Scan an optional space */ {

            getxtoken();
            if (curcmd != SPACER)
                backinput();
        }
    } else if (scankeyword(/* str 'nonewwindow' */ 1835)) {
        mem[p + 1].hh.v.RH = 2;
        /* comment:Scan an optional space */ {

            getxtoken();
            if (curcmd != SPACER)
                backinput();
        }
    } else
        mem[p + 1].hh.v.RH = 0;
    if ((mem[p + 1].hh.v.RH > 0) &&
        (((mem[p].hh.b0 != 1) && (mem[p].hh.b0 != 0)) ||
         (mem[p + 1].hh.v.LH == TEXNULL)))
        pdferror(
            /* str 'ext1' */ 1777,
            /* str '`newwindow'`nonewwindow' must be used with `goto' */ 1836);
    return Result;
}
void znewannotwhatsit(smallnumber w, smallnumber s) {
    newannotwhatsit_regmem newwhatsit(w, s);
    scanaltrule();
    mem[curlist.tailfield + 1].cint = mem[altrule + WIDTHOFFSET].cint;
    mem[curlist.tailfield + 2].cint = mem[altrule + HEIGHTOFFSET].cint;
    mem[curlist.tailfield + 3].cint = mem[altrule + DEPTHOFFSET].cint;
    if ((w == /* @d13133@ */ 14)) {
        if (scankeyword(/* str 'attr' */ 1802)) {
            scanpdfexttoks();
            mem[curlist.tailfield + 5].hh.v.LH = defref;
        } else
            mem[curlist.tailfield + 5].hh.v.LH = TEXNULL;
    }
    if ((w == /* @d13135@ */ 18) || (w == /* @d13136@ */ 19)) {
        if (scankeyword(/* str 'attr' */ 1802)) {
            scanpdfexttoks();
            mem[curlist.tailfield + 6].hh.v.LH = defref;
        } else
            mem[curlist.tailfield + 6].hh.v.LH = TEXNULL;
    }
}
integer zoutlinelistcount(halfword p) {
    register integer Result;
    outlinelistcount_regmem integer k;
    k = 1;
    while (pdfmem[objtab[p].int4 + 2] != 0) {

        incr(k);
        p = pdfmem[objtab[p].int4 + 2];
    }
    Result = k;
    return Result;
}
void scanthreadid(void) {
    scanthreadid_regmem if (scankeyword(/* str 'num' */ 1198)) {
        scanint();
        if (curval <= 0)
            pdferror(/* str 'ext1' */ 1777,
                     /* str 'num identifier must be positive' */ 1832);
        if (curval > 2147483647L)
            pdferror(/* str 'ext1' */ 1777, /* str 'number too big' */ 1028);
        mem[curlist.tailfield + 5].hh.v.RH = curval;
        mem[curlist.tailfield + 5].hh.b1 = 0;
    }
    else if (scankeyword(/* str 'name' */ 1830)) {
        scanpdfexttoks();
        mem[curlist.tailfield + 5].hh.v.RH = defref;
        mem[curlist.tailfield + 5].hh.b1 = 1;
    }
    else pdferror(/* str 'ext1' */ 1777,
                  /* str 'identifier type missing' */ 1833);
}
halfword znewsnapnode(smallnumber s) {
    register halfword Result;
    newsnapnode_regmem halfword p;
    scanglue(GLUEVAL);
    if (mem[curval + WIDTHOFFSET].cint < 0)
        pdferror(/* str 'ext1' */ 1777, /* str 'negative snap glue' */ 1863);
    p = getnode(3);
    mem[p].hh.b0 = WHATSITNODE;
    mem[p].hh.b1 = s;
    mem[p].hh.v.RH = TEXNULL;
    mem[p + 1].hh.v.LH = curval;
    mem[p + 2].cint = 0;
    Result = p;
    return Result;
}
halfword zconcattokens(halfword q, halfword r) {
    register halfword Result;
    concattokens_regmem halfword p;
    if (q == TEXNULL) {
        Result = r;
        return Result;
    }
    p = q;
    while (mem[p].hh.v.RH != TEXNULL)
        p = mem[p].hh.v.RH;
    mem[p].hh.v.RH = mem[r].hh.v.RH;
    {
        mem[r].hh.v.RH = avail;
        avail = r;
        mem[r].hh.me = 0;
        ;
#ifdef STAT
        decr(dynused);
#endif /* STAT */
    }
    Result = q;
    return Result;
}
void pdfincludechars(void) {
    pdfincludechars_regmem strnumber s;
    poolpointer k;
    internalfontnumber f;
    scanfontident();
    f = curval;
    if (f == FONTBASE)
        pdferror(/* str 'font' */ 595, /* str 'invalid font identifier' */ 873);
    pdfcheckvfcurval();
    if (!fontused[f])
        pdfinitfont(f);
    scanpdfexttoks();
    s = tokenstostring(defref);
    deletetokenref(defref);
    k = strstart[s];
    while (k < strstart[s + 1]) {

        pdfmarkchar(f, strpool[k]);
        incr(k);
    }
    flushstr(s);
}
void glyphtounicode(void) {
    glyphtounicode_regmem strnumber s1, s2;
    scanpdfexttoks();
    s1 = tokenstostring(defref);
    deletetokenref(defref);
    scanpdfexttoks();
    s2 = tokenstostring(defref);
    deletetokenref(defref);
    deftounicode(s1, s2);
    flushstr(s2);
    flushstr(s1);
}
void zthreadtitle(integer thread) {
    threadtitle_regmem pdfprint(/* str 'Title (' */ 1880);
    if (objtab[thread].int0 < 0)
        pdfprint(-(integer)objtab[thread].int0);
    else
        pdfprintint(objtab[thread].int0);
    {
        pdfprint(/* str ')' */ 41);
        {
            {
                if (pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfosgetosbuf(1);
                else if (!pdfosmode && (1 > pdfbufsize))
                    overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
                else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfflush();
            }
            {
                pdfbuf[pdfptr] = 10;
                incr(pdfptr);
            }
        }
    }
}
void zpdffixthread(integer thread) {
    pdffixthread_regmem halfword a;
    pdfwarning(/* str 'thread' */ 1826, /* str 'destination ' */ 1881, false,
               false);
    if (objtab[thread].int0 < 0) {
        print(/* str 'name{' */ 1197);
        print(-(integer)objtab[thread].int0);
        print(/* str '}' */ 125);
    } else {

        print(/* str 'num' */ 1198);
        printint(objtab[thread].int0);
    }
    print(/* str ' has been referenced but does not exist, replaced' */ 1199);
    println();
    println();
    pdfnewdict(0, 0, 0);
    a = objptr;
    pdfindirectln(/* str 'T' */ 84, thread);
    pdfindirectln(/* str 'V' */ 86, a);
    pdfindirectln(/* str 'N' */ 78, a);
    pdfindirectln(/* str 'P' */ 80, headtab[1]);
    pdfprint(/* str 'R [0 0 ' */ 1882);
    pdfprintbp(eqtb[DIMENBASE + PDFPAGEWIDTHCODE].cint);
    {
        {
            if (pdfosmode && (1 + pdfptr > pdfbufsize))
                pdfosgetosbuf(1);
            else if (!pdfosmode && (1 > pdfbufsize))
                overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
            else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                pdfflush();
        }
        {
            pdfbuf[pdfptr] = /* str ' ' */ 32;
            incr(pdfptr);
        }
    }
    pdfprintbp(eqtb[DIMENBASE + PDFPAGEHEIGHTCODE].cint);
    {
        pdfprint(/* str ']' */ 93);
        {
            {
                if (pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfosgetosbuf(1);
                else if (!pdfosmode && (1 > pdfbufsize))
                    overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
                else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfflush();
            }
            {
                pdfbuf[pdfptr] = 10;
                incr(pdfptr);
            }
        }
    }
    pdfenddict();
    pdfbegindict(thread, 1);
    {
        pdfprint(/* str 'I << ' */ 1883);
        {
            {
                if (pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfosgetosbuf(1);
                else if (!pdfosmode && (1 > pdfbufsize))
                    overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
                else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfflush();
            }
            {
                pdfbuf[pdfptr] = 10;
                incr(pdfptr);
            }
        }
    }
    threadtitle(thread);
    {
        pdfprint(/* str '>>' */ 1018);
        {
            {
                if (pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfosgetosbuf(1);
                else if (!pdfosmode && (1 > pdfbufsize))
                    overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
                else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfflush();
            }
            {
                pdfbuf[pdfptr] = 10;
                incr(pdfptr);
            }
        }
    }
    pdfindirectln(/* str 'F' */ 70, a);
    pdfenddict();
}
void zoutthread(integer thread) {
    outthread_regmem halfword a, b;
    integer lastattr;
    if (objtab[thread].int4 == 0) {
        pdffixthread(thread);
        return;
    }
    pdfbegindict(thread, 1);
    a = objtab[thread].int4;
    b = a;
    lastattr = 0;
    do {
        if (pdfmem[objtab[a].int4 + 4] != 0)
            lastattr = pdfmem[objtab[a].int4 + 4];
        a = pdfmem[objtab[a].int4 + 2];
    } while (!(a == b));
    if (lastattr != 0) {
        pdfprint(lastattr);
        {
            {
                if (pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfosgetosbuf(1);
                else if (!pdfosmode && (1 > pdfbufsize))
                    overflow(/* str 'PDF output buffer' */ 1004, pdfopbufsize);
                else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                    pdfflush();
            }
            {
                pdfbuf[pdfptr] = 10;
                incr(pdfptr);
            }
        }
    } else {

        {
            pdfprint(/* str 'I << ' */ 1883);
            {
                {
                    if (pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfosgetosbuf(1);
                    else if (!pdfosmode && (1 > pdfbufsize))
                        overflow(/* str 'PDF output buffer' */ 1004,
                                 pdfopbufsize);
                    else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfflush();
                }
                {
                    pdfbuf[pdfptr] = 10;
                    incr(pdfptr);
                }
            }
        }
        threadtitle(thread);
        {
            pdfprint(/* str '>>' */ 1018);
            {
                {
                    if (pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfosgetosbuf(1);
                    else if (!pdfosmode && (1 > pdfbufsize))
                        overflow(/* str 'PDF output buffer' */ 1004,
                                 pdfopbufsize);
                    else if (!pdfosmode && (1 + pdfptr > pdfbufsize))
                        pdfflush();
                }
                {
                    pdfbuf[pdfptr] = 10;
                    incr(pdfptr);
                }
            }
        }
    }
    pdfindirectln(/* str 'F' */ 70, a);
    pdfenddict();
    do {
        pdfbegindict(a, 1);
        if (a == b)
            pdfindirectln(/* str 'T' */ 84, thread);
        pdfindirectln(/* str 'V' */ 86, pdfmem[objtab[a].int4 + 3]);
        pdfindirectln(/* str 'N' */ 78, pdfmem[objtab[a].int4 + 2]);
        pdfindirectln(/* str 'P' */ 80, pdfmem[objtab[a].int4 + 1]);
        pdfindirectln(/* str 'R' */ 82, pdfmem[objtab[a].int4]);
        pdfenddict();
        a = pdfmem[objtab[a].int4 + 2];
    } while (!(a == b));
}
void doextension(void) {
    doextension_regmem integer i, j, k;
    halfword p, q, r;
    switch (curchr) {
    case OPENNODE:
        /* comment:Implement \.{\\openout} */ {

            newwritewhatsit(OPENNODESIZE);
            scanoptionalequals();
            scanfilename();
            mem[curlist.tailfield + 1].hh.v.RH = curname;
            mem[curlist.tailfield + 2].hh.v.LH = curarea;
            mem[curlist.tailfield + 2].hh.v.RH = curext;
        }
        break;
    case WRITENODE:
        /* comment:Implement \.{\\write} */ {

            k = curcs;
            newwritewhatsit(WRITENODESIZE);
            curcs = k;
            p = scantoks(false, false);
            mem[curlist.tailfield + 1].hh.v.RH = defref;
        }
        break;
    case CLOSENODE:
        /* comment:Implement \.{\\closeout} */ {

            newwritewhatsit(WRITENODESIZE);
            mem[curlist.tailfield + 1].hh.v.RH = TEXNULL;
        }
        break;
    case SPECIALNODE:
        /* comment:Implement \.{\\special} */ {

            newwhatsit(SPECIALNODE, WRITENODESIZE);
            if (eqtb[INTBASE + SPECOUTCODE].cint + 64 < 0)
                mem[curlist.tailfield + 1].hh.b0 = 0;
            else if (eqtb[INTBASE + SPECOUTCODE].cint + 64 >= 2 * 64)
                mem[curlist.tailfield + 1].hh.b0 = 2 * 64 - 1;
            else
                mem[curlist.tailfield + 1].hh.b0 =
                    eqtb[INTBASE + SPECOUTCODE].cint + 64;
            if (eqtb[INTBASE + MUBYTEOUTCODE].cint + 64 < 0)
                mem[curlist.tailfield + 1].hh.b1 = 0;
            else if (eqtb[INTBASE + MUBYTEOUTCODE].cint + 64 >= 2 * 64)
                mem[curlist.tailfield + 1].hh.b1 = 2 * 64 - 1;
            else
                mem[curlist.tailfield + 1].hh.b1 =
                    eqtb[INTBASE + MUBYTEOUTCODE].cint + 64;
            if ((eqtb[INTBASE + SPECOUTCODE].cint == 2) ||
                (eqtb[INTBASE + SPECOUTCODE].cint == 3)) {

                if ((eqtb[INTBASE + MUBYTEOUTCODE].cint > 2) ||
                    (eqtb[INTBASE + MUBYTEOUTCODE].cint == -1) ||
                    (eqtb[INTBASE + MUBYTEOUTCODE].cint == -2))
                    writenoexpanding = true;
            }
            p = scantoks(false, true);
            mem[curlist.tailfield + 1].hh.v.RH = defref;
            writenoexpanding = false;
        }
        break;
    case IMMEDIATECODE:
        /* comment:Implement \.{\\immediate} */ {

            getxtoken();
            if (curcmd == EXTENSION) {
                if (curchr <= CLOSENODE) {
                    p = curlist.tailfield;
                    doextension();
                    outwhat(curlist.tailfield);
                    flushnodelist(curlist.tailfield);
                    curlist.tailfield = p;
                    mem[p].hh.v.RH = TEXNULL;
                } else
                    switch (curchr) {
                    case PDFTEXFIRSTEXTENSIONCODE + 1: {
                        doextension();
                        if (objtab[pdflastobj].int4 == 0)
                            pdferror(/* str 'ext1' */ 1777,
                                     /* str '`\pdfobj reserveobjnum' cannot be
                                        used with \imme' */
                                     1925);
                        pdfwriteobj(pdflastobj);
                    } break;
                    case PDFTEXFIRSTEXTENSIONCODE + 3: {
                        doextension();
                        pdfcurform = pdflastxform;
                        pdfshipout(pdfmem[objtab[pdflastxform].int4 + 3],
                                   false);
                    } break;
                    case PDFTEXFIRSTEXTENSIONCODE + 5: {
                        doextension();
                        pdfwriteimage(pdflastximage);
                    } break;
                    default:
                        backinput();
                        break;
                    }
            } else
                backinput();
        }
        break;
    case SETLANGUAGECODE:
        /* comment:Implement \.{\\setlanguage} */ if (abs(curlist.modefield) !=
                                                      HMODE)
            reportillegalcase();
        else {

            newwhatsit(LANGUAGENODE, SMALLNODESIZE);
            scanint();
            if (curval <= 0)
                curlist.auxfield.hh.v.RH = 0;
            else if (curval > 255)
                curlist.auxfield.hh.v.RH = 0;
            else
                curlist.auxfield.hh.v.RH = curval;
            mem[curlist.tailfield + 1].hh.v.RH = curlist.auxfield.hh.v.RH;
            mem[curlist.tailfield + 1].hh.b0 =
                normmin(eqtb[INTBASE + LEFTHYPHENMINCODE].cint);
            mem[curlist.tailfield + 1].hh.b1 =
                normmin(eqtb[INTBASE + RIGHTHYPHENMINCODE].cint);
        }
        break;
    case PDFTEXFIRSTEXTENSIONCODE + 7:
        /* comment:Implement \.{\\pdfannot} */ {

            checkpdfoutput(/* str '\pdfannot' */ 1837, true);
            if (scankeyword(/* str 'reserveobjnum' */ 1799)) {
                pdflastannot = pdfnewobjnum();
                /* comment:Scan an optional space */ {

                    getxtoken();
                    if (curcmd != SPACER)
                        backinput();
                }
            } else {

                if (scankeyword(/* str 'useobjnum' */ 1800)) {
                    scanint();
                    k = curval;
                    if ((k <= 0) || (k > objptr) || (objtab[k].int4 != 0))
                        pdferror(/* str 'ext1' */ 1777,
                                 /* str 'invalid object number' */ 1838);
                } else
                    k = pdfnewobjnum();
                newannotwhatsit(/* @d13256@ */ 13, 7);
                mem[curlist.tailfield + 6].cint = k;
                scanpdfexttoks();
                mem[curlist.tailfield + 5].hh.v.LH = defref;
                pdflastannot = k;
            }
        }
        break;
    case PDFTEXFIRSTEXTENSIONCODE + 17:
        /* comment:Implement \.{\\pdfcatalog} */ {

            checkpdfoutput(/* str '\pdfcatalog' */ 1867, false);
            scanpdfexttoks();
            if (eqtb[INTBASE + PDFOUTPUTCODE].cint > 0)
                pdfcatalogtoks = concattokens(pdfcatalogtoks, defref);
            if (scankeyword(/* str 'openaction' */ 1868)) {
                if (pdfcatalogopenaction != 0)
                    pdferror(/* str 'ext1' */ 1777,
                             /* str 'duplicate of openaction' */ 1869);
                else {

                    p = scanaction();
                    pdfnewobj(0, 0, 1);
                    if (eqtb[INTBASE + PDFOUTPUTCODE].cint > 0)
                        pdfcatalogopenaction = objptr;
                    writeaction(p);
                    pdfendobj();
                    {
                        if (mem[p + 2].hh.v.RH == TEXNULL) {
                            if (mem[p].hh.b0 == 3)
                                deletetokenref(mem[p + 2].hh.v.LH);
                            else {

                                if (mem[p + 1].hh.v.LH != TEXNULL)
                                    deletetokenref(mem[p + 1].hh.v.LH);
                                if (mem[p].hh.b0 == 0)
                                    deletetokenref(mem[p + 2].hh.v.LH);
                                else if (mem[p].hh.b1 > 0)
                                    deletetokenref(mem[p].hh.v.RH);
                            }
                            freenode(p, 3);
                        } else
                            decr(mem[p + 2].hh.v.RH);
                    }
                }
            }
        }
        break;
    case PDFTEXFIRSTEXTENSIONCODE + 11:
        /* comment:Implement \.{\\pdfdest} */ {

            checkpdfoutput(/* str '\pdfdest' */ 1846, true);
            q = curlist.tailfield;
            newwhatsit(/* @d13270@ */ 17, 7);
            if (scankeyword(/* str 'num' */ 1198)) {
                scanint();
                if (curval <= 0)
                    pdferror(/* str 'ext1' */ 1777,
                             /* str 'num identifier must be positive' */ 1832);
                if (curval > 2147483647L)
                    pdferror(/* str 'ext1' */ 1777,
                             /* str 'number too big' */ 1028);
                mem[curlist.tailfield + 5].hh.v.RH = curval;
                mem[curlist.tailfield + 5].hh.b1 = 0;
            } else if (scankeyword(/* str 'name' */ 1830)) {
                scanpdfexttoks();
                mem[curlist.tailfield + 5].hh.v.RH = defref;
                mem[curlist.tailfield + 5].hh.b1 = 1;
            } else
                pdferror(/* str 'ext1' */ 1777,
                         /* str 'identifier type missing' */ 1833);
            if (scankeyword(/* str 'xyz' */ 1847)) {
                mem[curlist.tailfield + 5].hh.b0 = 0;
                if (scankeyword(/* str 'zoom' */ 1848)) {
                    scanint();
                    if (curval > 2147483647L)
                        pdferror(/* str 'ext1' */ 1777,
                                 /* str 'number too big' */ 1028);
                    mem[curlist.tailfield + 6].hh.v.LH = curval;
                } else
                    mem[curlist.tailfield + 6].hh.v.LH = TEXNULL;
            } else if (scankeyword(/* str 'fitbh' */ 1849))
                mem[curlist.tailfield + 5].hh.b0 = 5;
            else if (scankeyword(/* str 'fitbv' */ 1850))
                mem[curlist.tailfield + 5].hh.b0 = 6;
            else if (scankeyword(/* str 'fitb' */ 1851))
                mem[curlist.tailfield + 5].hh.b0 = 4;
            else if (scankeyword(/* str 'fith' */ 1852))
                mem[curlist.tailfield + 5].hh.b0 = 2;
            else if (scankeyword(/* str 'fitv' */ 1853))
                mem[curlist.tailfield + 5].hh.b0 = 3;
            else if (scankeyword(/* str 'fitr' */ 1854))
                mem[curlist.tailfield + 5].hh.b0 = 7;
            else if (scankeyword(/* str 'fit' */ 1855))
                mem[curlist.tailfield + 5].hh.b0 = 1;
            else
                pdferror(/* str 'ext1' */ 1777,
                         /* str 'destination type missing' */ 1856);
            /* comment:Scan an optional space */ {

                getxtoken();
                if (curcmd != SPACER)
                    backinput();
            }
            if (mem[curlist.tailfield + 5].hh.b0 == 7) {
                scanaltrule();
                mem[curlist.tailfield + 1].cint =
                    mem[altrule + WIDTHOFFSET].cint;
                mem[curlist.tailfield + 2].cint =
                    mem[altrule + HEIGHTOFFSET].cint;
                mem[curlist.tailfield + 3].cint =
                    mem[altrule + DEPTHOFFSET].cint;
            }
            if (mem[curlist.tailfield + 5].hh.b1 != 0) {
                i = tokenstostring(mem[curlist.tailfield + 5].hh.v.RH);
                k = findobj(5, i, true);
                flushstr(i);
            } else
                k = findobj(5, mem[curlist.tailfield + 5].hh.v.RH, false);
            if ((k != 0) && (objtab[k].int4 != TEXNULL)) {
                warndestdup(
                    mem[curlist.tailfield + 5].hh.v.RH,
                    mem[curlist.tailfield + 5].hh.b1, /* str 'ext4' */ 1857,
                    /* str 'has been already used, duplicate ignored' */ 1858);
                flushnodelist(curlist.tailfield);
                curlist.tailfield = q;
                mem[q].hh.v.RH = TEXNULL;
            }
        }
        break;
    case PDFTEXFIRSTEXTENSIONCODE + 9:
        /* comment:Implement \.{\\pdfendlink} */ {

            checkpdfoutput(/* str '\pdfendlink' */ 1841, true);
            if (abs(curlist.modefield) == VMODE)
                pdferror(/* str 'ext1' */ 1777,
                         /* str '\pdfendlink cannot be used in vertical mode' */
                         1842);
            newwhatsit(/* @d13305@ */ 15, SMALLNODESIZE);
        }
        break;
    case PDFTEXFIRSTEXTENSIONCODE + 14:
        /* comment:Implement \.{\\pdfendthread} */ {

            checkpdfoutput(/* str '\pdfendthread' */ 1861, true);
            newwhatsit(/* @d13310@ */ 20, SMALLNODESIZE);
        }
        break;
    case PDFTEXFIRSTEXTENSIONCODE + 19:
        /* comment:Implement \.{\\pdffontattr} */ {

            checkpdfoutput(/* str '\pdffontattr' */ 1203, true);
            scanfontident();
            k = curval;
            if (k == FONTBASE)
                pdferror(/* str 'font' */ 595,
                         /* str 'invalid font identifier' */ 873);
            scanpdfexttoks();
            pdffontattr[k] = tokenstostring(defref);
        }
        break;
    case PDFTEXFIRSTEXTENSIONCODE + 26:
        /* comment:Implement \.{\\pdffontexpand} */ readexpandfont();
        break;
    case PDFTEXFIRSTEXTENSIONCODE + 20:
        /* comment:Implement \.{\\pdfincludechars} */ {

            checkpdfoutput(/* str '\pdfincludechars' */ 1873, true);
            pdfincludechars();
        }
        break;
    case PDFTEXFIRSTEXTENSIONCODE + 16:
        /* comment:Implement \.{\\pdfinfo} */ {

            checkpdfoutput(/* str '\pdfinfo' */ 1866, false);
            scanpdfexttoks();
            if (eqtb[INTBASE + PDFOUTPUTCODE].cint > 0)
                pdfinfotoks = concattokens(pdfinfotoks, defref);
        }
        break;
    case PDFTEXFIRSTEXTENSIONCODE:
        /* comment:Implement \.{\\pdfliteral} */ {

            checkpdfoutput(/* str '\pdfliteral' */ 1780, true);
            newwhatsit(PDFTEXFIRSTEXTENSIONCODE, WRITENODESIZE);
            if (scankeyword(/* str 'direct' */ 890))
                mem[curlist.tailfield + 1].hh.v.LH = 2;
            else if (scankeyword(/* str 'page' */ 889))
                mem[curlist.tailfield + 1].hh.v.LH = 1;
            else
                mem[curlist.tailfield + 1].hh.v.LH = 0;
            scanpdfexttoks();
            mem[curlist.tailfield + 1].hh.v.RH = defref;
        }
        break;
    case PDFTEXFIRSTEXTENSIONCODE + 32:
        /* comment:Implement \.{\\pdfcolorstack} */ {

            checkpdfoutput(/* str '\pdfcolorstack' */ 1781, true);
            scanint();
            if (curval >= colorstackused()) {
                {
                    if (interaction == ERRORSTOPMODE)
                        ;
                    if (filelineerrorstylep)
                        printfileline();
                    else
                        printnl(/* str '! ' */ 264);
                    print(/* str 'Unknown color stack number ' */ 1782);
                }
                printint(curval);
                {
                    helpptr = 3;
                    helpline[2] = /* str 'Allocate and initialize a color stack
                                     with \\pdfc' */
                        1783;
                    helpline[1] =
                        /* str 'I'll use default color stack 0 here.' */ 1784;
                    helpline[0] =
                        /* str 'Proceed, with fingers crossed.' */ 1785;
                }
                error();
                curval = 0;
            }
            if (curval < 0) {
                {
                    if (interaction == ERRORSTOPMODE)
                        ;
                    if (filelineerrorstylep)
                        printfileline();
                    else
                        printnl(/* str '! ' */ 264);
                    print(/* str 'Invalid negative color stack number' */ 1786);
                }
                {
                    helpptr = 2;
                    helpline[1] =
                        /* str 'I'll use default color stack 0 here.' */ 1784;
                    helpline[0] =
                        /* str 'Proceed, with fingers corssed.' */ 1787;
                }
                error();
                curval = 0;
            }
            if (scankeyword(/* str 'set' */ 1788)) {
                i = 0;
                j = 3;
            } else if (scankeyword(/* str 'push' */ 1789)) {
                i = 1;
                j = 3;
            } else if (scankeyword(/* str 'pop' */ 1790)) {
                i = 2;
                j = 2;
            } else if (scankeyword(/* str 'current' */ 1791)) {
                i = 3;
                j = 2;
            } else {

                i = -1;
            }
            if (i >= 0) {
                newwhatsit(/* @d13353@ */ 38, j);
                mem[curlist.tailfield + 1].hh.v.RH = curval;
                mem[curlist.tailfield + 1].hh.v.LH = i;
                if (i <= 1) {
                    scanpdfexttoks();
                    mem[curlist.tailfield + 2].hh.v.RH = defref;
                }
            } else {

                {
                    if (interaction == ERRORSTOPMODE)
                        ;
                    if (filelineerrorstylep)
                        printfileline();
                    else
                        printnl(/* str '! ' */ 264);
                    print(/* str 'Color stack action is missing' */ 1792);
                }
                {
                    helpptr = 3;
                    helpline[2] =
                        /* str 'The expected actions for \pdfcolorstack' */
                        1793;
                    helpline[1] = /* str '    set, push, pop, current' */ 1794;
                    helpline[0] =
                        /* str 'I'll ignore the color stack command.' */ 1795;
                }
                error();
            }
        }
        break;
    case PDFTEXFIRSTEXTENSIONCODE + 33:
        /* comment:Implement \.{\\pdfsetmatrix} */ {

            checkpdfoutput(/* str '\pdfsetmatrix' */ 1137, true);
            newwhatsit(/* @d13363@ */ 39, 2);
            scanpdfexttoks();
            mem[curlist.tailfield + 1].hh.v.RH = defref;
        }
        break;
    case PDFTEXFIRSTEXTENSIONCODE + 34:
        /* comment:Implement \.{\\pdfsave} */ {

            checkpdfoutput(/* str '\pdfsave' */ 1796, true);
            newwhatsit(/* @d13367@ */ 40, 2);
        }
        break;
    case PDFTEXFIRSTEXTENSIONCODE + 35:
        /* comment:Implement \.{\\pdfrestore} */ {

            checkpdfoutput(/* str '\pdfrestore' */ 1797, true);
            newwhatsit(/* @d13371@ */ 41, 2);
        }
        break;
    case PDFTEXFIRSTEXTENSIONCODE + 21:
        /* comment:Implement \.{\\pdfmapfile} */ {

            checkpdfoutput(/* str '\pdfmapfile' */ 1874, true);
            scanpdfexttoks();
            pdfmapfile(defref);
            deletetokenref(defref);
        }
        break;
    case PDFTEXFIRSTEXTENSIONCODE + 22:
        /* comment:Implement \.{\\pdfmapline} */ {

            checkpdfoutput(/* str '\pdfmapline' */ 1875, true);
            scanpdfexttoks();
            pdfmapline(defref);
            deletetokenref(defref);
        }
        break;
    case PDFTEXFIRSTEXTENSIONCODE + 18:
        /* comment:Implement \.{\\pdfnames} */ {

            checkpdfoutput(/* str '\pdfnames' */ 1870, true);
            scanpdfexttoks();
            pdfnamestoks = concattokens(pdfnamestoks, defref);
        }
        break;
    case PDFTEXFIRSTEXTENSIONCODE + 1:
        /* comment:Implement \.{\\pdfobj} */ {

            checkpdfoutput(/* str '\pdfobj' */ 1798, true);
            if (scankeyword(/* str 'reserveobjnum' */ 1799)) {
                /* comment:Scan an optional space */ {

                    getxtoken();
                    if (curcmd != SPACER)
                        backinput();
                }
                incr(pdfobjcount);
                pdfcreateobj(6, pdfobjcount);
                pdflastobj = objptr;
            } else {

                k = -1;
                if (scankeyword(/* str 'useobjnum' */ 1800)) {
                    scanint();
                    k = curval;
                    if ((k <= 0) || (k > objptr) || (objtab[k].int4 != 0)) {
                        pdfwarning(
                            /* str '\pdfobj' */ 1798,
                            /* str 'invalid object number being ignored' */
                            1801, true, true);
                        pdfretval = -1;
                        k = -1;
                    }
                }
                if (k < 0) {
                    incr(pdfobjcount);
                    pdfcreateobj(6, pdfobjcount);
                    k = objptr;
                }
                objtab[k].int4 = pdfgetmem(4);
                if (scankeyword(/* str 'stream' */ 1019)) {
                    pdfmem[objtab[k].int4 + 1] = 1;
                    if (scankeyword(/* str 'attr' */ 1802)) {
                        scanpdfexttoks();
                        pdfmem[objtab[k].int4 + 2] = defref;
                    } else
                        pdfmem[objtab[k].int4 + 2] = TEXNULL;
                } else
                    pdfmem[objtab[k].int4 + 1] = 0;
                if (scankeyword(/* str 'file' */ 878))
                    pdfmem[objtab[k].int4 + 3] = 1;
                else
                    pdfmem[objtab[k].int4 + 3] = 0;
                scanpdfexttoks();
                pdfmem[objtab[k].int4 + 0] = defref;
                pdflastobj = k;
            }
        }
        break;
    case PDFTEXFIRSTEXTENSIONCODE + 10:
        /* comment:Implement \.{\\pdfoutline} */ {

            checkpdfoutput(/* str '\pdfoutline' */ 1843, true);
            if (scankeyword(/* str 'attr' */ 1802)) {
                scanpdfexttoks();
                r = defref;
            } else
                r = 0;
            p = scanaction();
            if (scankeyword(/* str 'count' */ 537)) {
                scanint();
                i = curval;
            } else
                i = 0;
            scanpdfexttoks();
            q = defref;
            pdfnewobj(0, 0, 1);
            j = objptr;
            writeaction(p);
            pdfendobj();
            {
                if (mem[p + 2].hh.v.RH == TEXNULL) {
                    if (mem[p].hh.b0 == 3)
                        deletetokenref(mem[p + 2].hh.v.LH);
                    else {

                        if (mem[p + 1].hh.v.LH != TEXNULL)
                            deletetokenref(mem[p + 1].hh.v.LH);
                        if (mem[p].hh.b0 == 0)
                            deletetokenref(mem[p + 2].hh.v.LH);
                        else if (mem[p].hh.b1 > 0)
                            deletetokenref(mem[p].hh.v.RH);
                    }
                    freenode(p, 3);
                } else
                    decr(mem[p + 2].hh.v.RH);
            }
            pdfcreateobj(4, 0);
            k = objptr;
            objtab[k].int4 = pdfgetmem(8);
            pdfmem[objtab[k].int4 + 6] = j;
            objtab[k].int0 = i;
            pdfnewobj(0, 0, 1);
            pdfprintstrln(tokenstostring(q));
            flushstr(lasttokensstring);
            deletetokenref(q);
            pdfendobj();
            pdfmem[objtab[k].int4] = objptr;
            pdfmem[objtab[k].int4 + 2] = 0;
            pdfmem[objtab[k].int4 + 3] = 0;
            pdfmem[objtab[k].int4 + 4] = 0;
            pdfmem[objtab[k].int4 + 5] = 0;
            pdfmem[objtab[k].int4 + 1] = pdfparentoutline;
            pdfmem[objtab[k].int4 + 7] = r;
            if (pdffirstoutline == 0)
                pdffirstoutline = k;
            if (pdflastoutline == 0) {
                if (pdfparentoutline != 0)
                    pdfmem[objtab[pdfparentoutline].int4 + 4] = k;
            } else {

                pdfmem[objtab[pdflastoutline].int4 + 3] = k;
                pdfmem[objtab[k].int4 + 2] = pdflastoutline;
            }
            pdflastoutline = k;
            if (objtab[k].int0 != 0) {
                pdfparentoutline = k;
                pdflastoutline = 0;
            } else if ((pdfparentoutline != 0) &&
                       (outlinelistcount(k) ==
                        abs(objtab[pdfparentoutline].int0))) {
                j = pdflastoutline;
                do {
                    pdfmem[objtab[pdfparentoutline].int4 + 5] = j;
                    j = pdfparentoutline;
                    pdfparentoutline =
                        pdfmem[objtab[pdfparentoutline].int4 + 1];
                } while (!((pdfparentoutline == 0) ||
                           (outlinelistcount(j) <
                            abs(objtab[pdfparentoutline].int0))));
                if (pdfparentoutline == 0)
                    pdflastoutline = pdffirstoutline;
                else
                    pdflastoutline = pdfmem[objtab[pdfparentoutline].int4 + 4];
                while (pdfmem[objtab[pdflastoutline].int4 + 3] != 0)
                    pdflastoutline = pdfmem[objtab[pdflastoutline].int4 + 3];
            }
        }
        break;
    case PDFTEXFIRSTEXTENSIONCODE + 2:
        /* comment:Implement \.{\\pdfrefobj} */ {

            checkpdfoutput(/* str '\pdfrefobj' */ 1804, true);
            scanint();
            pdfcheckobj(6, curval);
            newwhatsit(/* @d13401@ */ 8, 2);
            mem[curlist.tailfield + 1].hh.v.LH = curval;
        }
        break;
    case PDFTEXFIRSTEXTENSIONCODE + 4:
        /* comment:Implement \.{\\pdfrefxform} */ {

            checkpdfoutput(/* str '\pdfrefxform' */ 1808, true);
            scanint();
            pdfcheckobj(7, curval);
            newwhatsit(/* @d13405@ */ 10, 5);
            mem[curlist.tailfield + 4].hh.v.LH = curval;
            mem[curlist.tailfield + 1].cint = pdfmem[objtab[curval].int4 + 0];
            mem[curlist.tailfield + 2].cint = pdfmem[objtab[curval].int4 + 1];
            mem[curlist.tailfield + 3].cint = pdfmem[objtab[curval].int4 + 2];
        }
        break;
    case PDFTEXFIRSTEXTENSIONCODE + 6:
        /* comment:Implement \.{\\pdfrefximage} */ {

            checkpdfoutput(/* str '\pdfrefximage' */ 1823, true);
            scanint();
            pdfcheckobj(8, curval);
            newwhatsit(/* @d13409@ */ 12, 5);
            mem[curlist.tailfield + 4].hh.v.LH = curval;
            mem[curlist.tailfield + 1].cint = pdfmem[objtab[curval].int4 + 0];
            mem[curlist.tailfield + 2].cint = pdfmem[objtab[curval].int4 + 1];
            mem[curlist.tailfield + 3].cint = pdfmem[objtab[curval].int4 + 2];
        }
        break;
    case PDFTEXFIRSTEXTENSIONCODE + 15:
        /* comment:Implement \.{\\pdfsavepos} */ {
            newwhatsit(/* @d13412@ */ 21, SMALLNODESIZE);
        }
        break;
    case PDFTEXFIRSTEXTENSIONCODE + 28:
        /* comment:Implement \.{\\pdfsnaprefpoint} */ {

            checkpdfoutput(/* str '\pdfsnaprefpoint' */ 1862, true);
            newwhatsit(/* @d13417@ */ 34, SMALLNODESIZE);
        }
        break;
    case PDFTEXFIRSTEXTENSIONCODE + 30:
        /* comment:Implement \.{\\pdfsnapycomp} */ {

            checkpdfoutput(/* str '\pdfsnapycomp' */ 1865, true);
            newwhatsit(/* @d13422@ */ 36, SMALLNODESIZE);
            scanint();
            mem[curlist.tailfield + 1].cint = fixint(curval, 0, 1000);
        }
        break;
    case PDFTEXFIRSTEXTENSIONCODE + 29:
        /* comment:Implement \.{\\pdfsnapy} */ {

            checkpdfoutput(/* str '\pdfsnapy' */ 1864, true);
            {
                mem[curlist.tailfield].hh.v.RH = newsnapnode(/* @d13427@ */ 35);
                curlist.tailfield = mem[curlist.tailfield].hh.v.RH;
            }
        }
        break;
    case PDFTEXFIRSTEXTENSIONCODE + 8:
        /* comment:Implement \.{\\pdfstartlink} */ {

            checkpdfoutput(/* str '\pdfstartlink' */ 1839, true);
            if (abs(curlist.modefield) == VMODE)
                pdferror(
                    /* str 'ext1' */ 1777,
                    /* str '\pdfstartlink cannot be used in vertical mode' */
                    1840);
            k = pdfnewobjnum();
            newannotwhatsit(/* @d13434@ */ 14, 7);
            mem[curlist.tailfield + 5].hh.v.RH = scanaction();
            mem[curlist.tailfield + 6].cint = k;
            pdflastlink = k;
        }
        break;
    case PDFTEXFIRSTEXTENSIONCODE + 13:
        /* comment:Implement \.{\\pdfstartthread} */ {

            checkpdfoutput(/* str '\pdfstartthread' */ 1860, true);
            newannotwhatsit(/* @d13438@ */ 19, 7);
            scanthreadid();
        }
        break;
    case PDFTEXFIRSTEXTENSIONCODE + 12:
        /* comment:Implement \.{\\pdfthread} */ {

            checkpdfoutput(/* str '\pdfthread' */ 1859, true);
            newannotwhatsit(/* @d13442@ */ 18, 7);
            scanthreadid();
        }
        break;
    case PDFTEXFIRSTEXTENSIONCODE + 23:
        /* comment:Implement \.{\\pdftrailer} */ {

            checkpdfoutput(/* str '\pdftrailer' */ 1871, false);
            scanpdfexttoks();
            if (eqtb[INTBASE + PDFOUTPUTCODE].cint > 0)
                pdftrailertoks = concattokens(pdftrailertoks, defref);
        }
        break;
    case PDFTEXFIRSTEXTENSIONCODE + 24:
        /* comment:Implement \.{\\pdftrailerid} */ {

            checkpdfoutput(/* str '\pdftrailerid' */ 1872, false);
            scanpdfexttoks();
            if (eqtb[INTBASE + PDFOUTPUTCODE].cint > 0)
                pdftraileridtoks = concattokens(pdftraileridtoks, defref);
        }
        break;
    case PDFTEXFIRSTEXTENSIONCODE + 3:
        /* comment:Implement \.{\\pdfxform} */ {

            checkpdfoutput(/* str '\pdfxform' */ 1805, true);
            incr(pdfxformcount);
            pdfcreateobj(7, pdfxformcount);
            k = objptr;
            objtab[k].int4 = pdfgetmem(6);
            if (scankeyword(/* str 'attr' */ 1802)) {
                scanpdfexttoks();
                pdfmem[objtab[k].int4 + 4] = defref;
            } else
                pdfmem[objtab[k].int4 + 4] = TEXNULL;
            if (scankeyword(/* str 'resources' */ 1806)) {
                scanpdfexttoks();
                pdfmem[objtab[k].int4 + 5] = defref;
            } else
                pdfmem[objtab[k].int4 + 5] = TEXNULL;
            scanregisternum();
            if (curval < 256)
                p = eqtb[BOXBASE + curval].hh.v.RH;
            else {

                findsaelement(4, curval, false);
                if (curptr == TEXNULL)
                    p = TEXNULL;
                else
                    p = mem[curptr + 1].hh.v.RH;
            }
            if (p == TEXNULL)
                pdferror(
                    /* str 'ext1' */ 1777,
                    /* str '\pdfxform cannot be used with a void box' */ 1807);
            pdfmem[objtab[k].int4 + 0] = mem[p + WIDTHOFFSET].cint;
            pdfmem[objtab[k].int4 + 1] = mem[p + HEIGHTOFFSET].cint;
            pdfmem[objtab[k].int4 + 2] = mem[p + DEPTHOFFSET].cint;
            pdfmem[objtab[k].int4 + 3] = p;
            if (curval < 256)
                eqtb[BOXBASE + curval].hh.v.RH = TEXNULL;
            else {

                findsaelement(4, curval, false);
                if (curptr != TEXNULL) {
                    mem[curptr + 1].hh.v.RH = TEXNULL;
                    incr(mem[curptr + 1].hh.v.LH);
                    deletesaref(curptr);
                }
            }
            pdflastxform = k;
        }
        break;
    case PDFTEXFIRSTEXTENSIONCODE + 5:
        /* comment:Implement \.{\\pdfximage} */ {

            checkpdfoutput(/* str '\pdfximage' */ 1822, true);
            checkpdfminorversion();
            scanimage();
        }
        break;
    case PDFTEXFIRSTEXTENSIONCODE + 25:
        /* comment:Implement \.{\\pdfresettimer} */ {
            secondsandmicros(epochseconds, microseconds);
        }
        break;
    case PDFTEXFIRSTEXTENSIONCODE + 27:
        /* comment:Implement \.{\\pdfsetrandomseed} */ {

            scanint();
            if (curval < 0)
                curval = -(integer)curval;
            randomseed = curval;
            initrandoms(randomseed);
        }
        break;
    case PDFTEXFIRSTEXTENSIONCODE + 31:
        /* comment:Implement \.{\\pdfglyphtounicode} */ { glyphtounicode(); }
        break;
    case PDFTEXFIRSTEXTENSIONCODE + 36:
        /* comment:Implement \.{\\pdfnobuiltintounicode} */ {

            checkpdfoutput(/* str '\pdfnobuiltintounicode' */ 1876, true);
            scanfontident();
            k = curval;
            if (k == FONTBASE)
                pdferror(/* str 'font' */ 595,
                         /* str 'invalid font identifier' */ 873);
            pdffontnobuiltintounicode[k] = true;
        }
        break;
    case PDFTEXFIRSTEXTENSIONCODE + 37:
        /* comment:Implement \.{\\pdfinterwordspaceon} */ {

            checkpdfoutput(/* str '\pdfinterwordspaceon' */ 1877, true);
            newwhatsit(/* @d13483@ */ 43, SMALLNODESIZE);
        }
        break;
    case PDFTEXFIRSTEXTENSIONCODE + 38:
        /* comment:Implement \.{\\pdfinterwordspaceoff} */ {

            checkpdfoutput(/* str '\pdfinterwordspaceoff' */ 1878, true);
            newwhatsit(/* @d13488@ */ 44, SMALLNODESIZE);
        }
        break;
    case PDFTEXFIRSTEXTENSIONCODE + 39:
        /* comment:Implement \.{\\pdffakespace} */ {

            checkpdfoutput(/* str '\pdffakespace' */ 1879, true);
            newwhatsit(/* @d13493@ */ 45, SMALLNODESIZE);
        }
        break;
    default:
        confusion(/* str 'ext1' */ 1777);
        break;
    }
}
void fixlanguage(void) {
    fixlanguage_regmem ASCIIcode l;
    if (eqtb[INTBASE + LANGUAGECODE].cint <= 0)
        l = 0;
    else if (eqtb[INTBASE + LANGUAGECODE].cint > 255)
        l = 0;
    else
        l = eqtb[INTBASE + LANGUAGECODE].cint;
    if (l != curlist.auxfield.hh.v.RH) {
        newwhatsit(LANGUAGENODE, SMALLNODESIZE);
        mem[curlist.tailfield + 1].hh.v.RH = l;
        curlist.auxfield.hh.v.RH = l;
        mem[curlist.tailfield + 1].hh.b0 =
            normmin(eqtb[INTBASE + LEFTHYPHENMINCODE].cint);
        mem[curlist.tailfield + 1].hh.b1 =
            normmin(eqtb[INTBASE + RIGHTHYPHENMINCODE].cint);
    }
}
void insertsrcspecial(void) {
    insertsrcspecial_regmem halfword toklist, p, q;
    if ((sourcefilenamestack[inopen] > 0 &&
         isnewsource(sourcefilenamestack[inopen], line))) {
        toklist = getavail();
        p = toklist;
        mem[p].hh.v.LH = /* @d13508@ */ 19619;
        mem[p].hh.v.RH = getavail();
        p = mem[p].hh.v.RH;
        mem[p].hh.v.LH = /* @d13509@ */ /* str '{' */ 379;
        q = strtoks(makesrcspecial(sourcefilenamestack[inopen], line));
        mem[p].hh.v.RH = mem[memtop - 3].hh.v.RH;
        p = q;
        mem[p].hh.v.RH = getavail();
        p = mem[p].hh.v.RH;
        mem[p].hh.v.LH = /* @d13511@ */ /* str '}' */ 637;
        begintokenlist(toklist, INSERTED);
        remembersourceinfo(sourcefilenamestack[inopen], line);
    }
}
void appendsrcspecial(void) {
    appendsrcspecial_regmem halfword q;
    if ((sourcefilenamestack[inopen] > 0 &&
         isnewsource(sourcefilenamestack[inopen], line))) {
        newwhatsit(SPECIALNODE, WRITENODESIZE);
        mem[curlist.tailfield + 1].hh.b0 = 0;
        defref = getavail();
        mem[defref].hh.v.LH = TEXNULL;
        q = strtoks(makesrcspecial(sourcefilenamestack[inopen], line));
        mem[defref].hh.v.RH = mem[memtop - 3].hh.v.RH;
        mem[curlist.tailfield + 1].hh.v.RH = defref;
        remembersourceinfo(sourcefilenamestack[inopen], line);
    }
}
/* comment:Declare the procedure called |handle_right_brace| */ void
handlerightbrace(void) {
    handlerightbrace_regmem halfword p, q;
    scaled d;
    integer f;
    switch (curgroup) {
    case SIMPLEGROUP:
        unsave();
        break;
    case BOTTOMLEVEL: {
        {
            if (interaction == ERRORSTOPMODE)
                ;
            if (filelineerrorstylep)
                printfileline();
            else
                printnl(/* str '! ' */ 264);
            print(/* str 'Too many }'s' */ 1457);
        }
        {
            helpptr = 2;
            helpline[1] =
                /* str 'You've closed more groups than you opened.' */ 1458;
            helpline[0] =
                /* str 'Such booboos are generally harmless, so keep goin' */
                1459;
        }
        error();
    } break;
    case SEMISIMPLEGROUP:
    case MATHSHIFTGROUP:
    case MATHLEFTGROUP:
        extrarightbrace();
        break;
    /* comment:Cases of |handle_right_brace| where a |right_brace */
    case HBOXGROUP:
        package(0);
        break;
    case ADJUSTEDHBOXGROUP: {
        adjusttail = memtop - 5;
        preadjusttail = memtop - 14;
        package(0);
    } break;
    case VBOXGROUP: {
        endgraf();
        package(0);
    } break;
    case VTOPGROUP: {
        endgraf();
        package(VTOPCODE);
    } break;
    case INSERTGROUP: {
        endgraf();
        q = eqtb[GLUEBASE + SPLITTOPSKIPCODE].hh.v.RH;
        incr(mem[q].hh.v.RH);
        d = eqtb[DIMENBASE + SPLITMAXDEPTHCODE].cint;
        f = eqtb[INTBASE + FLOATINGPENALTYCODE].cint;
        unsave();
        saveptr = saveptr - 2;
        p = vpackage(mem[curlist.headfield].hh.v.RH, 0, ADDITIONAL,
                     1073741823L);
        popnest();
        if (savestack[saveptr + 0].cint < 255) {
            {
                mem[curlist.tailfield].hh.v.RH = getnode(INSNODESIZE);
                curlist.tailfield = mem[curlist.tailfield].hh.v.RH;
            }
            mem[curlist.tailfield].hh.b0 = INSNODE;
            mem[curlist.tailfield].hh.b1 = savestack[saveptr + 0].cint;
            mem[curlist.tailfield /* @d13543@ */ + 3].cint =
                mem[p + HEIGHTOFFSET].cint + mem[p + DEPTHOFFSET].cint;
            mem[curlist.tailfield + 4].hh.v.LH = mem[p + LISTOFFSET].hh.v.RH;
            mem[curlist.tailfield + 4].hh.v.RH = q;
            mem[curlist.tailfield /* @d13547@ */ + 2].cint = d;
            mem[curlist.tailfield + 1].cint = f;
        } else {

            {
                mem[curlist.tailfield].hh.v.RH = getnode(SMALLNODESIZE);
                curlist.tailfield = mem[curlist.tailfield].hh.v.RH;
            }
            mem[curlist.tailfield].hh.b0 = ADJUSTNODE;
            mem[curlist.tailfield].hh.b1 = savestack[saveptr + 1].cint;
            mem[curlist.tailfield + 1].cint = mem[p + LISTOFFSET].hh.v.RH;
            deleteglueref(q);
        }
        freenode(p, BOXNODESIZE);
        if (nestptr == 0)
            buildpage();
    } break;
    case OUTPUTGROUP:
        /* comment:Resume the page builder after an output routine ha */ {

            if ((curinput.locfield != TEXNULL) ||
                ((curinput.indexfield != OUTPUTTEXT) &&
                 (curinput.indexfield !=
                  BACKEDUP))) /* comment:Recover from an unbalanced
                                         output routine */
            {
                {
                    if (interaction == ERRORSTOPMODE)
                        ;
                    if (filelineerrorstylep)
                        printfileline();
                    else
                        printnl(/* str '! ' */ 264);
                    print(/* str 'Unbalanced output routine' */ 1425);
                }
                {
                    helpptr = 2;
                    helpline[1] = /* str 'Your sneaky output routine has
                                     problematic {'s an' */
                        1426;
                    helpline[0] =
                        /* str 'I can't handle that very well; good luck.' */
                        1427;
                }
                error();
                do {
                    gettoken();
                } while (!(curinput.locfield == TEXNULL));
            }
            endtokenlist();
            endgraf();
            unsave();
            outputactive = false;
            insertpenalties = 0;
            /* comment:Ensure that box 255 is empty after output */
            if (eqtb[/* @d13563@ */ 27688].hh.v.RH != TEXNULL) {
                {
                    if (interaction == ERRORSTOPMODE)
                        ;
                    if (filelineerrorstylep)
                        printfileline();
                    else
                        printnl(/* str '! ' */ 264);
                    print(/* str 'Output routine didn't use all of ' */ 1428);
                }
                printesc(/* str 'box' */ 429);
                printint(255);
                {
                    helpptr = 3;
                    helpline[2] =
                        /* str 'Your \output commands should empty \box255,' */
                        1429;
                    helpline[1] =
                        /* str 'e.g., by saying `\shipout\box255'.' */ 1430;
                    helpline[0] =
                        /* str 'Proceed; I'll discard its present contents.' */
                        1431;
                }
                boxerror(255);
            }
            if (curlist.tailfield != curlist.headfield) {
                mem[pagetail].hh.v.RH = mem[curlist.headfield].hh.v.RH;
                pagetail = curlist.tailfield;
            }
            if (mem[memtop - 2].hh.v.RH != TEXNULL) {
                if (mem[memtop - 1].hh.v.RH == TEXNULL)
                    nest[0].tailfield = pagetail;
                mem[pagetail].hh.v.RH = mem[memtop - 1].hh.v.RH;
                mem[memtop - 1].hh.v.RH = mem[memtop - 2].hh.v.RH;
                mem[memtop - 2].hh.v.RH = TEXNULL;
                pagetail = memtop - 2;
            }
            flushnodelist(discptr[LASTBOXCODE]);
            discptr[LASTBOXCODE] = TEXNULL;
            popnest();
            buildpage();
        }
        break;
    case DISCGROUP:
        builddiscretionary();
        break;
    case ALIGNGROUP: {
        backinput();
        curtok = /* @d13575@ */ 19610;
        {
            if (interaction == ERRORSTOPMODE)
                ;
            if (filelineerrorstylep)
                printfileline();
            else
                printnl(/* str '! ' */ 264);
            print(/* str 'Missing ' */ 712);
        }
        printesc(/* str 'cr' */ 1309);
        print(/* str ' inserted' */ 713);
        {
            helpptr = 1;
            helpline[0] =
                /* str 'I'm guessing that you meant to end an alignment h' */
                1541;
        }
        inserror();
    } break;
    case NOALIGNGROUP: {
        endgraf();
        unsave();
        alignpeek();
    } break;
    case VCENTERGROUP: {
        endgraf();
        unsave();
        saveptr = saveptr - 2;
        p = vpackage(mem[curlist.headfield].hh.v.RH,
                     savestack[saveptr + 1].cint, savestack[saveptr + 0].cint,
                     1073741823L);
        popnest();
        {
            mem[curlist.tailfield].hh.v.RH = newnoad();
            curlist.tailfield = mem[curlist.tailfield].hh.v.RH;
        }
        mem[curlist.tailfield].hh.b0 = VCENTERNOAD;
        mem[curlist.tailfield + 1].hh.v.RH = SUBBOX;
        mem[curlist.tailfield + 1].hh.v.LH = p;
    } break;
    case MATHCHOICEGROUP:
        buildchoices();
        break;
    case MATHGROUP: {
        unsave();
        decr(saveptr);
        mem[savestack[saveptr + 0].cint].hh.v.RH = SUBMLIST;
        p = finmlist(TEXNULL);
        mem[savestack[saveptr + 0].cint].hh.v.LH = p;
        if (p != TEXNULL)
            mem[savestack[saveptr + 0].cint].hh.me = mem[p].hh.me;
        if (p != TEXNULL) {

            if (mem[p].hh.v.RH == TEXNULL) {

                if (mem[p].hh.b0 == ORDNOAD) {
                    if (mem[p + 3].hh.v.RH == EMPTY) {

                        if (mem[p + 2].hh.v.RH == EMPTY) {
                            mem[savestack[saveptr + 0].cint].hh = mem[p + 1].hh;
                            freenode(p, NOADSIZE);
                        }
                    }
                } else if (mem[p].hh.b0 == ACCENTNOAD) {

                    if (savestack[saveptr + 0].cint == curlist.tailfield + 1) {

                        if (mem[curlist.tailfield].hh.b0 ==
                            ORDNOAD) /* comment:Replace the tail of
                                                  the list by |p| */
                        {
                            q = curlist.headfield;
                            while (mem[q].hh.v.RH != curlist.tailfield)
                                q = mem[q].hh.v.RH;
                            mem[q].hh.v.RH = p;
                            freenode(curlist.tailfield, NOADSIZE);
                            curlist.tailfield = p;
                        }
                    }
                }
            }
        }
    } break;
    default:
        confusion(/* str 'rightbrace' */ 1460);
        break;
    }
}
void maincontrol(void) {
   
    maincontrol_regmem integer t;
    halfword tmpk1, tmpk2;
    if (eqtb[EVERYJOBLOC].hh.v.RH != TEXNULL)
        begintokenlist(eqtb[EVERYJOBLOC].hh.v.RH, EVERYJOBTEXT);
    eqtb[INTBASE + PDFCOMPRESSLEVELCODE].cint = 0;
labmaincontrol60big_switch:
    getxtoken();
labmaincontrol21reswitch
    : /* comment:Give diagnostic information, if requested */
    if (interrupt != 0) {

        if (OKtointerrupt) {
            backinput();
            {
                if (interrupt != 0)
                    pauseforinstructions();
            }
            goto labmaincontrol60big_switch;
        }
    };
#ifdef TEXMF_DEBUG
    if (panicking)
        checkmem(false);
#endif /* TEXMF_DEBUG */
    if (eqtb[INTBASE + TRACINGCOMMANDSCODE].cint > 0)
        showcurcmdchr();
    switch (abs(curlist.modefield) + curcmd) {
    case HMODE + LETTER:
    case HMODE + OTHERCHAR:
    case HMODE + CHARGIVEN:
        goto labmaincontrol70main_loop;
        break;
    case HMODE + CHARNUM: {
        scancharnum();
        curchr = curval;
        goto labmaincontrol70main_loop;
    } break;
    case HMODE + NOBOUNDARY: {
        getxtoken();
        if ((curcmd == LETTER) || (curcmd == OTHERCHAR) ||
            (curcmd == CHARGIVEN) || (curcmd == CHARNUM))
            cancelboundary = true;
        goto labmaincontrol21reswitch;
    } break;
    case HMODE + SPACER:
        if ((curlist.auxfield.hh.v.LH == 1000) ||
            (eqtb[INTBASE + PDFADJUSTINTERWORDGLUECODE].cint > 0))
            goto labmaincontrol120append_normal_space;
        else
            appspace();
        break;
    case HMODE + EXSPACE:
    case MMODE + EXSPACE:
        goto labmaincontrol120append_normal_space;
        break;
    /* comment:Cases of |main_control| that are not part of the i */
    case VMODE + RELAX:
    case HMODE + RELAX:
    case MMODE + RELAX:
    case VMODE + SPACER:
    case MMODE + SPACER:
    case MMODE + NOBOUNDARY:;
        break;
    case VMODE + IGNORESPACES:
    case HMODE + IGNORESPACES:
    case MMODE + IGNORESPACES: {
        if (curchr == 0) {
            /* comment:Get the next non-blank non-call token */ do {
                getxtoken();
            } while (!(curcmd != SPACER));
            goto labmaincontrol21reswitch;
        } else {

            t = scannerstatus;
            scannerstatus = NORMAL;
            getnext();
            scannerstatus = t;
            if (curcs < HASHBASE)
                curcs = primlookup(curcs - SINGLEBASE);
            else
                curcs = primlookup(hash[curcs].v.RH);
            if (curcs != UNDEFINEDPRIMITIVE) {
                curcmd = eqtb[PRIMEQTBBASE + curcs].hh.b0;
                curchr = eqtb[PRIMEQTBBASE + curcs].hh.v.RH;
                curtok = /* @d13679@ */ 19621 + curcs;
                goto labmaincontrol21reswitch;
            }
        }
    } break;
    case VMODE + STOP:
        if (itsallover())
            return;
        break;
    /* comment:Forbidden cases detected in |main_control| */ /* @d13685@ */
    case VMOVE + 1:
    case HMODE + HMOVE:
    case MMODE + HMOVE:
    case VMODE + LASTITEM:
    case HMODE + LASTITEM:
    case MMODE + LASTITEM:
    case VMODE + VADJUST:
    case VMODE + ITALCORR:
    case VMODE + EQNO:
    case HMODE + EQNO:
    case VMODE + MACPARAM:
    case HMODE + MACPARAM:
    case MMODE + MACPARAM:
        reportillegalcase();
        break;
    /* comment:Math-only cases in non-math modes, or vice versa */
    case VMODE + SUPMARK:
    case HMODE + SUPMARK:
    case VMODE + SUBMARK:
    case HMODE + SUBMARK:
    case VMODE + MATHCHARNUM:
    case HMODE + MATHCHARNUM:
    case VMODE + MATHGIVEN:
    case HMODE + MATHGIVEN:
    case VMODE + MATHCOMP:
    case HMODE + MATHCOMP:
    case VMODE + DELIMNUM:
    case HMODE + DELIMNUM:
    case VMODE + LEFTRIGHT:
    case HMODE + LEFTRIGHT:
    case VMODE + ABOVE:
    case HMODE + ABOVE:
    case VMODE + RADICAL:
    case HMODE + RADICAL:
    case VMODE + MATHSTYLE:
    case HMODE + MATHSTYLE:
    case VMODE + MATHCHOICE:
    case HMODE + MATHCHOICE:
    case VMODE + VCENTER:
    case HMODE + VCENTER:
    case VMODE + NONSCRIPT:
    case HMODE + NONSCRIPT:
    case VMODE + MKERN:
    case HMODE + MKERN:
    case VMODE + LIMITSWITCH:
    case HMODE + LIMITSWITCH:
    case VMODE + MSKIP:
    case HMODE + MSKIP:
    case VMODE + MATHACCENT:
    case HMODE + MATHACCENT:
    case MMODE + ENDV:
    case MMODE + PAREND:
    case MMODE + STOP:
    case MMODE + VSKIP:
    case MMODE + UNVBOX:
    case MMODE + VALIGN:
    case MMODE + HRULE:
        insertdollarsign();
        break;
    /* comment:Cases of |main_control| that build boxes and lists */
    case VMODE + HRULE:
    case HMODE + VRULE:
    case MMODE + VRULE: {
        {
            mem[curlist.tailfield].hh.v.RH = scanrulespec();
            curlist.tailfield = mem[curlist.tailfield].hh.v.RH;
        }
        if (abs(curlist.modefield) == VMODE)
            curlist.auxfield.cint = eqtb[DIMENBASE + PDFIGNOREDDIMENCODE].cint;
        else if (abs(curlist.modefield) == HMODE)
            curlist.auxfield.hh.v.LH = 1000;
    } break;
    case VMODE + VSKIP:
    case HMODE + HSKIP:
    case MMODE + HSKIP:
    case MMODE + MSKIP:
        appendglue();
        break;
    case VMODE + KERN:
    case HMODE + KERN:
    case MMODE + KERN:
    case MMODE + MKERN:
        appendkern();
        break;
    case VMODE + LEFTBRACE:
    case HMODE + LEFTBRACE:
        newsavelevel(SIMPLEGROUP);
        break;
    case VMODE + BEGINGROUP:
    case HMODE + BEGINGROUP:
    case MMODE + BEGINGROUP:
        newsavelevel(SEMISIMPLEGROUP);
        break;
    case VMODE + ENDGROUP:
    case HMODE + ENDGROUP:
    case MMODE + ENDGROUP:
        if (curgroup == SEMISIMPLEGROUP)
            unsave();
        else
            offsave();
        break;
    case VMODE + RIGHTBRACE:
    case HMODE + RIGHTBRACE:
    case MMODE + RIGHTBRACE:
        handlerightbrace();
        break;
    case VMODE + HMOVE:
    case HMODE + VMOVE:
    case MMODE + VMOVE: {
        t = curchr;
        scandimen(false, false, false);
        if (t == 0)
            scanbox(curval);
        else
            scanbox(-(integer)curval);
    } break;
    case VMODE + LEADERSHIP:
    case HMODE + LEADERSHIP:
    case MMODE + LEADERSHIP:
        scanbox(/* @d13858@ */ 1073807261L + curchr);
        break;
    case VMODE + MAKEBOX:
    case HMODE + MAKEBOX:
    case MMODE + MAKEBOX:
        beginbox(0);
        break;
    case VMODE + STARTPAR:
        newgraf(curchr > 0);
        break;
    case VMODE + LETTER:
    case VMODE + OTHERCHAR:
    case VMODE + CHARNUM:
    case VMODE + CHARGIVEN:
    case VMODE + MATHSHIFT:
    case VMODE + UNHBOX:
    case VMODE + VRULE:
    case VMODE + ACCENT:
    case VMODE + DISCRETIONARY:
    case VMODE + HSKIP:
    case VMODE + VALIGN:
    case VMODE + EXSPACE:
    case VMODE + NOBOUNDARY: {
        backinput();
        newgraf(true);
    } break;
    case HMODE + STARTPAR:
    case MMODE + STARTPAR:
        if (curchr != 2)
            indentinhmode();
        break;
    case VMODE + PAREND: {
        normalparagraph();
        if (curlist.modefield > 0)
            buildpage();
    } break;
    case HMODE + PAREND: {
        if (alignstate < 0)
            offsave();
        endgraf();
        if (curlist.modefield == VMODE)
            buildpage();
    } break;
    case HMODE + STOP:
    case HMODE + VSKIP:
    case HMODE + HRULE:
    case HMODE + UNVBOX:
    case HMODE + HALIGN:
        headforvmode();
        break;
    case VMODE + INSERT:
    case HMODE + INSERT:
    case MMODE + INSERT:
    case HMODE + VADJUST:
    case MMODE + VADJUST:
        begininsertoradjust();
        break;
    case VMODE + MARK:
    case HMODE + MARK:
    case MMODE + MARK:
        makemark();
        break;
    case VMODE + BREAKPENALTY:
    case HMODE + BREAKPENALTY:
    case MMODE + BREAKPENALTY:
        appendpenalty();
        break;
    case VMODE + REMOVEITEM:
    case HMODE + REMOVEITEM:
    case MMODE + REMOVEITEM:
        deletelast();
        break;
    case VMODE + UNVBOX:
    case HMODE + UNHBOX:
    case MMODE + UNHBOX:
        unpackage();
        break;
    case HMODE + ITALCORR:
        appenditaliccorrection();
        break;
    case MMODE + ITALCORR: {
        mem[curlist.tailfield].hh.v.RH = newkern(0);
        curlist.tailfield = mem[curlist.tailfield].hh.v.RH;
    } break;
    case HMODE + DISCRETIONARY:
    case MMODE + DISCRETIONARY:
        appenddiscretionary();
        break;
    case HMODE + ACCENT:
        makeaccent();
        break;
    case VMODE + CARRET:
    case HMODE + CARRET:
    case MMODE + CARRET:
    case VMODE + TABMARK:
    case HMODE + TABMARK:
    case MMODE + TABMARK:
        alignerror();
        break;
    case VMODE + NOALIGN:
    case HMODE + NOALIGN:
    case MMODE + NOALIGN:
        noalignerror();
        break;
    case VMODE + OMIT:
    case HMODE + OMIT:
    case MMODE + OMIT:
        omiterror();
        break;
    case VMODE + HALIGN:
        initalign();
        break;
    case HMODE + VALIGN:
        /* comment:Cases of |main_control| for |hmode+valign| */ if (curchr >
                                                                     0) {
            if (eTeXenabled((eqtb[ETEXSTATEBASE + TEXXETCODE].cint > 0), curcmd,
                            curchr)) {
                mem[curlist.tailfield].hh.v.RH = newmath(0, curchr);
                curlist.tailfield = mem[curlist.tailfield].hh.v.RH;
            }
        } else
            initalign();
        break;
    case MMODE + HALIGN:
        if (privileged()) {

            if (curgroup == MATHSHIFTGROUP)
                initalign();
            else
                offsave();
        }
        break;
    case VMODE + ENDV:
    case HMODE + ENDV:
        doendv();
        break;
    case VMODE + ENDCSNAME:
    case HMODE + ENDCSNAME:
    case MMODE + ENDCSNAME:
        cserror();
        break;
    case HMODE + MATHSHIFT:
        initmath();
        break;
    case MMODE + EQNO:
        if (privileged()) {

            if (curgroup == MATHSHIFTGROUP)
                starteqno();
            else
                offsave();
        }
        break;
    case MMODE + LEFTBRACE: {
        {
            mem[curlist.tailfield].hh.v.RH = newnoad();
            curlist.tailfield = mem[curlist.tailfield].hh.v.RH;
        }
        backinput();
        scanmath(curlist.tailfield + 1);
    } break;
    case MMODE + LETTER:
    case MMODE + OTHERCHAR:
    case MMODE + CHARGIVEN:
        setmathchar(eqtb[MATHCODEBASE + curchr].hh.v.RH);
        break;
    case MMODE + CHARNUM: {
        scancharnum();
        curchr = curval;
        setmathchar(eqtb[MATHCODEBASE + curchr].hh.v.RH);
    } break;
    case MMODE + MATHCHARNUM: {
        scanfifteenbitint();
        setmathchar(curval);
    } break;
    case MMODE + MATHGIVEN:
        setmathchar(curchr);
        break;
    case MMODE + DELIMNUM: {
        scantwentysevenbitint();
        setmathchar(curval / 4096);
    } break;
    case MMODE + MATHCOMP: {
        {
            mem[curlist.tailfield].hh.v.RH = newnoad();
            curlist.tailfield = mem[curlist.tailfield].hh.v.RH;
        }
        mem[curlist.tailfield].hh.b0 = curchr;
        scanmath(curlist.tailfield + 1);
    } break;
    case MMODE + LIMITSWITCH:
        mathlimitswitch();
        break;
    case MMODE + RADICAL:
        mathradical();
        break;
    case MMODE + ACCENT:
    case MMODE + MATHACCENT:
        mathac();
        break;
    case MMODE + VCENTER: {
        scanspec(VCENTERGROUP, false);
        normalparagraph();
        pushnest();
        curlist.modefield = /* @d14036@ */ -1;
        curlist.auxfield.cint = eqtb[DIMENBASE + PDFIGNOREDDIMENCODE].cint;
        if ((insertsrcspecialeveryvbox))
            insertsrcspecial();
        if (eqtb[EVERYVBOXLOC].hh.v.RH != TEXNULL)
            begintokenlist(eqtb[EVERYVBOXLOC].hh.v.RH, EVERYVBOXTEXT);
    } break;
    case MMODE + MATHSTYLE: {
        mem[curlist.tailfield].hh.v.RH = newstyle(curchr);
        curlist.tailfield = mem[curlist.tailfield].hh.v.RH;
    } break;
    case MMODE + NONSCRIPT: {
        {
            mem[curlist.tailfield].hh.v.RH = newglue(membot);
            curlist.tailfield = mem[curlist.tailfield].hh.v.RH;
        }
        mem[curlist.tailfield].hh.b1 = CONDMATHGLUE;
    } break;
    case MMODE + MATHCHOICE:
        appendchoices();
        break;
    case MMODE + SUBMARK:
    case MMODE + SUPMARK:
        subsup();
        break;
    case MMODE + ABOVE:
        mathfraction();
        break;
    case MMODE + LEFTRIGHT:
        mathleftright();
        break;
    case MMODE + MATHSHIFT:
        if (curgroup == MATHSHIFTGROUP)
            aftermath();
        else
            offsave();
        break;
    /* comment:Cases of |main_control| that don't depend on |mode */
    case VMODE + TOKSREGISTER:
    case HMODE + TOKSREGISTER:
    case MMODE + TOKSREGISTER:
    case VMODE + ASSIGNTOKS:
    case HMODE + ASSIGNTOKS:
    case MMODE + ASSIGNTOKS:
    case VMODE + ASSIGNINT:
    case HMODE + ASSIGNINT:
    case MMODE + ASSIGNINT:
    case VMODE + ASSIGNDIMEN:
    case HMODE + ASSIGNDIMEN:
    case MMODE + ASSIGNDIMEN:
    case VMODE + ASSIGNGLUE:
    case HMODE + ASSIGNGLUE:
    case MMODE + ASSIGNGLUE:
    case VMODE + ASSIGNMUGLUE:
    case HMODE + ASSIGNMUGLUE:
    case MMODE + ASSIGNMUGLUE:
    case VMODE + ASSIGNFONTDIMEN:
    case HMODE + ASSIGNFONTDIMEN:
    case MMODE + ASSIGNFONTDIMEN:
    case VMODE + ASSIGNFONTINT:
    case HMODE + ASSIGNFONTINT:
    case MMODE + ASSIGNFONTINT:
    case VMODE + SETAUX:
    case HMODE + SETAUX:
    case MMODE + SETAUX:
    case VMODE + SETPREVGRAF:
    case HMODE + SETPREVGRAF:
    case MMODE + SETPREVGRAF:
    case VMODE + SETPAGEDIMEN:
    case HMODE + SETPAGEDIMEN:
    case MMODE + SETPAGEDIMEN:
    case VMODE + SETPAGEINT:
    case HMODE + SETPAGEINT:
    case MMODE + SETPAGEINT:
    case VMODE + SETBOXDIMEN:
    case HMODE + SETBOXDIMEN:
    case MMODE + SETBOXDIMEN:
    case VMODE + SETSHAPE:
    case HMODE + SETSHAPE:
    case MMODE + SETSHAPE:
    case VMODE + DEFCODE:
    case HMODE + DEFCODE:
    case MMODE + DEFCODE:
    case VMODE + DEFFAMILY:
    case HMODE + DEFFAMILY:
    case MMODE + DEFFAMILY:
    case VMODE + SETFONT:
    case HMODE + SETFONT:
    case MMODE + SETFONT:
    case VMODE + DEFFONT:
    case HMODE + DEFFONT:
    case MMODE + DEFFONT:
    case VMODE + LETTERSPACEFONT:
    case HMODE + LETTERSPACEFONT:
    case MMODE + LETTERSPACEFONT:
    case VMODE + PDFCOPYFONT:
    case HMODE + PDFCOPYFONT:
    case MMODE + PDFCOPYFONT:
    case VMODE + REGISTER:
    case HMODE + REGISTER:
    case MMODE + REGISTER:
    case VMODE + ADVANCE:
    case HMODE + ADVANCE:
    case MMODE + ADVANCE:
    case VMODE + MULTIPLY:
    case HMODE + MULTIPLY:
    case MMODE + MULTIPLY:
    case VMODE + DIVIDE:
    case HMODE + DIVIDE:
    case MMODE + DIVIDE:
    case VMODE + PREFIX:
    case HMODE + PREFIX:
    case MMODE + PREFIX:
    case VMODE + LET:
    case HMODE + LET:
    case MMODE + LET:
    case VMODE + SHORTHANDDEF:
    case HMODE + SHORTHANDDEF:
    case MMODE + SHORTHANDDEF:
    case VMODE + READTOCS:
    case HMODE + READTOCS:
    case MMODE + READTOCS:
    case VMODE + DEF:
    case HMODE + DEF:
    case MMODE + DEF:
    case VMODE + SETBOX:
    case HMODE + SETBOX:
    case MMODE + SETBOX:
    case VMODE + HYPHDATA:
    case HMODE + HYPHDATA:
    case MMODE + HYPHDATA:
    case VMODE + SETINTERACTION:
    case HMODE + SETINTERACTION:
    case MMODE + SETINTERACTION:
        prefixedcommand();
        break;
    case VMODE + AFTERASSIGNMENT:
    case HMODE + AFTERASSIGNMENT:
    case MMODE + AFTERASSIGNMENT: {
        gettoken();
        aftertoken = curtok;
    } break;
    case VMODE + AFTERGROUP:
    case HMODE + AFTERGROUP:
    case MMODE + AFTERGROUP: {
        gettoken();
        saveforafter(curtok);
    } break;
    case VMODE + INSTREAM:
    case HMODE + INSTREAM:
    case MMODE + INSTREAM:
        openorclosein();
        break;
    case VMODE + MESSAGE:
    case HMODE + MESSAGE:
    case MMODE + MESSAGE:
        issuemessage();
        break;
    case VMODE + CASESHIFT:
    case HMODE + CASESHIFT:
    case MMODE + CASESHIFT:
        shiftcase();
        break;
    case VMODE + XRAY:
    case HMODE + XRAY:
    case MMODE + XRAY:
        showwhatever();
        break;
    /* comment:Cases of |main_control| that are for extensions to */
    case VMODE + EXTENSION:
    case HMODE + EXTENSION:
    case MMODE + EXTENSION:
        doextension();
        break;
    }
    goto labmaincontrol60big_switch;
labmaincontrol70main_loop
    : /* comment:Append character |cur_chr| and the following chara */
    if (((curlist.headfield == curlist.tailfield) && (curlist.modefield > 0))) {
        if ((insertsrcspecialauto))
            appendsrcspecial();
    }
    mains = eqtb[SFCODEBASE + curchr].hh.v.RH;
    if (mains == 1000)
        curlist.auxfield.hh.v.LH = 1000;
    else if (mains < 1000) {
        if (mains > 0)
            curlist.auxfield.hh.v.LH = mains;
    } else if (curlist.auxfield.hh.v.LH < 1000)
        curlist.auxfield.hh.v.LH = 1000;
    else
        curlist.auxfield.hh.v.LH = mains;
    savetail = TEXNULL;
    mainf = eqtb[CURFONTLOC].hh.v.RH;
    bchar = fontbchar[mainf];
    falsebchar = fontfalsebchar[mainf];
    if (curlist.modefield > 0) {

        if (eqtb[INTBASE + LANGUAGECODE].cint != curlist.auxfield.hh.v.RH)
            fixlanguage();
    }
    {
        ligstack = avail;
        if (ligstack == TEXNULL)
            ligstack = getavail();
        else {

            avail = mem[ligstack].hh.v.RH;
            mem[ligstack].hh.v.RH = TEXNULL;
            mem[ligstack].hh.me = curchrsig;
            ;
#ifdef STAT
            incr(dynused);
#endif /* STAT */
        }
    }
    mem[ligstack].hh.b0 = mainf;
    curl = curchr;
    mem[ligstack].hh.b1 = curl;
    curq = curlist.tailfield;
    tmpk1 = getautokern(mainf, 256, curl);
    /* comment:If |tmp_k1| is not null then append that kern */
    if (tmpk1 != TEXNULL) {
        if (curl < 256) {
            if (mem[curq].hh.v.RH > TEXNULL) {

                if (mem[curlist.tailfield].hh.b1 == hyphenchar[mainf])
                    insdisc = true;
            }
            if (ligaturepresent) {
                mainp = newligature(mainf, curl, mem[curq].hh.v.RH);
                mem[mainp].hh.me = mem[mem[curq].hh.v.RH].hh.me;
                if (lfthit) {
                    mem[mainp].hh.b1 = 2;
                    lfthit = false;
                }
                if (rthit) {

                    if (ligstack == TEXNULL) {
                        incr(mem[mainp].hh.b1);
                        rthit = false;
                    }
                }
                if (eqtb[INTBASE + PDFPREPENDKERNCODE].cint > 0)
                    tmpk2 = getautokern(mainf, 256, curl);
                else
                    tmpk2 = TEXNULL;
                if (tmpk2 == TEXNULL) {
                    mem[curq].hh.v.RH = mainp;
                    curlist.tailfield = mainp;
                    ligaturepresent = false;
                } else {

                    mem[curq].hh.v.RH = tmpk2;
                    mem[tmpk2].hh.v.RH = mainp;
                    curlist.tailfield = mainp;
                    ligaturepresent = false;
                }
            }
            if (insdisc) {
                insdisc = false;
                if (curlist.modefield > 0) {
                    mem[curlist.tailfield].hh.v.RH = newdisc();
                    curlist.tailfield = mem[curlist.tailfield].hh.v.RH;
                }
            }
        }
        savetail = curlist.tailfield;
        {
            mem[curlist.tailfield].hh.v.RH = tmpk1;
            curlist.tailfield = mem[curlist.tailfield].hh.v.RH;
        }
        goto labmaincontrol90main_loop_move;
    }
    if (cancelboundary) {
        cancelboundary = false;
        maink = NONADDRESS;
    } else
        maink = bcharlabel[mainf];
    if (maink == NONADDRESS)
        goto labmaincontrol92main_loop_move;
    curr = curl;
    curl = 256;
    goto labmaincontrol111main_lig_loop;
labmaincontrol80main_loop_wrapup
    : /* comment:Make a ligature node, if |ligature_present|; inser */
    if (curl < 256) {
        if (mem[curq].hh.v.RH > TEXNULL) {

            if (mem[curlist.tailfield].hh.b1 == hyphenchar[mainf])
                insdisc = true;
        }
        if (ligaturepresent) {
            mainp = newligature(mainf, curl, mem[curq].hh.v.RH);
            mem[mainp].hh.me = mem[mem[curq].hh.v.RH].hh.me;
            if (lfthit) {
                mem[mainp].hh.b1 = 2;
                lfthit = false;
            }
            if (rthit) {

                if (ligstack == TEXNULL) {
                    incr(mem[mainp].hh.b1);
                    rthit = false;
                }
            }
            if (eqtb[INTBASE + PDFPREPENDKERNCODE].cint > 0)
                tmpk2 = getautokern(mainf, 256, curl);
            else
                tmpk2 = TEXNULL;
            if (tmpk2 == TEXNULL) {
                mem[curq].hh.v.RH = mainp;
                curlist.tailfield = mainp;
                ligaturepresent = false;
            } else {

                mem[curq].hh.v.RH = tmpk2;
                mem[tmpk2].hh.v.RH = mainp;
                curlist.tailfield = mainp;
                ligaturepresent = false;
            }
        }
        if (insdisc) {
            insdisc = false;
            if (curlist.modefield > 0) {
                mem[curlist.tailfield].hh.v.RH = newdisc();
                curlist.tailfield = mem[curlist.tailfield].hh.v.RH;
            }
        }
    }
labmaincontrol90main_loop_move
    : /* comment:If the cursor is immediately followed by the right */
    if (ligstack == TEXNULL)
        goto labmaincontrol21reswitch;
    curq = curlist.tailfield;
    curl = mem[ligstack].hh.b1;
labmaincontrol91main_loop_move:
    if (!(ligstack >= himemmin))
        goto labmaincontrol95main_loop_move_lig;
labmaincontrol92main_loop_move:
    if ((effectivechar(false, mainf, curchr) > fontec[mainf]) ||
        (effectivechar(false, mainf, curchr) < fontbc[mainf])) {
        charwarning(mainf, curchr);
        {
            mem[ligstack].hh.v.RH = avail;
            avail = ligstack;
            mem[ligstack].hh.me = 0;
            ;
#ifdef STAT
            decr(dynused);
#endif /* STAT */
        }
        goto labmaincontrol60big_switch;
    }
    maini = effectivecharinfo(mainf, curl);
    if (!(maini.b0 > MINQUARTERWORD)) {
        charwarning(mainf, curchr);
        {
            mem[ligstack].hh.v.RH = avail;
            avail = ligstack;
            mem[ligstack].hh.me = 0;
            ;
#ifdef STAT
            decr(dynused);
#endif /* STAT */
        }
        goto labmaincontrol60big_switch;
    }
    mem[curlist.tailfield].hh.v.RH = ligstack;
    curlist.tailfield = ligstack;
labmaincontrol100main_loop_lookahead
    : /* comment:Look ahead for another character, or leave |lig_st */
    getnext();
    if (curcmd == LETTER)
        goto labmaincontrol101main_loop_lookahead;
    if (curcmd == OTHERCHAR)
        goto labmaincontrol101main_loop_lookahead;
    if (curcmd == CHARGIVEN)
        goto labmaincontrol101main_loop_lookahead;
    xtoken();
    if (curcmd == LETTER)
        goto labmaincontrol101main_loop_lookahead;
    if (curcmd == OTHERCHAR)
        goto labmaincontrol101main_loop_lookahead;
    if (curcmd == CHARGIVEN)
        goto labmaincontrol101main_loop_lookahead;
    if (curcmd == CHARNUM) {
        scancharnum();
        curchr = curval;
        goto labmaincontrol101main_loop_lookahead;
    }
    if (curcmd == NOBOUNDARY)
        bchar = 256;
    curr = bchar;
    ligstack = TEXNULL;
    goto labmaincontrol110main_lig_loop;
labmaincontrol101main_loop_lookahead:
    mains = eqtb[SFCODEBASE + curchr].hh.v.RH;
    if (mains == 1000)
        curlist.auxfield.hh.v.LH = 1000;
    else if (mains < 1000) {
        if (mains > 0)
            curlist.auxfield.hh.v.LH = mains;
    } else if (curlist.auxfield.hh.v.LH < 1000)
        curlist.auxfield.hh.v.LH = 1000;
    else
        curlist.auxfield.hh.v.LH = mains;
    {
        ligstack = avail;
        if (ligstack == TEXNULL)
            ligstack = getavail();
        else {

            avail = mem[ligstack].hh.v.RH;
            mem[ligstack].hh.v.RH = TEXNULL;
            mem[ligstack].hh.me = curchrsig;
            ;
#ifdef STAT
            incr(dynused);
#endif /* STAT */
        }
    }
    mem[ligstack].hh.b0 = mainf;
    curr = curchr;
    mem[ligstack].hh.b1 = curr;
    if (curr == falsebchar)
        curr = 256;
labmaincontrol110main_lig_loop
    : /* comment:If there's a ligaturekern command relevant to |cu */
    tmpk1 = getautokern(mainf, curl, curr);
    /* comment:If |tmp_k1| is not null then append that kern */
    if (tmpk1 != TEXNULL) {
        if (curl < 256) {
            if (mem[curq].hh.v.RH > TEXNULL) {

                if (mem[curlist.tailfield].hh.b1 == hyphenchar[mainf])
                    insdisc = true;
            }
            if (ligaturepresent) {
                mainp = newligature(mainf, curl, mem[curq].hh.v.RH);
                mem[mainp].hh.me = mem[mem[curq].hh.v.RH].hh.me;
                if (lfthit) {
                    mem[mainp].hh.b1 = 2;
                    lfthit = false;
                }
                if (rthit) {

                    if (ligstack == TEXNULL) {
                        incr(mem[mainp].hh.b1);
                        rthit = false;
                    }
                }
                if (eqtb[INTBASE + PDFPREPENDKERNCODE].cint > 0)
                    tmpk2 = getautokern(mainf, 256, curl);
                else
                    tmpk2 = TEXNULL;
                if (tmpk2 == TEXNULL) {
                    mem[curq].hh.v.RH = mainp;
                    curlist.tailfield = mainp;
                    ligaturepresent = false;
                } else {

                    mem[curq].hh.v.RH = tmpk2;
                    mem[tmpk2].hh.v.RH = mainp;
                    curlist.tailfield = mainp;
                    ligaturepresent = false;
                }
            }
            if (insdisc) {
                insdisc = false;
                if (curlist.modefield > 0) {
                    mem[curlist.tailfield].hh.v.RH = newdisc();
                    curlist.tailfield = mem[curlist.tailfield].hh.v.RH;
                }
            }
        }
        savetail = curlist.tailfield;
        {
            mem[curlist.tailfield].hh.v.RH = tmpk1;
            curlist.tailfield = mem[curlist.tailfield].hh.v.RH;
        }
        goto labmaincontrol90main_loop_move;
    }
    if (((maini.b2) % 4) != LIGTAG)
        goto labmaincontrol80main_loop_wrapup;
    if (curr == 256)
        goto labmaincontrol80main_loop_wrapup;
    maink = ligkernbase[mainf] + maini.b3;
    mainj = fontinfo[maink].qqqq;
    if (mainj.b0 <= 128)
        goto labmaincontrol112main_lig_loop;
    maink = ligkernbase[mainf] + 256 * mainj.b2 + mainj.b3 + 32768L -
            256 * (/* @d14354@ */ 128);
labmaincontrol111main_lig_loop:
    mainj = fontinfo[maink].qqqq;
labmaincontrol112main_lig_loop:
    if (mainj.b1 == curr) {

        if (mainj.b0 <= 128) /* comment:Do ligature or kern command, returning
                                to |main_li */
        {
            if (mainj.b2 >= 128) {
                if (curl < 256) {
                    if (mem[curq].hh.v.RH > TEXNULL) {

                        if (mem[curlist.tailfield].hh.b1 == hyphenchar[mainf])
                            insdisc = true;
                    }
                    if (ligaturepresent) {
                        mainp = newligature(mainf, curl, mem[curq].hh.v.RH);
                        mem[mainp].hh.me = mem[mem[curq].hh.v.RH].hh.me;
                        if (lfthit) {
                            mem[mainp].hh.b1 = 2;
                            lfthit = false;
                        }
                        if (rthit) {

                            if (ligstack == TEXNULL) {
                                incr(mem[mainp].hh.b1);
                                rthit = false;
                            }
                        }
                        if (eqtb[INTBASE + PDFPREPENDKERNCODE].cint > 0)
                            tmpk2 = getautokern(mainf, 256, curl);
                        else
                            tmpk2 = TEXNULL;
                        if (tmpk2 == TEXNULL) {
                            mem[curq].hh.v.RH = mainp;
                            curlist.tailfield = mainp;
                            ligaturepresent = false;
                        } else {

                            mem[curq].hh.v.RH = tmpk2;
                            mem[tmpk2].hh.v.RH = mainp;
                            curlist.tailfield = mainp;
                            ligaturepresent = false;
                        }
                    }
                    if (insdisc) {
                        insdisc = false;
                        if (curlist.modefield > 0) {
                            mem[curlist.tailfield].hh.v.RH = newdisc();
                            curlist.tailfield = mem[curlist.tailfield].hh.v.RH;
                        }
                    }
                }
                {
                    mem[curlist.tailfield].hh.v.RH = newkern(
                        fontinfo[kernbase[mainf] + 256 * mainj.b2 + mainj.b3]
                            .cint);
                    curlist.tailfield = mem[curlist.tailfield].hh.v.RH;
                }
                goto labmaincontrol90main_loop_move;
            }
            if (curl == 256)
                lfthit = true;
            else if (ligstack == TEXNULL)
                rthit = true;
            {
                if (interrupt != 0)
                    pauseforinstructions();
            }
            switch (mainj.b2) {
            case 1:
            case 5: {
                curl = mainj.b3;
                maini =
                    fontinfo[charbase[mainf] + effectivechar(true, mainf, curl)]
                        .qqqq;
                ligaturepresent = true;
            } break;
            case 2:
            case 6: {
                curr = mainj.b3;
                if (ligstack == TEXNULL) {
                    ligstack = newligitem(curr);
                    bchar = 256;
                } else if ((ligstack >= himemmin)) {
                    mainp = ligstack;
                    ligstack = newligitem(curr);
                    mem[ligstack + 1].hh.v.RH = mainp;
                } else
                    mem[ligstack].hh.b1 = curr;
            } break;
            case 3: {
                curr = mainj.b3;
                mainp = ligstack;
                ligstack = newligitem(curr);
                mem[ligstack].hh.v.RH = mainp;
            } break;
            case 7:
            case 11: {
                if (curl < 256) {
                    if (mem[curq].hh.v.RH > TEXNULL) {

                        if (mem[curlist.tailfield].hh.b1 == hyphenchar[mainf])
                            insdisc = true;
                    }
                    if (ligaturepresent) {
                        mainp = newligature(mainf, curl, mem[curq].hh.v.RH);
                        mem[mainp].hh.me = mem[mem[curq].hh.v.RH].hh.me;
                        if (lfthit) {
                            mem[mainp].hh.b1 = 2;
                            lfthit = false;
                        }
                        if (false) {

                            if (ligstack == TEXNULL) {
                                incr(mem[mainp].hh.b1);
                                rthit = false;
                            }
                        }
                        if (eqtb[INTBASE + PDFPREPENDKERNCODE].cint > 0)
                            tmpk2 = getautokern(mainf, 256, curl);
                        else
                            tmpk2 = TEXNULL;
                        if (tmpk2 == TEXNULL) {
                            mem[curq].hh.v.RH = mainp;
                            curlist.tailfield = mainp;
                            ligaturepresent = false;
                        } else {

                            mem[curq].hh.v.RH = tmpk2;
                            mem[tmpk2].hh.v.RH = mainp;
                            curlist.tailfield = mainp;
                            ligaturepresent = false;
                        }
                    }
                    if (insdisc) {
                        insdisc = false;
                        if (curlist.modefield > 0) {
                            mem[curlist.tailfield].hh.v.RH = newdisc();
                            curlist.tailfield = mem[curlist.tailfield].hh.v.RH;
                        }
                    }
                }
                curq = curlist.tailfield;
                curl = mainj.b3;
                maini =
                    fontinfo[charbase[mainf] + effectivechar(true, mainf, curl)]
                        .qqqq;
                ligaturepresent = true;
            } break;
            default: {
                curl = mainj.b3;
                ligaturepresent = true;
                if (ligstack == TEXNULL)
                    goto labmaincontrol80main_loop_wrapup;
                else
                    goto labmaincontrol91main_loop_move;
            } break;
            }
            if (mainj.b2 > 4) {

                if (mainj.b2 != 7)
                    goto labmaincontrol80main_loop_wrapup;
            }
            if (curl < 256)
                goto labmaincontrol110main_lig_loop;
            maink = bcharlabel[mainf];
            goto labmaincontrol111main_lig_loop;
        }
    }
    if (mainj.b0 == 0)
        incr(maink);
    else {

        if (mainj.b0 >= 128)
            goto labmaincontrol80main_loop_wrapup;
        maink = maink + mainj.b0 + 1;
    }
    goto labmaincontrol111main_lig_loop;
labmaincontrol95main_loop_move_lig
    : /* comment:Move the cursor past a pseudo-ligature, then |goto */
    mainp = mem[ligstack + 1].hh.v.RH;
    if (mainp > TEXNULL) {
        mem[curlist.tailfield].hh.v.RH = mainp;
        curlist.tailfield = mem[curlist.tailfield].hh.v.RH;
    }
    tempptr = ligstack;
    ligstack = mem[tempptr].hh.v.RH;
    freenode(tempptr, SMALLNODESIZE);
    maini = fontinfo[charbase[mainf] + effectivechar(true, mainf, curl)].qqqq;
    ligaturepresent = true;
    if (ligstack == TEXNULL) {

        if (mainp > TEXNULL)
            goto labmaincontrol100main_loop_lookahead;
        else
            curr = bchar;
    } else
        curr = mem[ligstack].hh.b1;
    goto labmaincontrol110main_lig_loop;
labmaincontrol120append_normal_space
    : /* comment:Append a normal inter-word space to the current li */
    if (eqtb[GLUEBASE + SPACESKIPCODE].hh.v.RH == membot) {
        /* comment:Find the glue specification, |main_p|, for text sp */ {

            mainp = fontglue[eqtb[CURFONTLOC].hh.v.RH];
            if (mainp == TEXNULL) {
                mainp = newspec(membot);
                maink = parambase[eqtb[CURFONTLOC].hh.v.RH] /* @d14382@ */
                        + 2;
                mem[mainp + WIDTHOFFSET].cint = fontinfo[maink].cint;
                mem[mainp + 2].cint = fontinfo[maink + 1].cint;
                mem[mainp + 3].cint = fontinfo[maink + 2].cint;
                fontglue[eqtb[CURFONTLOC].hh.v.RH] = mainp;
            }
        }
        tempptr = newglue(mainp);
    } else
        tempptr = newparamglue(SPACESKIPCODE);
    if (eqtb[INTBASE + PDFADJUSTINTERWORDGLUECODE].cint > 0)
        adjustinterwordglue(curlist.tailfield, tempptr);
    mem[curlist.tailfield].hh.v.RH = tempptr;
    curlist.tailfield = tempptr;
    mem[tempptr].hh.me = curchrsig;
    goto labmaincontrol60big_switch;
}
void giveerrhelp(void) {
    giveerrhelp_regmem tokenshow(eqtb[ERRHELPLOC].hh.v.RH);
}
/* comment:Declare the function called |open_fmt_file| */ boolean
openfmtfile(void) {
    register boolean Result;
    openfmtfile_regmem integer j;
    j = curinput.locfield;
    if (buffer[curinput.locfield] == /* str '&' */ 38) {
        incr(curinput.locfield);
        j = curinput.locfield;
        buffer[last] = /* str ' ' */ 32;
        while (buffer[j] != /* str ' ' */ 32)
            incr(j);
        packbufferedname(0, curinput.locfield, j - 1);
        if (wopenin(fmtfile))
            goto labopenfmtfile40found;
        Fputs(stdout, "Sorry, I can't find the format `");
        fputs(stringcast(nameoffile + 1), stdout);
        Fputs(stdout, "'; will try `");
        fputs(TEXformatdefault + 1, stdout);
        fprintf(stdout, "%s\n", "'.");
        fflush(stdout);
    }
    packbufferedname(formatdefaultlength - FORMATEXTLENGTH, 1, 0);
    if (!wopenin(fmtfile)) {
        ;
        Fputs(stdout, "I can't find the format file `");
        fputs(TEXformatdefault + 1, stdout);
        fprintf(stdout, "%s\n", "'!");
        Result = false;
        return Result;
    }
labopenfmtfile40found:
    curinput.locfield = j;
    Result = true;
    return Result;
}
/* comment:Last-minute procedures */ void closefilesandterminate(void) {
    closefilesandterminate_regmem integer a, b, c, i, j, k, l;
    boolean isroot;
    boolean isnames;
    integer root, outlines, threads, namestree, dests;
    integer xrefoffsetwidth, nameshead, namestail;
    /* comment:Finish the extensions */ {
        register integer for_end;
        k = 0;
        for_end = 15;
        if (k <= for_end)
            do
                if (writeopen[k])
                    aclose(writefile[k]);
            while (k++ < for_end);
    };
#ifdef STAT
    if (eqtb[INTBASE + TRACINGSTATSCODE].cint >
        0) /* comment:Output statistics about this job */ {

        if (logopened) {
            {
                putc(' ', logfile);
                putc('\n', logfile);
            }
            fprintf(logfile, "%s%s\n", "Here is how much of TeX's memory",
                    " you used:");
            fprintf(logfile, "%c%ld%s", ' ', (long)strptr - initstrptr,
                    " string");
            if (strptr != initstrptr + 1)
                putc('s', logfile);
            fprintf(logfile, "%s%ld\n", " out of ",
                    (long)maxstrings - initstrptr);
            fprintf(logfile, "%c%ld%s%ld\n", ' ', (long)poolptr - initpoolptr,
                    " string characters out of ", (long)poolsize - initpoolptr);
            fprintf(logfile, "%c%ld%s%ld\n", ' ',
                    (long)lomemmax - memmin + memend - himemmin + 2,
                    " words of memory out of ", (long)memend + 1 - memmin);
            fprintf(logfile, "%c%ld%s%ld%c%ld\n", ' ', (long)cscount,
                    " multiletter control sequences out of ",
                    (long)/* @d14605@ */ 15000, '+', (long)hashextra);
            fprintf(logfile, "%c%ld%s%ld%s", ' ', (long)fmemptr,
                    " words of font info for ", (long)fontptr - FONTBASE,
                    " font");
            if (fontptr != /* @d14607@ */ 1)
                putc('s', logfile);
            fprintf(logfile, "%s%ld%s%ld\n", ", out of ", (long)fontmemsize,
                    " for ", (long)fontmax - FONTBASE);
            fprintf(logfile, "%c%ld%s", ' ', (long)hyphcount,
                    " hyphenation exception");
            if (hyphcount != 1)
                putc('s', logfile);
            fprintf(logfile, "%s%ld\n", " out of ", (long)hyphsize);
            fprintf(logfile,
                    "%c%ld%s%ld%s%ld%s%ld%s%ld%s%ld%s%ld%s%ld%s%ld%s%ld%c\n",
                    ' ', (long)maxinstack, "i,", (long)maxneststack, "n,",
                    (long)maxparamstack, "p,", (long)maxbufstack + 1, "b,",
                    (long)maxsavestack + 6, "s stack positions out of ",
                    (long)stacksize, "i,", (long)nestsize, "n,",
                    (long)paramsize, "p,", (long)bufsize, "b,", (long)savesize,
                    's');
        }
    }
#endif /* STAT */
    if (!fixedpdfoutputset)
        fixpdfoutput();
    if (fixedpdfoutput > 0) {
        if (history == FATALERRORSTOP) {
            removepdffile();
            {
                if (interaction == ERRORSTOPMODE)
                    ;
                if (filelineerrorstylep)
                    printfileline();
                else
                    printnl(/* str '! ' */ 264);
                print(/* str ' ==> Fatal error occurred, no output PDF file pro'
                       */
                      1721);
            }
        } else {

            /* comment:Finish the PDF file */ if (totalpages == 0) {
                printnl(/* str 'No pages of output.' */ 996);
                if (pdfgone > 0)
                    garbagewarning();
            } else {

                if (fixedpdfdraftmode == 0) {
                    pdfflush();
                    if (totalpages % 6 != 0)
                        objtab[pdflastpages].int0 = totalpages % 6;
                    flushjbig2page0objects();
                    /* comment:Check for non-existing pages */ k = headtab[1];
                    while (objtab[k].int4 == 0) {

                        pdfwarning(/* str 'dest' */ 1196,
                                   /* str 'Page ' */ 1201, false, false);
                        printint(objtab[k].int0);
                        print(
                            /* str ' has been referenced but does not exist!' */
                            1202);
                        println();
                        println();
                        k = objtab[k].int1;
                    }
                    headtab[1] = k;
                    /* comment:Reverse the linked list of Page and Pages objects
                     */
                    k = headtab[1];
                    l = 0;
                    do {
                        i = objtab[k].int1;
                        objtab[k].int1 = l;
                        l = k;
                        k = i;
                    } while (!(k == 0));
                    headtab[1] = l;
                    k = headtab[2];
                    pagestail = k;
                    l = 0;
                    do {
                        i = objtab[k].int1;
                        objtab[k].int1 = l;
                        l = k;
                        k = i;
                    } while (!(k == 0));
                    headtab[2] = l;
                    /* comment:Check for non-existing destinations */ k =
                        headtab[5];
                    while (k != 0) {

                        pdffixdest(k);
                        k = objtab[k].int1;
                    }
                    /* comment:Output fonts definition */ {
                        register integer for_end;
                        k = /* @d14622@ */ 1;
                        for_end = fontptr;
                        if (k <= for_end)
                            do
                                if (fontused[k] && hasfmentry(k) &&
                                    (pdffontnum[k] < 0)) {
                                    i = -(integer)pdffontnum[k];
                                    pdfassert(pdffontnum[i] > 0);
                                    {
                                        register integer for_end;
                                        j = 0;
                                        for_end = 255;
                                        if (j <= for_end)
                                            do
                                                if (pdfcharmarked(k, j))
                                                    pdfmarkchar(i, j);
                                            while (j++ < for_end);
                                    }
                                    if (((strstart[pdffontattr[i] + 1] -
                                          strstart[pdffontattr[i]]) == 0) &&
                                        ((strstart[pdffontattr[k] + 1] -
                                          strstart[pdffontattr[k]]) != 0))
                                        pdffontattr[i] = pdffontattr[k];
                                    else if (((strstart[pdffontattr[k] + 1] -
                                               strstart[pdffontattr[k]]) ==
                                              0) &&
                                             ((strstart[pdffontattr[i] + 1] -
                                               strstart[pdffontattr[i]]) != 0))
                                        pdffontattr[k] = pdffontattr[i];
                                    else if (((strstart[pdffontattr[i] + 1] -
                                               strstart[pdffontattr[i]]) !=
                                              0) &&
                                             ((strstart[pdffontattr[k] + 1] -
                                               strstart[pdffontattr[k]]) !=
                                              0) &&
                                             !streqstr(pdffontattr[i],
                                                       pdffontattr[k])) {
                                        pdfwarning(
                                            /* str '\pdffontattr' */ 1203,
                                            /* str 'fonts ' */ 1204, false,
                                            false);
                                        printfontidentifier(i);
                                        print(/* str ' and ' */ 1205);
                                        printfontidentifier(k);
                                        print(/* str ' have conflicting
                                                 attributes; I will ignore the
                                                 a' */
                                              1206);
                                        printfontidentifier(i);
                                        println();
                                        println();
                                    }
                                }
                            while (k++ < for_end);
                    }
                    fixedgentounicode =
                        eqtb[INTBASE + PDFGENTOUNICODECODE].cint;
                    k = headtab[3];
                    while (k != 0) {

                        f = objtab[k].int0;
                        pdfassert(pdffontnum[f] > 0);
                        dopdffont(k, f);
                        k = objtab[k].int1;
                    }
                    writefontstuff();
                    /* comment:Output pages tree */ a = sysobjptr + 1;
                    l = headtab[2];
                    k = headtab[1];
                    b = 0;
                    do {
                        i = 0;
                        c = 0;
                        if (objtab[l].int1 == 0)
                            isroot = true;
                        else
                            isroot = false;
                        do {
                            if (!isroot) {
                                if (i % 6 == 0) {
                                    pdflastpages = pdfnewobjnum();
                                    if (c == 0)
                                        c = pdflastpages;
                                    objtab[pagestail].int1 = pdflastpages;
                                    pagestail = pdflastpages;
                                    objtab[pdflastpages].int1 = 0;
                                    objtab[pdflastpages].int0 = objtab[l].int0;
                                } else
                                    objtab[pdflastpages].int0 =
                                        objtab[pdflastpages].int0 +
                                        objtab[l].int0;
                            }
                            /* comment:Output the current Pages object in this
                             * level */
                            pdfbegindict(l, 1);
                            {
                                pdfprint(/* str 'Type Pages' */ 1207);
                                {
                                    {
                                        if (pdfosmode &&
                                            (1 + pdfptr > pdfbufsize))
                                            pdfosgetosbuf(1);
                                        else if (!pdfosmode && (1 > pdfbufsize))
                                            overflow(
                                                /* str 'PDF output buffer' */
                                                1004, pdfopbufsize);
                                        else if (!pdfosmode &&
                                                 (1 + pdfptr > pdfbufsize))
                                            pdfflush();
                                    }
                                    {
                                        pdfbuf[pdfptr] = 10;
                                        incr(pdfptr);
                                    }
                                }
                            }
                            pdfintentryln(/* str 'Count' */ 1191,
                                          objtab[l].int0);
                            if (!isroot)
                                pdfindirectln(/* str 'Parent' */ 1166,
                                              pdflastpages);
                            pdfprint(/* str 'Kids [' */ 1208);
                            j = 0;
                            do {
                                pdfprintint(k);
                                pdfprint(/* str ' 0 R ' */ 1151);
                                k = objtab[k].int1;
                                incr(j);
                            } while (!(((l < a) && (j == objtab[l].int0)) ||
                                       (k == 0) || ((k == b) && (b != 0)) ||
                                       (j == 6)));
                            removelastspace();
                            {
                                pdfprint(/* str ']' */ 93);
                                {
                                    {
                                        if (pdfosmode &&
                                            (1 + pdfptr > pdfbufsize))
                                            pdfosgetosbuf(1);
                                        else if (!pdfosmode && (1 > pdfbufsize))
                                            overflow(
                                                /* str 'PDF output buffer' */
                                                1004, pdfopbufsize);
                                        else if (!pdfosmode &&
                                                 (1 + pdfptr > pdfbufsize))
                                            pdfflush();
                                    }
                                    {
                                        pdfbuf[pdfptr] = 10;
                                        incr(pdfptr);
                                    }
                                }
                            }
                            if (k == 0) {
                                k = headtab[2];
                                headtab[2] = 0;
                            }
                            if (isroot &&
                                (eqtb[PDFPAGESATTRLOC].hh.v.RH != TEXNULL))
                                pdfprinttoksln(eqtb[PDFPAGESATTRLOC].hh.v.RH);
                            pdfenddict();
                            incr(i);
                            l = objtab[l].int1;
                        } while (!((l == c)));
                        b = c;
                        if (l == 0)
                            goto labclosefilesandterminate30done;
                    } while (!(false));
                labclosefilesandterminate30done:;
                    /* comment:Output outlines */ if (pdffirstoutline != 0) {
                        pdfnewdict(0, 0, 1);
                        outlines = objptr;
                        l = pdffirstoutline;
                        k = 0;
                        do {
                            incr(k);
                            a = opensubentries(l);
                            if (objtab[l].int0 > 0)
                                k = k + a;
                            pdfmem[objtab[l].int4 + 1] = objptr;
                            l = pdfmem[objtab[l].int4 + 3];
                        } while (!(l == 0));
                        {
                            pdfprint(/* str 'Type Outlines' */ 1188);
                            {
                                {
                                    if (pdfosmode && (1 + pdfptr > pdfbufsize))
                                        pdfosgetosbuf(1);
                                    else if (!pdfosmode && (1 > pdfbufsize))
                                        overflow(
                                            /* str 'PDF output buffer' */ 1004,
                                            pdfopbufsize);
                                    else if (!pdfosmode &&
                                             (1 + pdfptr > pdfbufsize))
                                        pdfflush();
                                }
                                {
                                    pdfbuf[pdfptr] = 10;
                                    incr(pdfptr);
                                }
                            }
                        }
                        pdfindirectln(/* str 'First' */ 1189, pdffirstoutline);
                        pdfindirectln(/* str 'Last' */ 1190, pdflastoutline);
                        pdfintentryln(/* str 'Count' */ 1191, k);
                        pdfenddict();
                        /* comment:Output PDF outline entries */ k = headtab[4];
                        while (k != 0) {

                            if (pdfmem[objtab[k].int4 + 1] ==
                                pdfparentoutline) {
                                if (pdfmem[objtab[k].int4 + 2] == 0)
                                    pdffirstoutline = k;
                                if (pdfmem[objtab[k].int4 + 3] == 0)
                                    pdflastoutline = k;
                            }
                            pdfbegindict(k, 1);
                            pdfindirectln(/* str 'Title' */ 1192,
                                          pdfmem[objtab[k].int4]);
                            pdfindirectln(/* str 'A' */ 65,
                                          pdfmem[objtab[k].int4 + 6]);
                            if (pdfmem[objtab[k].int4 + 1] != 0)
                                pdfindirectln(/* str 'Parent' */ 1166,
                                              pdfmem[objtab[k].int4 + 1]);
                            if (pdfmem[objtab[k].int4 + 2] != 0)
                                pdfindirectln(/* str 'Prev' */ 1193,
                                              pdfmem[objtab[k].int4 + 2]);
                            if (pdfmem[objtab[k].int4 + 3] != 0)
                                pdfindirectln(/* str 'Next' */ 1194,
                                              pdfmem[objtab[k].int4 + 3]);
                            if (pdfmem[objtab[k].int4 + 4] != 0)
                                pdfindirectln(/* str 'First' */ 1189,
                                              pdfmem[objtab[k].int4 + 4]);
                            if (pdfmem[objtab[k].int4 + 5] != 0)
                                pdfindirectln(/* str 'Last' */ 1190,
                                              pdfmem[objtab[k].int4 + 5]);
                            if (objtab[k].int0 != 0)
                                pdfintentryln(/* str 'Count' */ 1191,
                                              objtab[k].int0);
                            if (pdfmem[objtab[k].int4 + 7] != 0) {
                                pdfprinttoksln(pdfmem[objtab[k].int4 + 7]);
                                {
                                    deletetokenref(pdfmem[objtab[k].int4 + 7]);
                                    pdfmem[objtab[k].int4 + 7] = TEXNULL;
                                }
                            }
                            pdfenddict();
                            k = objtab[k].int1;
                        }
                    } else
                        outlines = 0;
                    /* comment:Output name tree */ if (pdfdestnamesptr == 0) {
                        dests = 0;
                        goto labclosefilesandterminate31done1;
                    }
                    sortdestnames(0, pdfdestnamesptr - 1);
                    nameshead = 0;
                    namestail = 0;
                    k = 0;
                    isnames = true;
                    b = 0;
                    do {
                        do {
                            pdfcreateobj(0, 0);
                            l = objptr;
                            if (b == 0)
                                b = l;
                            if (nameshead == 0) {
                                nameshead = l;
                                namestail = l;
                            } else {

                                objtab[namestail].int1 = l;
                                namestail = l;
                            }
                            objtab[namestail].int1 = 0;
                            /* comment:Output the current node in this level */
                            pdfbegindict(l, 1);
                            j = 0;
                            if (isnames) {
                                objtab[l].int0 = destnames[k].objname;
                                pdfprint(/* str 'Names [' */ 1210);
                                do {
                                    pdfprintstr(destnames[k].objname);
                                    {
                                        {
                                            if (pdfosmode &&
                                                (1 + pdfptr > pdfbufsize))
                                                pdfosgetosbuf(1);
                                            else if (!pdfosmode &&
                                                     (1 > pdfbufsize))
                                                overflow(/* str 'PDF output
                                                            buffer' */
                                                         1004, pdfopbufsize);
                                            else if (!pdfosmode &&
                                                     (1 + pdfptr > pdfbufsize))
                                                pdfflush();
                                        }
                                        {
                                            pdfbuf[pdfptr] = /* str ' ' */ 32;
                                            incr(pdfptr);
                                        }
                                    }
                                    pdfprintint(destnames[k].objnum);
                                    pdfprint(/* str ' 0 R ' */ 1151);
                                    incr(j);
                                    incr(k);
                                } while (!((j == 6) || (k == pdfdestnamesptr)));
                                removelastspace();
                                {
                                    pdfprint(/* str ']' */ 93);
                                    {
                                        {
                                            if (pdfosmode &&
                                                (1 + pdfptr > pdfbufsize))
                                                pdfosgetosbuf(1);
                                            else if (!pdfosmode &&
                                                     (1 > pdfbufsize))
                                                overflow(/* str 'PDF output
                                                            buffer' */
                                                         1004, pdfopbufsize);
                                            else if (!pdfosmode &&
                                                     (1 + pdfptr > pdfbufsize))
                                                pdfflush();
                                        }
                                        {
                                            pdfbuf[pdfptr] = 10;
                                            incr(pdfptr);
                                        }
                                    }
                                }
                                objtab[l].int4 = destnames[k - 1].objname;
                                if (k == pdfdestnamesptr) {
                                    isnames = false;
                                    k = nameshead;
                                    b = 0;
                                }
                            } else {

                                objtab[l].int0 = objtab[k].int0;
                                pdfprint(/* str 'Kids [' */ 1208);
                                do {
                                    pdfprintint(k);
                                    pdfprint(/* str ' 0 R ' */ 1151);
                                    incr(j);
                                    objtab[l].int4 = objtab[k].int4;
                                    k = objtab[k].int1;
                                } while (!((j == 6) || (k == b) ||
                                           (objtab[k].int1 == 0)));
                                removelastspace();
                                {
                                    pdfprint(/* str ']' */ 93);
                                    {
                                        {
                                            if (pdfosmode &&
                                                (1 + pdfptr > pdfbufsize))
                                                pdfosgetosbuf(1);
                                            else if (!pdfosmode &&
                                                     (1 > pdfbufsize))
                                                overflow(/* str 'PDF output
                                                            buffer' */
                                                         1004, pdfopbufsize);
                                            else if (!pdfosmode &&
                                                     (1 + pdfptr > pdfbufsize))
                                                pdfflush();
                                        }
                                        {
                                            pdfbuf[pdfptr] = 10;
                                            incr(pdfptr);
                                        }
                                    }
                                }
                                if (k == b)
                                    b = 0;
                            }
                            pdfprint(/* str 'Limits [' */ 1211);
                            pdfprintstr(objtab[l].int0);
                            {
                                {
                                    if (pdfosmode && (1 + pdfptr > pdfbufsize))
                                        pdfosgetosbuf(1);
                                    else if (!pdfosmode && (1 > pdfbufsize))
                                        overflow(
                                            /* str 'PDF output buffer' */ 1004,
                                            pdfopbufsize);
                                    else if (!pdfosmode &&
                                             (1 + pdfptr > pdfbufsize))
                                        pdfflush();
                                }
                                {
                                    pdfbuf[pdfptr] = /* str ' ' */ 32;
                                    incr(pdfptr);
                                }
                            }
                            pdfprintstr(objtab[l].int4);
                            {
                                pdfprint(/* str ']' */ 93);
                                {
                                    {
                                        if (pdfosmode &&
                                            (1 + pdfptr > pdfbufsize))
                                            pdfosgetosbuf(1);
                                        else if (!pdfosmode && (1 > pdfbufsize))
                                            overflow(
                                                /* str 'PDF output buffer' */
                                                1004, pdfopbufsize);
                                        else if (!pdfosmode &&
                                                 (1 + pdfptr > pdfbufsize))
                                            pdfflush();
                                    }
                                    {
                                        pdfbuf[pdfptr] = 10;
                                        incr(pdfptr);
                                    }
                                }
                            }
                            pdfenddict();
                        } while (!(b == 0));
                        if (k == l) {
                            dests = l;
                            goto labclosefilesandterminate31done1;
                        }
                    } while (!(false));
                labclosefilesandterminate31done1:
                    if ((dests != 0) || (pdfnamestoks != TEXNULL)) {
                        pdfnewdict(0, 0, 1);
                        if ((dests != 0))
                            pdfindirectln(/* str 'Dests' */ 1209, dests);
                        if (pdfnamestoks != TEXNULL) {
                            pdfprinttoksln(pdfnamestoks);
                            {
                                deletetokenref(pdfnamestoks);
                                pdfnamestoks = TEXNULL;
                            }
                        }
                        pdfenddict();
                        namestree = objptr;
                    } else
                        namestree = 0;
                    /* comment:Output article threads */ if (headtab[9] != 0) {
                        pdfnewobj(0, 0, 1);
                        threads = objptr;
                        {
                            {
                                if (pdfosmode && (1 + pdfptr > pdfbufsize))
                                    pdfosgetosbuf(1);
                                else if (!pdfosmode && (1 > pdfbufsize))
                                    overflow(/* str 'PDF output buffer' */ 1004,
                                             pdfopbufsize);
                                else if (!pdfosmode &&
                                         (1 + pdfptr > pdfbufsize))
                                    pdfflush();
                            }
                            {
                                pdfbuf[pdfptr] = /* str '[' */ 91;
                                incr(pdfptr);
                            }
                        }
                        k = headtab[9];
                        while (k != 0) {

                            pdfprintint(k);
                            pdfprint(/* str ' 0 R ' */ 1151);
                            k = objtab[k].int1;
                        }
                        removelastspace();
                        {
                            pdfprint(/* str ']' */ 93);
                            {
                                {
                                    if (pdfosmode && (1 + pdfptr > pdfbufsize))
                                        pdfosgetosbuf(1);
                                    else if (!pdfosmode && (1 > pdfbufsize))
                                        overflow(
                                            /* str 'PDF output buffer' */ 1004,
                                            pdfopbufsize);
                                    else if (!pdfosmode &&
                                             (1 + pdfptr > pdfbufsize))
                                        pdfflush();
                                }
                                {
                                    pdfbuf[pdfptr] = 10;
                                    incr(pdfptr);
                                }
                            }
                        }
                        pdfendobj();
                        k = headtab[9];
                        while (k != 0) {

                            outthread(k);
                            k = objtab[k].int1;
                        }
                    } else
                        threads = 0;
                    /* comment:Output the catalog object */ pdfnewdict(0, 0, 1);
                    root = objptr;
                    {
                        pdfprint(/* str 'Type Catalog' */ 1212);
                        {
                            {
                                if (pdfosmode && (1 + pdfptr > pdfbufsize))
                                    pdfosgetosbuf(1);
                                else if (!pdfosmode && (1 > pdfbufsize))
                                    overflow(/* str 'PDF output buffer' */ 1004,
                                             pdfopbufsize);
                                else if (!pdfosmode &&
                                         (1 + pdfptr > pdfbufsize))
                                    pdfflush();
                            }
                            {
                                pdfbuf[pdfptr] = 10;
                                incr(pdfptr);
                            }
                        }
                    }
                    pdfindirectln(/* str 'Pages' */ 1213, pdflastpages);
                    if (threads != 0)
                        pdfindirectln(/* str 'Threads' */ 1214, threads);
                    if (outlines != 0)
                        pdfindirectln(/* str 'Outlines' */ 1215, outlines);
                    if (namestree != 0)
                        pdfindirectln(/* str 'Names' */ 1216, namestree);
                    if (pdfcatalogtoks != TEXNULL) {
                        pdfprinttoksln(pdfcatalogtoks);
                        {
                            deletetokenref(pdfcatalogtoks);
                            pdfcatalogtoks = TEXNULL;
                        }
                    }
                    if (pdfcatalogopenaction != 0)
                        pdfindirectln(/* str 'OpenAction' */ 1217,
                                      pdfcatalogopenaction);
                    pdfenddict();
                    pdfprintinfo();
                    if (pdfosenable) {
                        pdfosswitch(true);
                        pdfoswriteobjstream();
                        pdfflush();
                        pdfosswitch(false);
                        /* comment:Output the cross-reference stream dictionary
                         */
                        pdfnewdict(0, 0, 0);
                        if (((objtab[sysobjptr].int2 / ((double)256)) >
                             16777215L))
                            xrefoffsetwidth = 5;
                        else if (objtab[sysobjptr].int2 > 16777215L)
                            xrefoffsetwidth = 4;
                        else if (objtab[sysobjptr].int2 > 65535L)
                            xrefoffsetwidth = 3;
                        else
                            xrefoffsetwidth = 2;
                        /* comment:Build a linked list of free objects */ l = 0;
                        objtab[l].int2 = -2;
                        {
                            register integer for_end;
                            k = 1;
                            for_end = sysobjptr;
                            if (k <= for_end)
                                do
                                    if (!(objtab[k].int2 > -1)) {
                                        objtab[l].int1 = k;
                                        l = k;
                                    }
                                while (k++ < for_end);
                        }
                        objtab[l].int1 = 0;
                        {
                            pdfprint(/* str 'Type XRef' */ 1233);
                            {
                                {
                                    if (pdfosmode && (1 + pdfptr > pdfbufsize))
                                        pdfosgetosbuf(1);
                                    else if (!pdfosmode && (1 > pdfbufsize))
                                        overflow(
                                            /* str 'PDF output buffer' */ 1004,
                                            pdfopbufsize);
                                    else if (!pdfosmode &&
                                             (1 + pdfptr > pdfbufsize))
                                        pdfflush();
                                }
                                {
                                    pdfbuf[pdfptr] = 10;
                                    incr(pdfptr);
                                }
                            }
                        }
                        pdfprint(/* str 'Index [0 ' */ 1234);
                        pdfprintint(objptr + 1);
                        {
                            pdfprint(/* str ']' */ 93);
                            {
                                {
                                    if (pdfosmode && (1 + pdfptr > pdfbufsize))
                                        pdfosgetosbuf(1);
                                    else if (!pdfosmode && (1 > pdfbufsize))
                                        overflow(
                                            /* str 'PDF output buffer' */ 1004,
                                            pdfopbufsize);
                                    else if (!pdfosmode &&
                                             (1 + pdfptr > pdfbufsize))
                                        pdfflush();
                                }
                                {
                                    pdfbuf[pdfptr] = 10;
                                    incr(pdfptr);
                                }
                            }
                        }
                        pdfintentryln(/* str 'Size' */ 1235, objptr + 1);
                        pdfprint(/* str 'W [1 ' */ 1236);
                        pdfprintint(xrefoffsetwidth);
                        {
                            pdfprint(/* str ' 1]' */ 1237);
                            {
                                {
                                    if (pdfosmode && (1 + pdfptr > pdfbufsize))
                                        pdfosgetosbuf(1);
                                    else if (!pdfosmode && (1 > pdfbufsize))
                                        overflow(
                                            /* str 'PDF output buffer' */ 1004,
                                            pdfopbufsize);
                                    else if (!pdfosmode &&
                                             (1 + pdfptr > pdfbufsize))
                                        pdfflush();
                                }
                                {
                                    pdfbuf[pdfptr] = 10;
                                    incr(pdfptr);
                                }
                            }
                        }
                        pdfindirectln(/* str 'Root' */ 1238, root);
                        pdfindirectln(/* str 'Info' */ 1239, objptr - 1);
                        if (pdftrailertoks != TEXNULL) {
                            pdfprinttoksln(pdftrailertoks);
                            {
                                deletetokenref(pdftrailertoks);
                                pdftrailertoks = TEXNULL;
                            }
                        }
                        if (pdftraileridtoks != TEXNULL)
                            printIDalt(pdftraileridtoks);
                        else
                            printID(outputfilename);
                        {
                            {
                                if (pdfosmode && (1 + pdfptr > pdfbufsize))
                                    pdfosgetosbuf(1);
                                else if (!pdfosmode && (1 > pdfbufsize))
                                    overflow(/* str 'PDF output buffer' */ 1004,
                                             pdfopbufsize);
                                else if (!pdfosmode &&
                                         (1 + pdfptr > pdfbufsize))
                                    pdfflush();
                            }
                            {
                                pdfbuf[pdfptr] = 10;
                                incr(pdfptr);
                            }
                        }
                        pdfbeginstream();
                        {
                            register integer for_end;
                            k = 0;
                            for_end = sysobjptr;
                            if (k <= for_end)
                                do {
                                    if (!(objtab[k].int2 > -1)) {
                                        {
                                            {
                                                if (pdfosmode &&
                                                    (1 + pdfptr > pdfbufsize))
                                                    pdfosgetosbuf(1);
                                                else if (!pdfosmode &&
                                                         (1 > pdfbufsize))
                                                    overflow(/* str 'PDF output
                                                                buffer' */
                                                             1004,
                                                             pdfopbufsize);
                                                else if (!pdfosmode &&
                                                         (1 + pdfptr >
                                                          pdfbufsize))
                                                    pdfflush();
                                            }
                                            {
                                                pdfbuf[pdfptr] = 0;
                                                incr(pdfptr);
                                            }
                                        }
                                        pdfoutbytes(objtab[k].int1,
                                                    xrefoffsetwidth);
                                        {
                                            {
                                                if (pdfosmode &&
                                                    (1 + pdfptr > pdfbufsize))
                                                    pdfosgetosbuf(1);
                                                else if (!pdfosmode &&
                                                         (1 > pdfbufsize))
                                                    overflow(/* str 'PDF output
                                                                buffer' */
                                                             1004,
                                                             pdfopbufsize);
                                                else if (!pdfosmode &&
                                                         (1 + pdfptr >
                                                          pdfbufsize))
                                                    pdfflush();
                                            }
                                            {
                                                pdfbuf[pdfptr] = 255;
                                                incr(pdfptr);
                                            }
                                        }
                                    } else {

                                        if (objtab[k].int3 == -1) {
                                            {
                                                {
                                                    if (pdfosmode &&
                                                        (1 + pdfptr >
                                                         pdfbufsize))
                                                        pdfosgetosbuf(1);
                                                    else if (!pdfosmode &&
                                                             (1 > pdfbufsize))
                                                        overflow(
                                                            /* str 'PDF output
                                                               buffer' */
                                                            1004, pdfopbufsize);
                                                    else if (!pdfosmode &&
                                                             (1 + pdfptr >
                                                              pdfbufsize))
                                                        pdfflush();
                                                }
                                                {
                                                    pdfbuf[pdfptr] = 1;
                                                    incr(pdfptr);
                                                }
                                            }
                                            pdfoutbytes(objtab[k].int2,
                                                        xrefoffsetwidth);
                                            {
                                                {
                                                    if (pdfosmode &&
                                                        (1 + pdfptr >
                                                         pdfbufsize))
                                                        pdfosgetosbuf(1);
                                                    else if (!pdfosmode &&
                                                             (1 > pdfbufsize))
                                                        overflow(
                                                            /* str 'PDF output
                                                               buffer' */
                                                            1004, pdfopbufsize);
                                                    else if (!pdfosmode &&
                                                             (1 + pdfptr >
                                                              pdfbufsize))
                                                        pdfflush();
                                                }
                                                {
                                                    pdfbuf[pdfptr] = 0;
                                                    incr(pdfptr);
                                                }
                                            }
                                        } else {

                                            {
                                                {
                                                    if (pdfosmode &&
                                                        (1 + pdfptr >
                                                         pdfbufsize))
                                                        pdfosgetosbuf(1);
                                                    else if (!pdfosmode &&
                                                             (1 > pdfbufsize))
                                                        overflow(
                                                            /* str 'PDF output
                                                               buffer' */
                                                            1004, pdfopbufsize);
                                                    else if (!pdfosmode &&
                                                             (1 + pdfptr >
                                                              pdfbufsize))
                                                        pdfflush();
                                                }
                                                {
                                                    pdfbuf[pdfptr] = 2;
                                                    incr(pdfptr);
                                                }
                                            }
                                            pdfoutbytes(objtab[k].int2,
                                                        xrefoffsetwidth);
                                            {
                                                {
                                                    if (pdfosmode &&
                                                        (1 + pdfptr >
                                                         pdfbufsize))
                                                        pdfosgetosbuf(1);
                                                    else if (!pdfosmode &&
                                                             (1 > pdfbufsize))
                                                        overflow(
                                                            /* str 'PDF output
                                                               buffer' */
                                                            1004, pdfopbufsize);
                                                    else if (!pdfosmode &&
                                                             (1 + pdfptr >
                                                              pdfbufsize))
                                                        pdfflush();
                                                }
                                                {
                                                    pdfbuf[pdfptr] =
                                                        objtab[k].int3;
                                                    incr(pdfptr);
                                                }
                                            }
                                        }
                                    }
                                } while (k++ < for_end);
                        }
                        pdfendstream();
                        pdfflush();
                    } else {

                        /* comment:Output the |obj_tab| */
                        /* comment:Build a linked list of free objects */ l = 0;
                        objtab[l].int2 = -2;
                        {
                            register integer for_end;
                            k = 1;
                            for_end = sysobjptr;
                            if (k <= for_end)
                                do
                                    if (!(objtab[k].int2 > -1)) {
                                        objtab[l].int1 = k;
                                        l = k;
                                    }
                                while (k++ < for_end);
                        }
                        objtab[l].int1 = 0;
                        pdfsaveoffset = (pdfgone + pdfptr);
                        {
                            pdfprint(/* str 'xref' */ 1228);
                            {
                                {
                                    if (pdfosmode && (1 + pdfptr > pdfbufsize))
                                        pdfosgetosbuf(1);
                                    else if (!pdfosmode && (1 > pdfbufsize))
                                        overflow(
                                            /* str 'PDF output buffer' */ 1004,
                                            pdfopbufsize);
                                    else if (!pdfosmode &&
                                             (1 + pdfptr > pdfbufsize))
                                        pdfflush();
                                }
                                {
                                    pdfbuf[pdfptr] = 10;
                                    incr(pdfptr);
                                }
                            }
                        }
                        pdfprint(/* str '0 ' */ 1229);
                        {
                            pdfprintint(objptr + 1);
                            {
                                {
                                    if (pdfosmode && (1 + pdfptr > pdfbufsize))
                                        pdfosgetosbuf(1);
                                    else if (!pdfosmode && (1 > pdfbufsize))
                                        overflow(
                                            /* str 'PDF output buffer' */ 1004,
                                            pdfopbufsize);
                                    else if (!pdfosmode &&
                                             (1 + pdfptr > pdfbufsize))
                                        pdfflush();
                                }
                                {
                                    pdfbuf[pdfptr] = 10;
                                    incr(pdfptr);
                                }
                            }
                        }
                        pdfprintfwint(objtab[0].int1, 10);
                        {
                            pdfprint(/* str ' 65535 f ' */ 1230);
                            {
                                {
                                    if (pdfosmode && (1 + pdfptr > pdfbufsize))
                                        pdfosgetosbuf(1);
                                    else if (!pdfosmode && (1 > pdfbufsize))
                                        overflow(
                                            /* str 'PDF output buffer' */ 1004,
                                            pdfopbufsize);
                                    else if (!pdfosmode &&
                                             (1 + pdfptr > pdfbufsize))
                                        pdfflush();
                                }
                                {
                                    pdfbuf[pdfptr] = 10;
                                    incr(pdfptr);
                                }
                            }
                        }
                        {
                            register integer for_end;
                            k = 1;
                            for_end = objptr;
                            if (k <= for_end)
                                do {
                                    if (!(objtab[k].int2 > -1)) {
                                        pdfprintfwint(objtab[k].int1, 10);
                                        {
                                            pdfprint(
                                                /* str ' 00000 f ' */ 1231);
                                            {
                                                {
                                                    if (pdfosmode &&
                                                        (1 + pdfptr >
                                                         pdfbufsize))
                                                        pdfosgetosbuf(1);
                                                    else if (!pdfosmode &&
                                                             (1 > pdfbufsize))
                                                        overflow(
                                                            /* str 'PDF output
                                                               buffer' */
                                                            1004, pdfopbufsize);
                                                    else if (!pdfosmode &&
                                                             (1 + pdfptr >
                                                              pdfbufsize))
                                                        pdfflush();
                                                }
                                                {
                                                    pdfbuf[pdfptr] = 10;
                                                    incr(pdfptr);
                                                }
                                            }
                                        }
                                    } else {

                                        pdfprintfwint(objtab[k].int2, 10);
                                        {
                                            pdfprint(
                                                /* str ' 00000 n ' */ 1232);
                                            {
                                                {
                                                    if (pdfosmode &&
                                                        (1 + pdfptr >
                                                         pdfbufsize))
                                                        pdfosgetosbuf(1);
                                                    else if (!pdfosmode &&
                                                             (1 > pdfbufsize))
                                                        overflow(
                                                            /* str 'PDF output
                                                               buffer' */
                                                            1004, pdfopbufsize);
                                                    else if (!pdfosmode &&
                                                             (1 + pdfptr >
                                                              pdfbufsize))
                                                        pdfflush();
                                                }
                                                {
                                                    pdfbuf[pdfptr] = 10;
                                                    incr(pdfptr);
                                                }
                                            }
                                        }
                                    }
                                } while (k++ < for_end);
                        }
                    }
                    /* comment:Output the trailer */ if (!pdfosenable) {
                        {
                            pdfprint(/* str 'trailer' */ 1240);
                            {
                                {
                                    if (pdfosmode && (1 + pdfptr > pdfbufsize))
                                        pdfosgetosbuf(1);
                                    else if (!pdfosmode && (1 > pdfbufsize))
                                        overflow(
                                            /* str 'PDF output buffer' */ 1004,
                                            pdfopbufsize);
                                    else if (!pdfosmode &&
                                             (1 + pdfptr > pdfbufsize))
                                        pdfflush();
                                }
                                {
                                    pdfbuf[pdfptr] = 10;
                                    incr(pdfptr);
                                }
                            }
                        }
                        pdfprint(/* str '<< ' */ 1241);
                        pdfintentryln(/* str 'Size' */ 1235, sysobjptr + 1);
                        pdfindirectln(/* str 'Root' */ 1238, root);
                        pdfindirectln(/* str 'Info' */ 1239, sysobjptr);
                        if (pdftrailertoks != TEXNULL) {
                            pdfprinttoksln(pdftrailertoks);
                            {
                                deletetokenref(pdftrailertoks);
                                pdftrailertoks = TEXNULL;
                            }
                        }
                        if (pdftraileridtoks != TEXNULL)
                            printIDalt(pdftraileridtoks);
                        else
                            printID(outputfilename);
                        {
                            pdfprint(/* str ' >>' */ 1242);
                            {
                                {
                                    if (pdfosmode && (1 + pdfptr > pdfbufsize))
                                        pdfosgetosbuf(1);
                                    else if (!pdfosmode && (1 > pdfbufsize))
                                        overflow(
                                            /* str 'PDF output buffer' */ 1004,
                                            pdfopbufsize);
                                    else if (!pdfosmode &&
                                             (1 + pdfptr > pdfbufsize))
                                        pdfflush();
                                }
                                {
                                    pdfbuf[pdfptr] = 10;
                                    incr(pdfptr);
                                }
                            }
                        }
                    }
                    {
                        pdfprint(/* str 'startxref' */ 1243);
                        {
                            {
                                if (pdfosmode && (1 + pdfptr > pdfbufsize))
                                    pdfosgetosbuf(1);
                                else if (!pdfosmode && (1 > pdfbufsize))
                                    overflow(/* str 'PDF output buffer' */ 1004,
                                             pdfopbufsize);
                                else if (!pdfosmode &&
                                         (1 + pdfptr > pdfbufsize))
                                    pdfflush();
                            }
                            {
                                pdfbuf[pdfptr] = 10;
                                incr(pdfptr);
                            }
                        }
                    }
                    if (pdfosenable) {
                        pdfprintint(objtab[sysobjptr].int2);
                        {
                            {
                                if (pdfosmode && (1 + pdfptr > pdfbufsize))
                                    pdfosgetosbuf(1);
                                else if (!pdfosmode && (1 > pdfbufsize))
                                    overflow(/* str 'PDF output buffer' */ 1004,
                                             pdfopbufsize);
                                else if (!pdfosmode &&
                                         (1 + pdfptr > pdfbufsize))
                                    pdfflush();
                            }
                            {
                                pdfbuf[pdfptr] = 10;
                                incr(pdfptr);
                            }
                        }
                    } else {

                        pdfprintint(pdfsaveoffset);
                        {
                            {
                                if (pdfosmode && (1 + pdfptr > pdfbufsize))
                                    pdfosgetosbuf(1);
                                else if (!pdfosmode && (1 > pdfbufsize))
                                    overflow(/* str 'PDF output buffer' */ 1004,
                                             pdfopbufsize);
                                else if (!pdfosmode &&
                                         (1 + pdfptr > pdfbufsize))
                                    pdfflush();
                            }
                            {
                                pdfbuf[pdfptr] = 10;
                                incr(pdfptr);
                            }
                        }
                    }
                    {
                        pdfprint(/* str '%%EOF' */ 1244);
                        {
                            {
                                if (pdfosmode && (1 + pdfptr > pdfbufsize))
                                    pdfosgetosbuf(1);
                                else if (!pdfosmode && (1 > pdfbufsize))
                                    overflow(/* str 'PDF output buffer' */ 1004,
                                             pdfopbufsize);
                                else if (!pdfosmode &&
                                         (1 + pdfptr > pdfbufsize))
                                    pdfflush();
                            }
                            {
                                pdfbuf[pdfptr] = 10;
                                incr(pdfptr);
                            }
                        }
                    }
                    pdfflush();
                    printnl(/* str 'Output written on ' */ 997);
                    printfilename(0, outputfilename, 0);
                    print(/* str ' (' */ 286);
                    printint(totalpages);
                    print(/* str ' page' */ 999);
                    if (totalpages != 1)
                        printchar(/* str 's' */ 115);
                    print(/* str ', ' */ 1000);
                    printint((pdfgone + pdfptr));
                    print(/* str ' bytes).' */ 1001);
                }
                libpdffinish();
                if (fixedpdfdraftmode == 0)
                    bclose(pdffile);
                else
                    pdfwarning(0, /* str '\pdfdraftmode enabled, not changing
                                     output pdf' */
                               1195, true, true);
            }
            if (logopened) {
                putc('\n', logfile);
                fprintf(logfile, "%s\n", "PDF statistics:");
                fprintf(logfile, "%c%ld%s%ld%s%ld%c\n", ' ', (long)objptr,
                        " PDF objects out of ", (long)objtabsize, " (max. ",
                        (long)supobjtabsize, ')');
                if (pdfoscntr > 0) {
                    fprintf(logfile, "%c%ld%s%ld%s", ' ',
                            (long)((pdfoscntr - 1) * pdfosmaxobjs +
                                   pdfosobjidx + 1),
                            " compressed objects within ", (long)pdfoscntr,
                            " object stream");
                    if (pdfoscntr > 1)
                        putc('s', logfile);
                    putc('\n', logfile);
                }
                fprintf(logfile, "%c%ld%s%ld%s%ld%c\n", ' ',
                        (long)pdfdestnamesptr, " named destinations out of ",
                        (long)destnamessize, " (max. ", (long)supdestnamessize,
                        ')');
                fprintf(logfile, "%c%ld%s%ld%s%ld%c\n", ' ', (long)pdfmemptr,
                        " words of extra memory for PDF output out of ",
                        (long)pdfmemsize, " (max. ", (long)suppdfmemsize, ')');
            }
        }
    } else {

        /* comment:Finish the \.{DVI} file */ while (curs > -1) {

            if (curs > 0) {
                dvibuf[dviptr] = POP;
                incr(dviptr);
                if (dviptr == dvilimit)
                    dviswap();
            } else {

                {
                    dvibuf[dviptr] = EOP;
                    incr(dviptr);
                    if (dviptr == dvilimit)
                        dviswap();
                }
                incr(totalpages);
            }
            decr(curs);
        }
        if (totalpages == 0)
            printnl(/* str 'No pages of output.' */ 996);
        else if (curs != -2) {
            {
                dvibuf[dviptr] = POST;
                incr(dviptr);
                if (dviptr == dvilimit)
                    dviswap();
            }
            dvifour(lastbop);
            lastbop = dvioffset + dviptr - 5;
            dvifour(25400000L);
            dvifour(473628672L);
            preparemag();
            dvifour(eqtb[INTBASE + MAGCODE].cint);
            dvifour(maxv);
            dvifour(maxh);
            {
                dvibuf[dviptr] = maxpush / 256;
                incr(dviptr);
                if (dviptr == dvilimit)
                    dviswap();
            }
            {
                dvibuf[dviptr] = maxpush % 256;
                incr(dviptr);
                if (dviptr == dvilimit)
                    dviswap();
            }
            {
                dvibuf[dviptr] = (totalpages / 256) % 256;
                incr(dviptr);
                if (dviptr == dvilimit)
                    dviswap();
            }
            {
                dvibuf[dviptr] = totalpages % 256;
                incr(dviptr);
                if (dviptr == dvilimit)
                    dviswap();
            }
            /* comment:Output the font definitions for all fonts that wer */
            while (fontptr > FONTBASE) {

                if (fontused[fontptr])
                    dvifontdef(fontptr);
                decr(fontptr);
            }
            {
                dvibuf[dviptr] = POSTPOST;
                incr(dviptr);
                if (dviptr == dvilimit)
                    dviswap();
            }
            dvifour(lastbop);
            {
                dvibuf[dviptr] = IDBYTE;
                incr(dviptr);
                if (dviptr == dvilimit)
                    dviswap();
            };
#ifdef IPC
            k = 7 - ((3 + dvioffset + dviptr) % 4);
#endif /* IPC */
            ;
#ifndef IPC
            k = 4 + ((dvibufsize - dviptr) % 4);
#endif /* not IPC */
            while (k > 0) {

                {
                    dvibuf[dviptr] = 223;
                    incr(dviptr);
                    if (dviptr == dvilimit)
                        dviswap();
                }
                decr(k);
            }
            /* comment:Empty the last bytes out of |dvi_buf| */ if (dvilimit ==
                                                                    halfbuf)
                writedvi(halfbuf, dvibufsize - 1);
            if (dviptr > (2147483647L - dvioffset)) {
                curs = -2;
                fatalerror(/* str 'dvi length exceeds ""7FFFFFFF' */ 985);
            }
            if (dviptr > 0)
                writedvi(0, dviptr - 1);
            printnl(/* str 'Output written on ' */ 997);
            printfilename(0, outputfilename, 0);
            print(/* str ' (' */ 286);
            printint(totalpages);
            if (totalpages != 1)
                print(/* str ' pages' */ 998);
            else
                print(/* str ' page' */ 999);
            print(/* str ', ' */ 1000);
            printint(dvioffset + dviptr);
            print(/* str ' bytes).' */ 1001);
            bclose(dvifile);
        }
    }
    if (logopened) {
        putc('\n', logfile);
        aclose(logfile);
        selector = selector - 2;
        if (selector == TERMONLY) {
            printnl(/* str 'Transcript written on ' */ 1722);
            printfilename(0, texmflogname, 0);
            printchar(/* str '.' */ 46);
        }
    }
    println();
    if ((editnamestart != 0) && (interaction > BATCHMODE))
        calledit(strpool, editnamestart, editnamelength, editline);
}
strnumber getnullstr(void) {
    register strnumber Result;
    getnullstr_regmem Result = /* str '' */ 345;
    return Result;
}
